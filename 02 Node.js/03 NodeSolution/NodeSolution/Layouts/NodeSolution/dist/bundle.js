/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@pnp/common/dist/common.es5.js":
/*!*****************************************************!*\
  !*** ./node_modules/@pnp/common/dist/common.es5.js ***!
  \*****************************************************/
/*! exports provided: AdalClient, objectToMap, mergeMaps, setup, RuntimeConfigImpl, RuntimeConfig, mergeHeaders, mergeOptions, FetchClient, BearerTokenFetchClient, PnPClientStorageWrapper, PnPClientStorage, getCtxCallback, dateAdd, combine, getRandomString, getGUID, isFunc, objectDefinedNotNull, isArray, extend, isUrlAbsolute, stringIsNullOrEmpty, getAttrValueFromString, sanitizeGuid, jsS, hOP, getHashCode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdalClient", function() { return AdalClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectToMap", function() { return objectToMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeMaps", function() { return mergeMaps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setup", function() { return setup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RuntimeConfigImpl", function() { return RuntimeConfigImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RuntimeConfig", function() { return RuntimeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeHeaders", function() { return mergeHeaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeOptions", function() { return mergeOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchClient", function() { return FetchClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BearerTokenFetchClient", function() { return BearerTokenFetchClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PnPClientStorageWrapper", function() { return PnPClientStorageWrapper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PnPClientStorage", function() { return PnPClientStorage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCtxCallback", function() { return getCtxCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dateAdd", function() { return dateAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combine", function() { return combine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomString", function() { return getRandomString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGUID", function() { return getGUID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFunc", function() { return isFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectDefinedNotNull", function() { return objectDefinedNotNull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUrlAbsolute", function() { return isUrlAbsolute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringIsNullOrEmpty", function() { return stringIsNullOrEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAttrValueFromString", function() { return getAttrValueFromString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeGuid", function() { return sanitizeGuid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jsS", function() { return jsS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hOP", function() { return hOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHashCode", function() { return getHashCode; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var adal_angular_dist_adal_min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! adal-angular/dist/adal.min.js */ "./node_modules/adal-angular/dist/adal.min.js");
/* harmony import */ var adal_angular_dist_adal_min_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(adal_angular_dist_adal_min_js__WEBPACK_IMPORTED_MODULE_1__);
/**
@license
 * @pnp/common v1.2.3 - pnp - provides shared functionality across all pnp libraries
 * MIT (https://github.com/pnp/pnpjs/blob/master/LICENSE)
 * Copyright (c) 2018 Microsoft
 * docs: https://pnp.github.io/pnpjs/
 * source: https:github.com/pnp/pnpjs
 * bugs: https://github.com/pnp/pnpjs/issues
 */



var global$1 = (typeof global !== "undefined" ? global :
            typeof self !== "undefined" ? self :
            typeof window !== "undefined" ? window : {});

/**
 * Gets a callback function which will maintain context across async calls.
 * Allows for the calling pattern getCtxCallback(thisobj, method, methodarg1, methodarg2, ...)
 *
 * @param context The object that will be the 'this' value in the callback
 * @param method The method to which we will apply the context and parameters
 * @param params Optional, additional arguments to supply to the wrapped method when it is invoked
 */
function getCtxCallback(context, method) {
    var params = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        params[_i - 2] = arguments[_i];
    }
    return function () {
        method.apply(context, params);
    };
}
/**
 * Adds a value to a date
 *
 * @param date The date to which we will add units, done in local time
 * @param interval The name of the interval to add, one of: ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second']
 * @param units The amount to add to date of the given interval
 *
 * http://stackoverflow.com/questions/1197928/how-to-add-30-minutes-to-a-javascript-date-object
 */
function dateAdd(date, interval, units) {
    var ret = new Date(date); // don't change original date
    switch (interval.toLowerCase()) {
        case "year":
            ret.setFullYear(ret.getFullYear() + units);
            break;
        case "quarter":
            ret.setMonth(ret.getMonth() + 3 * units);
            break;
        case "month":
            ret.setMonth(ret.getMonth() + units);
            break;
        case "week":
            ret.setDate(ret.getDate() + 7 * units);
            break;
        case "day":
            ret.setDate(ret.getDate() + units);
            break;
        case "hour":
            ret.setTime(ret.getTime() + units * 3600000);
            break;
        case "minute":
            ret.setTime(ret.getTime() + units * 60000);
            break;
        case "second":
            ret.setTime(ret.getTime() + units * 1000);
            break;
        default:
            ret = undefined;
            break;
    }
    return ret;
}
/**
 * Combines an arbitrary set of paths ensuring and normalizes the slashes
 *
 * @param paths 0 to n path parts to combine
 */
function combine() {
    var paths = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        paths[_i] = arguments[_i];
    }
    return paths
        .filter(function (path) { return !stringIsNullOrEmpty(path); })
        .map(function (path) { return path.replace(/^[\\|\/]/, "").replace(/[\\|\/]$/, ""); })
        .join("/")
        .replace(/\\/g, "/");
}
/**
 * Gets a random string of chars length
 *
 * https://stackoverflow.com/questions/1349404/generate-random-string-characters-in-javascript
 *
 * @param chars The length of the random string to generate
 */
function getRandomString(chars) {
    var text = new Array(chars);
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < chars; i++) {
        text[i] = possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text.join("");
}
/**
 * Gets a random GUID value
 *
 * http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 */
/* tslint:disable no-bitwise */
function getGUID() {
    var d = new Date().getTime();
    var guid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
    });
    return guid;
}
/* tslint:enable */
/**
 * Determines if a given value is a function
 *
 * @param cf The thing to test for functionness
 */
function isFunc(cf) {
    return typeof cf === "function";
}
/**
 * Determines if an object is both defined and not null
 * @param obj Object to test
 */
function objectDefinedNotNull(obj) {
    return typeof obj !== "undefined" && obj !== null;
}
/**
 * @returns whether the provided parameter is a JavaScript Array or not.
*/
function isArray(array) {
    if (Array.isArray) {
        return Array.isArray(array);
    }
    return array && typeof array.length === "number" && array.constructor === Array;
}
/**
 * Provides functionality to extend the given object by doing a shallow copy
 *
 * @param target The object to which properties will be copied
 * @param source The source object from which properties will be copied
 * @param noOverwrite If true existing properties on the target are not overwritten from the source
 * @param filter If provided allows additional filtering on what properties are copied (propName: string) => boolean
 *
 */
function extend(target, source, noOverwrite, filter) {
    if (noOverwrite === void 0) { noOverwrite = false; }
    if (filter === void 0) { filter = function () { return true; }; }
    if (!objectDefinedNotNull(source)) {
        return target;
    }
    // ensure we don't overwrite things we don't want overwritten
    var check = noOverwrite ? function (o, i) { return !(i in o); } : function () { return true; };
    // final filter we will use
    var f = function (v) { return check(target, v) && filter(v); };
    return Object.getOwnPropertyNames(source)
        .filter(f)
        .reduce(function (t, v) {
        t[v] = source[v];
        return t;
    }, target);
}
/**
 * Determines if a given url is absolute
 *
 * @param url The url to check to see if it is absolute
 */
function isUrlAbsolute(url) {
    return /^https?:\/\/|^\/\//i.test(url);
}
/**
 * Determines if a string is null or empty or undefined
 *
 * @param s The string to test
 */
function stringIsNullOrEmpty(s) {
    return s === undefined || s === null || s.length < 1;
}
/**
 * Gets an attribute value from an html/xml string block. NOTE: if the input attribute value has
 * RegEx special characters they will be escaped in the returned string
 *
 * @param html HTML to search
 * @param attrName The name of the attribute to find
 */
function getAttrValueFromString(html, attrName) {
    // make the input safe for regex
    html = html.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    var reg = new RegExp(attrName + "\\s*?=\\s*?(\"|')([^\\1]*?)\\1", "i");
    var match = reg.exec(html);
    return match !== null && match.length > 0 ? match[2] : null;
}
/**
 * Ensures guid values are represented consistently as "ea123463-137d-4ae3-89b8-cf3fc578ca05"
 *
 * @param guid The candidate guid
 */
function sanitizeGuid(guid) {
    if (stringIsNullOrEmpty(guid)) {
        return guid;
    }
    var matches = /([0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12})/i.exec(guid);
    return matches === null ? guid : matches[1];
}
/**
 * Shorthand for oToS
 *
 * @param o Any type of object
 */
function jsS(o) {
    return JSON.stringify(o);
}
/**
 * Shorthand for Object.hasOwnProperty
 *
 * @param o Object to check for
 * @param p Name of the property
 */
function hOP(o, p) {
    return Object.hasOwnProperty.call(o, p);
}
/**
 * Generates a ~unique hash code for this ObjectPathQueue
 *
 * From: https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript
 */
// tslint:disable:no-bitwise
function getHashCode(s) {
    var hash = 0;
    if (s.length === 0) {
        return hash;
    }
    for (var i = 0; i < s.length; i++) {
        var chr = s.charCodeAt(i);
        hash = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}
// tslint:enable:no-bitwise

function mergeHeaders(target, source) {
    if (source !== undefined && source !== null) {
        var temp = new Request("", { headers: source });
        temp.headers.forEach(function (value, name) {
            target.append(name, value);
        });
    }
}
function mergeOptions(target, source) {
    if (objectDefinedNotNull(source)) {
        var headers = extend(target.headers || {}, source.headers);
        target = extend(target, source);
        target.headers = headers;
    }
}
/**
 * Makes requests using the global/window fetch API
 */
var FetchClient = /** @class */ (function () {
    function FetchClient() {
    }
    FetchClient.prototype.fetch = function (url, options) {
        return global$1.fetch(url, options);
    };
    return FetchClient;
}());
/**
 * Makes requests using the fetch API adding the supplied token to the Authorization header
 */
var BearerTokenFetchClient = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(BearerTokenFetchClient, _super);
    function BearerTokenFetchClient(_token) {
        var _this = _super.call(this) || this;
        _this._token = _token;
        return _this;
    }
    Object.defineProperty(BearerTokenFetchClient.prototype, "token", {
        get: function () {
            return this._token || "";
        },
        set: function (token) {
            this._token = token;
        },
        enumerable: true,
        configurable: true
    });
    BearerTokenFetchClient.prototype.fetch = function (url, options) {
        if (options === void 0) { options = {}; }
        var headers = new Headers();
        mergeHeaders(headers, options.headers);
        headers.set("Authorization", "Bearer " + this._token);
        options.headers = headers;
        return _super.prototype.fetch.call(this, url, options);
    };
    return BearerTokenFetchClient;
}(FetchClient));

/**
 * Azure AD Client for use in the browser
 */
var AdalClient = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(AdalClient, _super);
    /**
     * Creates a new instance of AdalClient
     * @param clientId Azure App Id
     * @param tenant Office 365 tenant (Ex: {tenant}.onmicrosoft.com)
     * @param redirectUri The redirect url used to authenticate the
     */
    function AdalClient(clientId, tenant, redirectUri) {
        var _this = _super.call(this, null) || this;
        _this.clientId = clientId;
        _this.tenant = tenant;
        _this.redirectUri = redirectUri;
        _this._displayCallback = null;
        _this._loginPromise = null;
        return _this;
    }
    /**
     * Creates a new AdalClient using the values of the supplied SPFx context
     *
     * @param spfxContext Current SPFx context
     * @param clientId Optional client id to use instead of the built-in SPFx id
     * @description Using this method and the default clientId requires that the features described in
     * this article https://docs.microsoft.com/en-us/sharepoint/dev/spfx/use-aadhttpclient are activated in the tenant. If not you can
     * creat your own app, grant permissions and use that clientId here along with the SPFx context
     */
    AdalClient.fromSPFxContext = function (spfxContext, cliendId) {
        if (cliendId === void 0) { cliendId = "c58637bb-e2e1-4312-8a00-04b5ffcd3403"; }
        // this "magic" client id is the one to which permissions are granted behind the scenes
        // this redirectUrl is the page as used by spfx
        return new AdalClient(cliendId, spfxContext.pageContext.aadInfo.tenantId.toString(), combine(window.location.origin, "/_forms/spfxsinglesignon.aspx"));
    };
    /**
     * Conducts the fetch opertation against the AAD secured resource
     *
     * @param url Absolute URL for the request
     * @param options Any fetch options passed to the underlying fetch implementation
     */
    AdalClient.prototype.fetch = function (url, options) {
        var _this = this;
        if (!isUrlAbsolute(url)) {
            throw Error("You must supply absolute urls to AdalClient.fetch.");
        }
        // the url we are calling is the resource
        return this.getToken(this.getResource(url)).then(function (token) {
            _this.token = token;
            return _super.prototype.fetch.call(_this, url, options);
        });
    };
    /**
     * Gets a token based on the current user
     *
     * @param resource The resource for which we are requesting a token
     */
    AdalClient.prototype.getToken = function (resource) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.ensureAuthContext().then(function (_) { return _this.login(); }).then(function (_) {
                AdalClient._authContext.acquireToken(resource, function (message, token) {
                    if (message) {
                        return reject(Error(message));
                    }
                    resolve(token);
                });
            }).catch(reject);
        });
    };
    /**
     * Ensures we have created and setup the adal AuthenticationContext instance
     */
    AdalClient.prototype.ensureAuthContext = function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (AdalClient._authContext === null) {
                AdalClient._authContext = Object(adal_angular_dist_adal_min_js__WEBPACK_IMPORTED_MODULE_1__["inject"])({
                    clientId: _this.clientId,
                    displayCall: function (url) {
                        if (_this._displayCallback) {
                            _this._displayCallback(url);
                        }
                    },
                    navigateToLoginRequestUrl: false,
                    redirectUri: _this.redirectUri,
                    tenant: _this.tenant,
                });
            }
            resolve();
        });
    };
    /**
     * Ensures the current user is logged in
     */
    AdalClient.prototype.login = function () {
        var _this = this;
        if (this._loginPromise) {
            return this._loginPromise;
        }
        this._loginPromise = new Promise(function (resolve, reject) {
            if (AdalClient._authContext.getCachedUser()) {
                return resolve();
            }
            _this._displayCallback = function (url) {
                var popupWindow = window.open(url, "login", "width=483, height=600");
                if (!popupWindow) {
                    return reject(Error("Could not open pop-up window for auth. Likely pop-ups are blocked by the browser."));
                }
                if (popupWindow && popupWindow.focus) {
                    popupWindow.focus();
                }
                var pollTimer = window.setInterval(function () {
                    if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {
                        window.clearInterval(pollTimer);
                    }
                    try {
                        if (popupWindow.document.URL.indexOf(_this.redirectUri) !== -1) {
                            window.clearInterval(pollTimer);
                            AdalClient._authContext.handleWindowCallback(popupWindow.location.hash);
                            popupWindow.close();
                            resolve();
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                }, 30);
            };
            // this triggers the login process
            _this.ensureAuthContext().then(function (_) {
                AdalClient._authContext._loginInProgress = false;
                AdalClient._authContext.login();
                _this._displayCallback = null;
            });
        });
        return this._loginPromise;
    };
    /**
     * Parses out the root of the request url to use as the resource when getting the token
     *
     * After: https://gist.github.com/jlong/2428561
     * @param url The url to parse
     */
    AdalClient.prototype.getResource = function (url) {
        var parser = document.createElement("a");
        parser.href = url;
        return parser.protocol + "//" + parser.hostname;
    };
    /**
     * Our auth context
     */
    AdalClient._authContext = null;
    return AdalClient;
}(BearerTokenFetchClient));

/**
 * Used to calculate the object properties, with polyfill if needed
 */
var objectEntries = isFunc(Object.entries) ? Object.entries : function (o) { return Object.keys(o).map(function (k) { return [k, o[k]]; }); };
/**
 * Converts the supplied object to a map
 *
 * @param o The object to map
 */
function objectToMap(o) {
    if (o !== undefined && o !== null) {
        return new Map(objectEntries(o));
    }
    return new Map();
}
/**
 * Merges to Map instances together, overwriting values in target with matching keys, last in wins
 *
 * @param target map into which the other maps are merged
 * @param maps One or more maps to merge into the target
 */
function mergeMaps(target) {
    var maps = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        maps[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < maps.length; i++) {
        maps[i].forEach(function (v, k) {
            target.set(k, v);
        });
    }
    return target;
}

function setup(config) {
    RuntimeConfig.extend(config);
}
// lable mapping for known config values
var s = [
    "defaultCachingStore",
    "defaultCachingTimeoutSeconds",
    "globalCacheDisable",
    "enableCacheExpiration",
    "cacheExpirationIntervalMilliseconds",
    "spfxContext",
];
var RuntimeConfigImpl = /** @class */ (function () {
    function RuntimeConfigImpl(_v) {
        if (_v === void 0) { _v = new Map(); }
        this._v = _v;
        // setup defaults
        this._v.set(s[0], "session");
        this._v.set(s[1], 60);
        this._v.set(s[2], false);
        this._v.set(s[3], false);
        this._v.set(s[4], 750);
        this._v.set(s[5], null);
    }
    /**
     *
     * @param config The set of properties to add to the globa configuration instance
     */
    RuntimeConfigImpl.prototype.extend = function (config) {
        this._v = mergeMaps(this._v, objectToMap(config));
    };
    RuntimeConfigImpl.prototype.get = function (key) {
        return this._v.get(key);
    };
    Object.defineProperty(RuntimeConfigImpl.prototype, "defaultCachingStore", {
        get: function () {
            return this.get(s[0]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuntimeConfigImpl.prototype, "defaultCachingTimeoutSeconds", {
        get: function () {
            return this.get(s[1]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuntimeConfigImpl.prototype, "globalCacheDisable", {
        get: function () {
            return this.get(s[2]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuntimeConfigImpl.prototype, "enableCacheExpiration", {
        get: function () {
            return this.get(s[3]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuntimeConfigImpl.prototype, "cacheExpirationIntervalMilliseconds", {
        get: function () {
            return this.get(s[4]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RuntimeConfigImpl.prototype, "spfxContext", {
        get: function () {
            return this.get(s[5]);
        },
        enumerable: true,
        configurable: true
    });
    return RuntimeConfigImpl;
}());
var _runtimeConfig = new RuntimeConfigImpl();
var RuntimeConfig = _runtimeConfig;

/**
 * A wrapper class to provide a consistent interface to browser based storage
 *
 */
var PnPClientStorageWrapper = /** @class */ (function () {
    /**
     * Creates a new instance of the PnPClientStorageWrapper class
     *
     * @constructor
     */
    function PnPClientStorageWrapper(store, defaultTimeoutMinutes) {
        if (defaultTimeoutMinutes === void 0) { defaultTimeoutMinutes = -1; }
        this.store = store;
        this.defaultTimeoutMinutes = defaultTimeoutMinutes;
        this.enabled = this.test();
        // if the cache timeout is enabled call the handler
        // this will clear any expired items and set the timeout function
        if (RuntimeConfig.enableCacheExpiration) {
            this.cacheExpirationHandler();
        }
    }
    /**
     * Get a value from storage, or null if that value does not exist
     *
     * @param key The key whose value we want to retrieve
     */
    PnPClientStorageWrapper.prototype.get = function (key) {
        if (!this.enabled) {
            return null;
        }
        var o = this.store.getItem(key);
        if (!objectDefinedNotNull(o)) {
            return null;
        }
        var persistable = JSON.parse(o);
        if (new Date(persistable.expiration) <= new Date()) {
            this.delete(key);
            return null;
        }
        else {
            return persistable.value;
        }
    };
    /**
     * Adds a value to the underlying storage
     *
     * @param key The key to use when storing the provided value
     * @param o The value to store
     * @param expire Optional, if provided the expiration of the item, otherwise the default is used
     */
    PnPClientStorageWrapper.prototype.put = function (key, o, expire) {
        if (this.enabled) {
            this.store.setItem(key, this.createPersistable(o, expire));
        }
    };
    /**
     * Deletes a value from the underlying storage
     *
     * @param key The key of the pair we want to remove from storage
     */
    PnPClientStorageWrapper.prototype.delete = function (key) {
        if (this.enabled) {
            this.store.removeItem(key);
        }
    };
    /**
     * Gets an item from the underlying storage, or adds it if it does not exist using the supplied getter function
     *
     * @param key The key to use when storing the provided value
     * @param getter A function which will upon execution provide the desired value
     * @param expire Optional, if provided the expiration of the item, otherwise the default is used
     */
    PnPClientStorageWrapper.prototype.getOrPut = function (key, getter, expire) {
        var _this = this;
        if (!this.enabled) {
            return getter();
        }
        return new Promise(function (resolve) {
            var o = _this.get(key);
            if (o == null) {
                getter().then(function (d) {
                    _this.put(key, d, expire);
                    resolve(d);
                });
            }
            else {
                resolve(o);
            }
        });
    };
    /**
     * Deletes any expired items placed in the store by the pnp library, leaves other items untouched
     */
    PnPClientStorageWrapper.prototype.deleteExpired = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this.enabled) {
                resolve();
            }
            try {
                for (var i = 0; i < _this.store.length; i++) {
                    var key = _this.store.key(i);
                    if (key !== null) {
                        // test the stored item to see if we stored it
                        if (/["|']?pnp["|']? ?: ?1/i.test(_this.store.getItem(key))) {
                            // get those items as get will delete from cache if they are expired
                            _this.get(key);
                        }
                    }
                }
                resolve();
            }
            catch (e) {
                reject(e);
            }
        });
    };
    /**
     * Used to determine if the wrapped storage is available currently
     */
    PnPClientStorageWrapper.prototype.test = function () {
        var str = "t";
        try {
            this.store.setItem(str, str);
            this.store.removeItem(str);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Creates the persistable to store
     */
    PnPClientStorageWrapper.prototype.createPersistable = function (o, expire) {
        if (expire === undefined) {
            // ensure we are by default inline with the global library setting
            var defaultTimeout = RuntimeConfig.defaultCachingTimeoutSeconds;
            if (this.defaultTimeoutMinutes > 0) {
                defaultTimeout = this.defaultTimeoutMinutes * 60;
            }
            expire = dateAdd(new Date(), "second", defaultTimeout);
        }
        return jsS({ pnp: 1, expiration: expire, value: o });
    };
    /**
     * Deletes expired items added by this library in this.store and sets a timeout to call itself
     */
    PnPClientStorageWrapper.prototype.cacheExpirationHandler = function () {
        var _this = this;
        this.deleteExpired().then(function (_) {
            // call ourself in the future
            setTimeout(getCtxCallback(_this, _this.cacheExpirationHandler), RuntimeConfig.cacheExpirationIntervalMilliseconds);
        }).catch(function (e) {
            console.error(e);
        });
    };
    return PnPClientStorageWrapper;
}());
/**
 * A thin implementation of in-memory storage for use in nodejs
 */
var MemoryStorage = /** @class */ (function () {
    function MemoryStorage(_store) {
        if (_store === void 0) { _store = new Map(); }
        this._store = _store;
    }
    Object.defineProperty(MemoryStorage.prototype, "length", {
        get: function () {
            return this._store.size;
        },
        enumerable: true,
        configurable: true
    });
    MemoryStorage.prototype.clear = function () {
        this._store.clear();
    };
    MemoryStorage.prototype.getItem = function (key) {
        return this._store.get(key);
    };
    MemoryStorage.prototype.key = function (index) {
        return Array.from(this._store)[index][0];
    };
    MemoryStorage.prototype.removeItem = function (key) {
        this._store.delete(key);
    };
    MemoryStorage.prototype.setItem = function (key, data) {
        this._store.set(key, data);
    };
    return MemoryStorage;
}());
/**
 * A class that will establish wrappers for both local and session storage
 */
var PnPClientStorage = /** @class */ (function () {
    /**
     * Creates a new instance of the PnPClientStorage class
     *
     * @constructor
     */
    function PnPClientStorage(_local, _session) {
        if (_local === void 0) { _local = null; }
        if (_session === void 0) { _session = null; }
        this._local = _local;
        this._session = _session;
    }
    Object.defineProperty(PnPClientStorage.prototype, "local", {
        /**
         * Provides access to the local storage of the browser
         */
        get: function () {
            if (this._local === null) {
                this._local = this.getStore("local");
            }
            return this._local;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PnPClientStorage.prototype, "session", {
        /**
         * Provides access to the session storage of the browser
         */
        get: function () {
            if (this._session === null) {
                this._session = this.getStore("session");
            }
            return this._session;
        },
        enumerable: true,
        configurable: true
    });
    PnPClientStorage.prototype.getStore = function (name) {
        if (name === "local") {
            return new PnPClientStorageWrapper(typeof (localStorage) === "undefined" ? new MemoryStorage() : localStorage);
        }
        return new PnPClientStorageWrapper(typeof (sessionStorage) === "undefined" ? new MemoryStorage() : sessionStorage);
    };
    return PnPClientStorage;
}());


//# sourceMappingURL=common.es5.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@pnp/logging/dist/logging.es5.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pnp/logging/dist/logging.es5.js ***!
  \*******************************************************/
/*! exports provided: Logger, LogLevel, ConsoleListener, FunctionListener */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLevel", function() { return LogLevel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleListener", function() { return ConsoleListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FunctionListener", function() { return FunctionListener; });
/**
@license
 * @pnp/logging v1.2.3 - pnp - light-weight, subscribable logging framework
 * MIT (https://github.com/pnp/pnpjs/blob/master/LICENSE)
 * Copyright (c) 2018 Microsoft
 * docs: https://pnp.github.io/pnpjs/
 * source: https:github.com/pnp/pnpjs
 * bugs: https://github.com/pnp/pnpjs/issues
 */
/**
 * Class used to subscribe ILogListener and log messages throughout an application
 *
 */
var Logger = /** @class */ (function () {
    function Logger() {
    }
    Object.defineProperty(Logger, "activeLogLevel", {
        /**
         * Gets or sets the active log level to apply for log filtering
         */
        get: function () {
            return Logger.instance.activeLogLevel;
        },
        set: function (value) {
            Logger.instance.activeLogLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Logger, "instance", {
        get: function () {
            if (Logger._instance === undefined || Logger._instance === null) {
                Logger._instance = new LoggerImpl();
            }
            return Logger._instance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds ILogListener instances to the set of subscribed listeners
     *
     * @param listeners One or more listeners to subscribe to this log
     */
    Logger.subscribe = function () {
        var listeners = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            listeners[_i] = arguments[_i];
        }
        listeners.map(function (listener) { return Logger.instance.subscribe(listener); });
    };
    /**
     * Clears the subscribers collection, returning the collection before modifiction
     */
    Logger.clearSubscribers = function () {
        return Logger.instance.clearSubscribers();
    };
    Object.defineProperty(Logger, "count", {
        /**
         * Gets the current subscriber count
         */
        get: function () {
            return Logger.instance.count;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Writes the supplied string to the subscribed listeners
     *
     * @param message The message to write
     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Info)
     */
    Logger.write = function (message, level) {
        if (level === void 0) { level = 1 /* Info */; }
        Logger.instance.log({ level: level, message: message });
    };
    /**
     * Writes the supplied string to the subscribed listeners
     *
     * @param json The json object to stringify and write
     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Info)
     */
    Logger.writeJSON = function (json, level) {
        if (level === void 0) { level = 1 /* Info */; }
        this.write(JSON.stringify(json), level);
    };
    /**
     * Logs the supplied entry to the subscribed listeners
     *
     * @param entry The message to log
     */
    Logger.log = function (entry) {
        Logger.instance.log(entry);
    };
    /**
     * Logs an error object to the subscribed listeners
     *
     * @param err The error object
     */
    Logger.error = function (err) {
        Logger.instance.log({ data: err, level: 3 /* Error */, message: err.message });
    };
    return Logger;
}());
var LoggerImpl = /** @class */ (function () {
    function LoggerImpl(activeLogLevel, subscribers) {
        if (activeLogLevel === void 0) { activeLogLevel = 2 /* Warning */; }
        if (subscribers === void 0) { subscribers = []; }
        this.activeLogLevel = activeLogLevel;
        this.subscribers = subscribers;
    }
    LoggerImpl.prototype.subscribe = function (listener) {
        this.subscribers.push(listener);
    };
    LoggerImpl.prototype.clearSubscribers = function () {
        var s = this.subscribers.slice(0);
        this.subscribers.length = 0;
        return s;
    };
    Object.defineProperty(LoggerImpl.prototype, "count", {
        get: function () {
            return this.subscribers.length;
        },
        enumerable: true,
        configurable: true
    });
    LoggerImpl.prototype.write = function (message, level) {
        if (level === void 0) { level = 1 /* Info */; }
        this.log({ level: level, message: message });
    };
    LoggerImpl.prototype.log = function (entry) {
        if (entry !== undefined && this.activeLogLevel <= entry.level) {
            this.subscribers.map(function (subscriber) { return subscriber.log(entry); });
        }
    };
    return LoggerImpl;
}());

/**
 * A set of logging levels
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Verbose"] = 0] = "Verbose";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Off"] = 99] = "Off";
})(LogLevel || (LogLevel = {}));

/**
 * Implementation of LogListener which logs to the console
 *
 */
var ConsoleListener = /** @class */ (function () {
    function ConsoleListener() {
    }
    /**
     * Any associated data that a given logging listener may choose to log or ignore
     *
     * @param entry The information to be logged
     */
    ConsoleListener.prototype.log = function (entry) {
        var msg = this.format(entry);
        switch (entry.level) {
            case 0 /* Verbose */:
            case 1 /* Info */:
                console.log(msg);
                break;
            case 2 /* Warning */:
                console.warn(msg);
                break;
            case 3 /* Error */:
                console.error(msg);
                break;
        }
    };
    /**
     * Formats the message
     *
     * @param entry The information to format into a string
     */
    ConsoleListener.prototype.format = function (entry) {
        var msg = [];
        msg.push("Message: " + entry.message);
        if (entry.data !== undefined) {
            msg.push(" Data: " + JSON.stringify(entry.data));
        }
        return msg.join("");
    };
    return ConsoleListener;
}());
/**
 * Implementation of LogListener which logs to the supplied function
 *
 */
var FunctionListener = /** @class */ (function () {
    /**
     * Creates a new instance of the FunctionListener class
     *
     * @constructor
     * @param  method The method to which any logging data will be passed
     */
    function FunctionListener(method) {
        this.method = method;
    }
    /**
     * Any associated data that a given logging listener may choose to log or ignore
     *
     * @param entry The information to be logged
     */
    FunctionListener.prototype.log = function (entry) {
        this.method(entry);
    };
    return FunctionListener;
}());


//# sourceMappingURL=logging.es5.js.map


/***/ }),

/***/ "./node_modules/@pnp/odata/dist/odata.es5.js":
/*!***************************************************!*\
  !*** ./node_modules/@pnp/odata/dist/odata.es5.js ***!
  \***************************************************/
/*! exports provided: CachingOptions, CachingParserWrapper, HttpRequestError, ODataParserBase, ODataDefaultParser, TextParser, BlobParser, JSONParser, BufferParser, LambdaParser, setResult, pipe, requestPipelineMethod, PipelineMethods, getDefaultPipeline, Queryable, ODataQueryable, ODataBatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachingOptions", function() { return CachingOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CachingParserWrapper", function() { return CachingParserWrapper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpRequestError", function() { return HttpRequestError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ODataParserBase", function() { return ODataParserBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ODataDefaultParser", function() { return ODataDefaultParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextParser", function() { return TextParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlobParser", function() { return BlobParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONParser", function() { return JSONParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferParser", function() { return BufferParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LambdaParser", function() { return LambdaParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setResult", function() { return setResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requestPipelineMethod", function() { return requestPipelineMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PipelineMethods", function() { return PipelineMethods; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultPipeline", function() { return getDefaultPipeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Queryable", function() { return Queryable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ODataQueryable", function() { return ODataQueryable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ODataBatch", function() { return ODataBatch; });
/* harmony import */ var _pnp_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pnp/common */ "./node_modules/@pnp/common/dist/common.es5.js");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _pnp_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pnp/logging */ "./node_modules/@pnp/logging/dist/logging.es5.js");
/**
@license
 * @pnp/odata v1.2.3 - pnp - provides shared odata functionality and base classes
 * MIT (https://github.com/pnp/pnpjs/blob/master/LICENSE)
 * Copyright (c) 2018 Microsoft
 * docs: https://pnp.github.io/pnpjs/
 * source: https:github.com/pnp/pnpjs
 * bugs: https://github.com/pnp/pnpjs/issues
 */




var CachingOptions = /** @class */ (function () {
    function CachingOptions(key) {
        this.key = key;
        this.expiration = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["dateAdd"])(new Date(), "second", _pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].defaultCachingTimeoutSeconds);
        this.storeName = _pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].defaultCachingStore;
    }
    Object.defineProperty(CachingOptions.prototype, "store", {
        get: function () {
            if (this.storeName === "local") {
                return CachingOptions.storage.local;
            }
            else {
                return CachingOptions.storage.session;
            }
        },
        enumerable: true,
        configurable: true
    });
    CachingOptions.storage = new _pnp_common__WEBPACK_IMPORTED_MODULE_0__["PnPClientStorage"]();
    return CachingOptions;
}());
var CachingParserWrapper = /** @class */ (function () {
    function CachingParserWrapper(parser, cacheOptions) {
        this.parser = parser;
        this.cacheOptions = cacheOptions;
    }
    CachingParserWrapper.prototype.parse = function (response) {
        var _this = this;
        return this.parser.parse(response).then(function (r) { return _this.cacheData(r); });
    };
    CachingParserWrapper.prototype.cacheData = function (data) {
        if (this.cacheOptions.store !== null) {
            this.cacheOptions.store.put(this.cacheOptions.key, data, this.cacheOptions.expiration);
        }
        return data;
    };
    return CachingParserWrapper;
}());

var HttpRequestError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(HttpRequestError, _super);
    function HttpRequestError(message, response, status, statusText) {
        if (status === void 0) { status = response.status; }
        if (statusText === void 0) { statusText = response.statusText; }
        var _this = _super.call(this, message) || this;
        _this.response = response;
        _this.status = status;
        _this.statusText = statusText;
        _this.isHttpRequestError = true;
        return _this;
    }
    return HttpRequestError;
}(Error));
var ODataParserBase = /** @class */ (function () {
    function ODataParserBase() {
    }
    ODataParserBase.prototype.parse = function (r) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.handleError(r, reject)) {
                _this.parseImpl(r, resolve, reject);
            }
        });
    };
    ODataParserBase.prototype.parseImpl = function (r, resolve, reject) {
        var _this = this;
        if ((r.headers.has("Content-Length") && parseFloat(r.headers.get("Content-Length")) === 0) || r.status === 204) {
            resolve({});
        }
        else {
            // patch to handle cases of 200 response with no or whitespace only bodies (#487 & #545)
            r.text()
                .then(function (txt) { return txt.replace(/\s/ig, "").length > 0 ? JSON.parse(txt) : {}; })
                .then(function (json) { return resolve(_this.parseODataJSON(json)); })
                .catch(function (e) { return reject(e); });
        }
    };
    /**
     * Handles a response with ok === false by parsing the body and creating a ProcessHttpClientResponseException
     * which is passed to the reject delegate. This method returns true if there is no error, otherwise false
     *
     * @param r Current response object
     * @param reject reject delegate for the surrounding promise
     */
    ODataParserBase.prototype.handleError = function (r, reject) {
        if (!r.ok) {
            reject(new HttpRequestError("Error making HttpClient request in queryable: [" + r.status + "] " + r.statusText, r.clone()));
        }
        return r.ok;
    };
    /**
     * Normalizes the json response by removing the various nested levels
     *
     * @param json json object to parse
     */
    ODataParserBase.prototype.parseODataJSON = function (json) {
        var result = json;
        if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(json, "d")) {
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(json.d, "results")) {
                result = json.d.results;
            }
            else {
                result = json.d;
            }
        }
        else if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(json, "value")) {
            result = json.value;
        }
        return result;
    };
    return ODataParserBase;
}());
var ODataDefaultParser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ODataDefaultParser, _super);
    function ODataDefaultParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ODataDefaultParser;
}(ODataParserBase));
var TextParser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(TextParser, _super);
    function TextParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TextParser.prototype.parseImpl = function (r, resolve) {
        r.text().then(resolve);
    };
    return TextParser;
}(ODataParserBase));
var BlobParser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(BlobParser, _super);
    function BlobParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BlobParser.prototype.parseImpl = function (r, resolve) {
        r.blob().then(resolve);
    };
    return BlobParser;
}(ODataParserBase));
var JSONParser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(JSONParser, _super);
    function JSONParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JSONParser.prototype.parseImpl = function (r, resolve) {
        r.json().then(resolve);
    };
    return JSONParser;
}(ODataParserBase));
var BufferParser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(BufferParser, _super);
    function BufferParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BufferParser.prototype.parseImpl = function (r, resolve) {
        if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["isFunc"])(r.arrayBuffer)) {
            r.arrayBuffer().then(resolve);
        }
        else {
            r.buffer().then(resolve);
        }
    };
    return BufferParser;
}(ODataParserBase));
var LambdaParser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(LambdaParser, _super);
    function LambdaParser(parser) {
        var _this = _super.call(this) || this;
        _this.parser = parser;
        return _this;
    }
    LambdaParser.prototype.parseImpl = function (r, resolve) {
        this.parser(r).then(resolve);
    };
    return LambdaParser;
}(ODataParserBase));

/**
 * Resolves the context's result value
 *
 * @param context The current context
 */
function returnResult(context) {
    _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].log({
        data: _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].activeLogLevel === 0 /* Verbose */ ? context.result : {},
        level: 1 /* Info */,
        message: "[" + context.requestId + "] (" + (new Date()).getTime() + ") Returning result from pipeline. Set logging to verbose to see data.",
    });
    return Promise.resolve(context.result);
}
/**
 * Sets the result on the context
 */
function setResult(context, value) {
    return new Promise(function (resolve) {
        context.result = value;
        context.hasResult = true;
        resolve(context);
    });
}
/**
 * Invokes the next method in the provided context's pipeline
 *
 * @param c The current request context
 */
function next(c) {
    if (c.pipeline.length > 0) {
        return c.pipeline.shift()(c);
    }
    else {
        return Promise.resolve(c);
    }
}
/**
 * Executes the current request context's pipeline
 *
 * @param context Current context
 */
function pipe(context) {
    if (context.pipeline.length < 1) {
        _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + context.requestId + "] (" + (new Date()).getTime() + ") Request pipeline contains no methods!", 2 /* Warning */);
    }
    var promise = next(context).then(function (ctx) { return returnResult(ctx); }).catch(function (e) {
        _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].error(e);
        throw e;
    });
    if (context.isBatched) {
        // this will block the batch's execute method from returning until the child requets have been resolved
        context.batch.addResolveBatchDependency(promise);
    }
    return promise;
}
/**
 * decorator factory applied to methods in the pipeline to control behavior
 */
function requestPipelineMethod(alwaysRun) {
    if (alwaysRun === void 0) { alwaysRun = false; }
    return function (target, propertyKey, descriptor) {
        var method = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // if we have a result already in the pipeline, pass it along and don't call the tagged method
            if (!alwaysRun && args.length > 0 && Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(args[0], "hasResult") && args[0].hasResult) {
                _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + args[0].requestId + "] (" + (new Date()).getTime() + ") Skipping request pipeline method " + propertyKey + ", existing result in pipeline.", 0 /* Verbose */);
                return Promise.resolve(args[0]);
            }
            // apply the tagged method
            _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + args[0].requestId + "] (" + (new Date()).getTime() + ") Calling request pipeline method " + propertyKey + ".", 0 /* Verbose */);
            // then chain the next method in the context's pipeline - allows for dynamic pipeline
            return method.apply(target, args).then(function (ctx) { return next(ctx); });
        };
    };
}
/**
 * Contains the methods used within the request pipeline
 */
var PipelineMethods = /** @class */ (function () {
    function PipelineMethods() {
    }
    /**
     * Logs the start of the request
     */
    PipelineMethods.logStart = function (context) {
        return new Promise(function (resolve) {
            _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].log({
                data: _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].activeLogLevel === 1 /* Info */ ? {} : context,
                level: 1 /* Info */,
                message: "[" + context.requestId + "] (" + (new Date()).getTime() + ") Beginning " + context.verb + " request (" + context.requestAbsoluteUrl + ")",
            });
            resolve(context);
        });
    };
    /**
     * Handles caching of the request
     */
    PipelineMethods.caching = function (context) {
        return new Promise(function (resolve) {
            // handle caching, if applicable
            if (context.isCached) {
                _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + context.requestId + "] (" + (new Date()).getTime() + ") Caching is enabled for request, checking cache...", 1 /* Info */);
                var cacheOptions = new CachingOptions(context.requestAbsoluteUrl.toLowerCase());
                if (context.cachingOptions !== undefined) {
                    cacheOptions = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(cacheOptions, context.cachingOptions);
                }
                // we may not have a valid store
                if (cacheOptions.store !== null) {
                    // check if we have the data in cache and if so resolve the promise and return
                    var data = cacheOptions.store.get(cacheOptions.key);
                    if (data !== null) {
                        // ensure we clear any held batch dependency we are resolving from the cache
                        _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].log({
                            data: _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].activeLogLevel === 1 /* Info */ ? {} : data,
                            level: 1 /* Info */,
                            message: "[" + context.requestId + "] (" + (new Date()).getTime() + ") Value returned from cache.",
                        });
                        if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["isFunc"])(context.batchDependency)) {
                            context.batchDependency();
                        }
                        // handle the case where a parser needs to take special actions with a cached result
                        if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(context.parser, "hydrate")) {
                            data = context.parser.hydrate(data);
                        }
                        return setResult(context, data).then(function (ctx) { return resolve(ctx); });
                    }
                }
                _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + context.requestId + "] (" + (new Date()).getTime() + ") Value not found in cache.", 1 /* Info */);
                // if we don't then wrap the supplied parser in the caching parser wrapper
                // and send things on their way
                context.parser = new CachingParserWrapper(context.parser, cacheOptions);
            }
            return resolve(context);
        });
    };
    /**
     * Sends the request
     */
    PipelineMethods.send = function (context) {
        return new Promise(function (resolve, reject) {
            // send or batch the request
            if (context.isBatched) {
                // we are in a batch, so add to batch, remove dependency, and resolve with the batch's promise
                var p = context.batch.add(context.requestAbsoluteUrl, context.verb, context.options, context.parser, context.requestId);
                // we release the dependency here to ensure the batch does not execute until the request is added to the batch
                if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["isFunc"])(context.batchDependency)) {
                    context.batchDependency();
                }
                _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + context.requestId + "] (" + (new Date()).getTime() + ") Batching request in batch " + context.batch.batchId + ".", 1 /* Info */);
                // we set the result as the promise which will be resolved by the batch's execution
                resolve(setResult(context, p));
            }
            else {
                _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + context.requestId + "] (" + (new Date()).getTime() + ") Sending request.", 1 /* Info */);
                // we are not part of a batch, so proceed as normal
                var client = context.clientFactory();
                var opts = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(context.options || {}, { method: context.verb });
                client.fetch(context.requestAbsoluteUrl, opts)
                    .then(function (response) { return context.parser.parse(response); })
                    .then(function (result) { return setResult(context, result); })
                    .then(function (ctx) { return resolve(ctx); })
                    .catch(function (e) { return reject(e); });
            }
        });
    };
    /**
     * Logs the end of the request
     */
    PipelineMethods.logEnd = function (context) {
        return new Promise(function (resolve) {
            if (context.isBatched) {
                _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].log({
                    data: _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].activeLogLevel === 1 /* Info */ ? {} : context,
                    level: 1 /* Info */,
                    message: "[" + context.requestId + "] (" + (new Date()).getTime() + ") " + context.verb + " request will complete in batch " + context.batch.batchId + ".",
                });
            }
            else {
                _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].log({
                    data: _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].activeLogLevel === 1 /* Info */ ? {} : context,
                    level: 1 /* Info */,
                    message: "[" + context.requestId + "] (" + (new Date()).getTime() + ") Completing " + context.verb + " request.",
                });
            }
            resolve(context);
        });
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        requestPipelineMethod(true)
    ], PipelineMethods, "logStart", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        requestPipelineMethod()
    ], PipelineMethods, "caching", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        requestPipelineMethod()
    ], PipelineMethods, "send", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        requestPipelineMethod(true)
    ], PipelineMethods, "logEnd", null);
    return PipelineMethods;
}());
function getDefaultPipeline() {
    return [
        PipelineMethods.logStart,
        PipelineMethods.caching,
        PipelineMethods.send,
        PipelineMethods.logEnd,
    ].slice(0);
}

var Queryable = /** @class */ (function () {
    function Queryable() {
        this._query = new Map();
        this._options = {};
        this._url = "";
        this._parentUrl = "";
        this._useCaching = false;
        this._cachingOptions = null;
    }
    /**
    * Gets the currentl url
    *
    */
    Queryable.prototype.toUrl = function () {
        return this._url;
    };
    /**
     * Directly concatonates the supplied string to the current url, not normalizing "/" chars
     *
     * @param pathPart The string to concatonate to the url
     */
    Queryable.prototype.concat = function (pathPart) {
        this._url += pathPart;
        return this;
    };
    Object.defineProperty(Queryable.prototype, "query", {
        /**
         * Provides access to the query builder for this url
         *
         */
        get: function () {
            return this._query;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets custom options for current object and all derived objects accessible via chaining
     *
     * @param options custom options
     */
    Queryable.prototype.configure = function (options) {
        Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["mergeOptions"])(this._options, options);
        return this;
    };
    /**
     * Configures this instance from the configure options of the supplied instance
     *
     * @param o Instance from which options should be taken
     */
    Queryable.prototype.configureFrom = function (o) {
        Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["mergeOptions"])(this._options, o._options);
        return this;
    };
    /**
     * Enables caching for this request
     *
     * @param options Defines the options used when caching this request
     */
    Queryable.prototype.usingCaching = function (options) {
        if (!_pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].globalCacheDisable) {
            this._useCaching = true;
            if (options !== undefined) {
                this._cachingOptions = options;
            }
        }
        return this;
    };
    Queryable.prototype.getCore = function (parser, options) {
        if (parser === void 0) { parser = new JSONParser(); }
        if (options === void 0) { options = {}; }
        return this.toRequestContext("GET", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    Queryable.prototype.postCore = function (options, parser) {
        if (options === void 0) { options = {}; }
        if (parser === void 0) { parser = new JSONParser(); }
        return this.toRequestContext("POST", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    Queryable.prototype.patchCore = function (options, parser) {
        if (options === void 0) { options = {}; }
        if (parser === void 0) { parser = new JSONParser(); }
        return this.toRequestContext("PATCH", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    Queryable.prototype.deleteCore = function (options, parser) {
        if (options === void 0) { options = {}; }
        if (parser === void 0) { parser = new JSONParser(); }
        return this.toRequestContext("DELETE", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    Queryable.prototype.putCore = function (options, parser) {
        if (options === void 0) { options = {}; }
        if (parser === void 0) { parser = new JSONParser(); }
        return this.toRequestContext("PUT", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    /**
     * Appends the given string and normalizes "/" chars
     *
     * @param pathPart The string to append
     */
    Queryable.prototype.append = function (pathPart) {
        this._url = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(this._url, pathPart);
    };
    Object.defineProperty(Queryable.prototype, "parentUrl", {
        /**
         * Gets the parent url used when creating this instance
         *
         */
        get: function () {
            return this._parentUrl;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Extends this queryable from the provided parent
     *
     * @param parent Parent queryable from which we will derive a base url
     * @param path Additional path
     */
    Queryable.prototype.extend = function (parent, path) {
        this._parentUrl = parent._url;
        this._url = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(this._parentUrl, path || "");
        this.configureFrom(parent);
    };
    return Queryable;
}());
var ODataQueryable = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ODataQueryable, _super);
    function ODataQueryable() {
        var _this = _super.call(this) || this;
        _this._batch = null;
        return _this;
    }
    /**
     * Adds this query to the supplied batch
     *
     * @example
     * ```
     *
     * let b = pnp.sp.createBatch();
     * pnp.sp.web.inBatch(b).get().then(...);
     * b.execute().then(...)
     * ```
     */
    ODataQueryable.prototype.inBatch = function (batch) {
        if (this.batch !== null) {
            throw Error("This query is already part of a batch.");
        }
        this._batch = batch;
        return this;
    };
    /**
     * Gets the currentl url
     *
     */
    ODataQueryable.prototype.toUrl = function () {
        return this._url;
    };
    /**
     * Executes the currently built request
     *
     * @param parser Allows you to specify a parser to handle the result
     * @param getOptions The options used for this request
     */
    ODataQueryable.prototype.get = function (parser, options) {
        if (parser === void 0) { parser = new ODataDefaultParser(); }
        if (options === void 0) { options = {}; }
        return this.getCore(parser, options);
    };
    ODataQueryable.prototype.getCore = function (parser, options) {
        if (parser === void 0) { parser = new ODataDefaultParser(); }
        if (options === void 0) { options = {}; }
        return this.toRequestContext("GET", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    ODataQueryable.prototype.postCore = function (options, parser) {
        if (options === void 0) { options = {}; }
        if (parser === void 0) { parser = new ODataDefaultParser(); }
        return this.toRequestContext("POST", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    ODataQueryable.prototype.patchCore = function (options, parser) {
        if (options === void 0) { options = {}; }
        if (parser === void 0) { parser = new ODataDefaultParser(); }
        return this.toRequestContext("PATCH", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    ODataQueryable.prototype.deleteCore = function (options, parser) {
        if (options === void 0) { options = {}; }
        if (parser === void 0) { parser = new ODataDefaultParser(); }
        return this.toRequestContext("DELETE", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    ODataQueryable.prototype.putCore = function (options, parser) {
        if (options === void 0) { options = {}; }
        if (parser === void 0) { parser = new ODataDefaultParser(); }
        return this.toRequestContext("PUT", options, parser, getDefaultPipeline()).then(function (context) { return pipe(context); });
    };
    /**
     * Blocks a batch call from occuring, MUST be cleared by calling the returned function
    */
    ODataQueryable.prototype.addBatchDependency = function () {
        if (this._batch !== null) {
            return this._batch.addDependency();
        }
        return function () { return null; };
    };
    Object.defineProperty(ODataQueryable.prototype, "hasBatch", {
        /**
         * Indicates if the current query has a batch associated
         *
         */
        get: function () {
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["objectDefinedNotNull"])(this._batch);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODataQueryable.prototype, "batch", {
        /**
         * The batch currently associated with this query or null
         *
         */
        get: function () {
            return this.hasBatch ? this._batch : null;
        },
        enumerable: true,
        configurable: true
    });
    return ODataQueryable;
}(Queryable));

var ODataBatch = /** @class */ (function () {
    function ODataBatch(_batchId) {
        if (_batchId === void 0) { _batchId = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getGUID"])(); }
        this._batchId = _batchId;
        this._reqs = [];
        this._deps = [];
        this._rDeps = [];
    }
    Object.defineProperty(ODataBatch.prototype, "batchId", {
        get: function () {
            return this._batchId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODataBatch.prototype, "requests", {
        /**
         * The requests contained in this batch
         */
        get: function () {
            return this._reqs;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @param url Request url
     * @param method Request method (GET, POST, etc)
     * @param options Any request options
     * @param parser The parser used to handle the eventual return from the query
     * @param id An identifier used to track a request within a batch
     */
    ODataBatch.prototype.add = function (url, method, options, parser, id) {
        var info = {
            id: id,
            method: method.toUpperCase(),
            options: options,
            parser: parser,
            reject: null,
            resolve: null,
            url: url,
        };
        var p = new Promise(function (resolve, reject) {
            info.resolve = resolve;
            info.reject = reject;
        });
        this._reqs.push(info);
        return p;
    };
    /**
     * Adds a dependency insuring that some set of actions will occur before a batch is processed.
     * MUST be cleared using the returned resolve delegate to allow batches to run
     */
    ODataBatch.prototype.addDependency = function () {
        var resolver = function () { return void (0); };
        this._deps.push(new Promise(function (resolve) {
            resolver = resolve;
        }));
        return resolver;
    };
    /**
     * The batch's execute method will not resolve util any promises added here resolve
     *
     * @param p The dependent promise
     */
    ODataBatch.prototype.addResolveBatchDependency = function (p) {
        this._rDeps.push(p);
    };
    /**
     * Execute the current batch and resolve the associated promises
     *
     * @returns A promise which will be resolved once all of the batch's child promises have resolved
     */
    ODataBatch.prototype.execute = function () {
        var _this = this;
        // we need to check the dependencies twice due to how different engines handle things.
        // We can get a second set of promises added during the first set resolving
        return Promise.all(this._deps)
            .then(function () { return Promise.all(_this._deps); })
            .then(function () { return _this.executeImpl(); })
            .then(function () { return Promise.all(_this._rDeps); })
            .then(function () { return void (0); });
    };
    return ODataBatch;
}());


//# sourceMappingURL=odata.es5.js.map


/***/ }),

/***/ "./node_modules/@pnp/sp/dist/sp.es5.js":
/*!*********************************************!*\
  !*** ./node_modules/@pnp/sp/dist/sp.es5.js ***!
  \*********************************************/
/*! exports provided: odataUrlFrom, spODataEntity, spODataEntityArray, SharePointQueryable, SharePointQueryableInstance, SharePointQueryableCollection, SharePointQueryableSecurable, FileFolderShared, SharePointQueryableShareable, SharePointQueryableShareableFile, SharePointQueryableShareableFolder, SharePointQueryableShareableItem, SharePointQueryableShareableWeb, AppCatalog, App, SPBatch, ContentType, ContentTypes, FieldLink, FieldLinks, Field, Fields, CheckinType, WebPartsPersonalizationScope, MoveOperations, TemplateFileType, File, Files, Folder, Folders, SPHttpClient, Item, Items, ItemVersion, ItemVersions, PagedItemCollection, NavigationNodes, NavigationNode, NavigationService, List, Lists, RegionalSettings, InstalledLanguages, TimeZone, TimeZones, sp, SPRest, RoleDefinitionBindings, Search, SearchQueryBuilder, SearchResults, SortDirection, ReorderingRuleMatchType, QueryPropertyValueType, SearchBuiltInSourceId, SearchSuggest, Site, UserProfileQuery, toAbsoluteUrl, extractWebUrl, UtilityMethod, View, Views, ViewFields, WebPartDefinitions, WebPartDefinition, WebPart, Web, PromotedState, ClientSidePage, CanvasSection, CanvasControl, CanvasColumn, ClientSidePart, ClientSideText, ClientSideWebpart, Comments, Comment, Replies, SocialQuery, MySocialQuery, SocialActorType, SocialActorTypes, SocialFollowResult, SocialStatusCode, ControlMode, FieldTypes, DateTimeFieldFormatType, AddFieldOptions, CalendarType, UrlFieldFormatType, PermissionKind, PrincipalType, PrincipalSource, RoleType, PageType, SharingLinkKind, SharingRole, SharingOperationStatusCode, SPSharedObjectType, SharingDomainRestrictionMode, RenderListDataOptions, FieldUserSelectionMode, ChoiceFieldFormatType, UrlZone */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "odataUrlFrom", function() { return odataUrlFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spODataEntity", function() { return spODataEntity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spODataEntityArray", function() { return spODataEntityArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharePointQueryable", function() { return SharePointQueryable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharePointQueryableInstance", function() { return SharePointQueryableInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharePointQueryableCollection", function() { return SharePointQueryableCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharePointQueryableSecurable", function() { return SharePointQueryableSecurable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileFolderShared", function() { return FileFolderShared; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharePointQueryableShareable", function() { return SharePointQueryableShareable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharePointQueryableShareableFile", function() { return SharePointQueryableShareableFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharePointQueryableShareableFolder", function() { return SharePointQueryableShareableFolder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharePointQueryableShareableItem", function() { return SharePointQueryableShareableItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharePointQueryableShareableWeb", function() { return SharePointQueryableShareableWeb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppCatalog", function() { return AppCatalog; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "App", function() { return App; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPBatch", function() { return SPBatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContentType", function() { return ContentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContentTypes", function() { return ContentTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldLink", function() { return FieldLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldLinks", function() { return FieldLinks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Field", function() { return Field; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fields", function() { return Fields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CheckinType", function() { return CheckinType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebPartsPersonalizationScope", function() { return WebPartsPersonalizationScope; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MoveOperations", function() { return MoveOperations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateFileType", function() { return TemplateFileType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "File", function() { return File; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Files", function() { return Files; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Folder", function() { return Folder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Folders", function() { return Folders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPHttpClient", function() { return SPHttpClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Item", function() { return Item; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Items", function() { return Items; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemVersion", function() { return ItemVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemVersions", function() { return ItemVersions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PagedItemCollection", function() { return PagedItemCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationNodes", function() { return NavigationNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationNode", function() { return NavigationNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationService", function() { return NavigationService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "List", function() { return List; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lists", function() { return Lists; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RegionalSettings", function() { return RegionalSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstalledLanguages", function() { return InstalledLanguages; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeZone", function() { return TimeZone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeZones", function() { return TimeZones; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sp", function() { return sp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPRest", function() { return SPRest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoleDefinitionBindings", function() { return RoleDefinitionBindings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Search", function() { return Search; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SearchQueryBuilder", function() { return SearchQueryBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SearchResults", function() { return SearchResults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SortDirection", function() { return SortDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReorderingRuleMatchType", function() { return ReorderingRuleMatchType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryPropertyValueType", function() { return QueryPropertyValueType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SearchBuiltInSourceId", function() { return SearchBuiltInSourceId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SearchSuggest", function() { return SearchSuggest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Site", function() { return Site; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserProfileQuery", function() { return UserProfileQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toAbsoluteUrl", function() { return toAbsoluteUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractWebUrl", function() { return extractWebUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UtilityMethod", function() { return UtilityMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View", function() { return View; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Views", function() { return Views; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewFields", function() { return ViewFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebPartDefinitions", function() { return WebPartDefinitions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebPartDefinition", function() { return WebPartDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebPart", function() { return WebPart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Web", function() { return Web; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PromotedState", function() { return PromotedState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClientSidePage", function() { return ClientSidePage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasSection", function() { return CanvasSection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasControl", function() { return CanvasControl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasColumn", function() { return CanvasColumn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClientSidePart", function() { return ClientSidePart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClientSideText", function() { return ClientSideText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClientSideWebpart", function() { return ClientSideWebpart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Comments", function() { return Comments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Comment", function() { return Comment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Replies", function() { return Replies; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SocialQuery", function() { return SocialQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MySocialQuery", function() { return MySocialQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SocialActorType", function() { return SocialActorType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SocialActorTypes", function() { return SocialActorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SocialFollowResult", function() { return SocialFollowResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SocialStatusCode", function() { return SocialStatusCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ControlMode", function() { return ControlMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldTypes", function() { return FieldTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateTimeFieldFormatType", function() { return DateTimeFieldFormatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddFieldOptions", function() { return AddFieldOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CalendarType", function() { return CalendarType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlFieldFormatType", function() { return UrlFieldFormatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PermissionKind", function() { return PermissionKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrincipalType", function() { return PrincipalType$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrincipalSource", function() { return PrincipalSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoleType", function() { return RoleType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PageType", function() { return PageType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharingLinkKind", function() { return SharingLinkKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharingRole", function() { return SharingRole; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharingOperationStatusCode", function() { return SharingOperationStatusCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SPSharedObjectType", function() { return SPSharedObjectType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharingDomainRestrictionMode", function() { return SharingDomainRestrictionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderListDataOptions", function() { return RenderListDataOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldUserSelectionMode", function() { return FieldUserSelectionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChoiceFieldFormatType", function() { return ChoiceFieldFormatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlZone", function() { return UrlZone; });
/* harmony import */ var _pnp_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pnp/common */ "./node_modules/@pnp/common/dist/common.es5.js");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _pnp_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pnp/logging */ "./node_modules/@pnp/logging/dist/logging.es5.js");
/* harmony import */ var _pnp_odata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pnp/odata */ "./node_modules/@pnp/odata/dist/odata.es5.js");
/**
@license
 * @pnp/sp v1.2.3 - pnp - provides a fluent api for working with SharePoint REST
 * MIT (https://github.com/pnp/pnpjs/blob/master/LICENSE)
 * Copyright (c) 2018 Microsoft
 * docs: https://pnp.github.io/pnpjs/
 * source: https:github.com/pnp/pnpjs
 * bugs: https://github.com/pnp/pnpjs/issues
 */





function extractWebUrl(candidateUrl) {
    if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["stringIsNullOrEmpty"])(candidateUrl)) {
        return "";
    }
    var index = candidateUrl.indexOf("_api/");
    if (index < 0) {
        index = candidateUrl.indexOf("_vti_bin/");
    }
    if (index > -1) {
        return candidateUrl.substr(0, index);
    }
    // if all else fails just give them what they gave us back
    return candidateUrl;
}

function odataUrlFrom(candidate) {
    var parts = [];
    var s = ["odata.type", "odata.editLink", "__metadata", "odata.metadata"];
    if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(candidate, s[0]) && candidate[s[0]] === "SP.Web") {
        // webs return an absolute url in the editLink
        if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(candidate, s[1])) {
            parts.push(candidate[s[1]]);
        }
        else if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(candidate, s[2])) {
            // we are dealing with verbose, which has an absolute uri
            parts.push(candidate.__metadata.uri);
        }
    }
    else {
        if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(candidate, s[3]) && Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(candidate, s[1])) {
            // we are dealign with minimal metadata (default)
            parts.push(extractWebUrl(candidate[s[3]]), "_api", candidate[s[1]]);
        }
        else if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(candidate, s[1])) {
            parts.push("_api", candidate[s[1]]);
        }
        else if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(candidate, s[2])) {
            // we are dealing with verbose, which has an absolute uri
            parts.push(candidate.__metadata.uri);
        }
    }
    if (parts.length < 1) {
        _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("No uri information found in ODataEntity parsing, chaining will fail for this object.", 2 /* Warning */);
        return "";
    }
    return _pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"].apply(void 0, parts);
}
var SPODataEntityParserImpl = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SPODataEntityParserImpl, _super);
    function SPODataEntityParserImpl(factory) {
        var _this = _super.call(this) || this;
        _this.factory = factory;
        _this.hydrate = function (d) {
            var o = new _this.factory(odataUrlFrom(d), null);
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(o, d);
        };
        return _this;
    }
    SPODataEntityParserImpl.prototype.parse = function (r) {
        var _this = this;
        return _super.prototype.parse.call(this, r).then(function (d) {
            var o = new _this.factory(odataUrlFrom(d), null);
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(o, d);
        });
    };
    return SPODataEntityParserImpl;
}(_pnp_odata__WEBPACK_IMPORTED_MODULE_3__["ODataParserBase"]));
var SPODataEntityArrayParserImpl = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SPODataEntityArrayParserImpl, _super);
    function SPODataEntityArrayParserImpl(factory) {
        var _this = _super.call(this) || this;
        _this.factory = factory;
        _this.hydrate = function (d) {
            return d.map(function (v) {
                var o = new _this.factory(odataUrlFrom(v), null);
                return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(o, v);
            });
        };
        return _this;
    }
    SPODataEntityArrayParserImpl.prototype.parse = function (r) {
        var _this = this;
        return _super.prototype.parse.call(this, r).then(function (d) {
            return d.map(function (v) {
                var o = new _this.factory(odataUrlFrom(v), null);
                return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(o, v);
            });
        });
    };
    return SPODataEntityArrayParserImpl;
}(_pnp_odata__WEBPACK_IMPORTED_MODULE_3__["ODataParserBase"]));
function spODataEntity(factory) {
    return new SPODataEntityParserImpl(factory);
}
function spODataEntityArray(factory) {
    return new SPODataEntityArrayParserImpl(factory);
}

function setup(config) {
    _pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].extend(config);
}
var SPRuntimeConfigImpl = /** @class */ (function () {
    function SPRuntimeConfigImpl() {
    }
    Object.defineProperty(SPRuntimeConfigImpl.prototype, "headers", {
        get: function () {
            var spPart = _pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].get("sp");
            if (spPart !== undefined && spPart.headers !== undefined) {
                return spPart.headers;
            }
            return {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SPRuntimeConfigImpl.prototype, "baseUrl", {
        get: function () {
            var spPart = _pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].get("sp");
            if (spPart !== undefined && spPart.baseUrl !== undefined) {
                return spPart.baseUrl;
            }
            if (_pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].spfxContext !== undefined && _pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].spfxContext !== null) {
                return _pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].spfxContext.pageContext.web.absoluteUrl;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SPRuntimeConfigImpl.prototype, "fetchClientFactory", {
        get: function () {
            var spPart = _pnp_common__WEBPACK_IMPORTED_MODULE_0__["RuntimeConfig"].get("sp");
            // use a configured factory firt
            if (spPart !== undefined && spPart.fetchClientFactory !== undefined) {
                return spPart.fetchClientFactory;
            }
            else {
                return function () { return new _pnp_common__WEBPACK_IMPORTED_MODULE_0__["FetchClient"](); };
            }
        },
        enumerable: true,
        configurable: true
    });
    return SPRuntimeConfigImpl;
}());
var SPRuntimeConfig = new SPRuntimeConfigImpl();

var CachedDigest = /** @class */ (function () {
    function CachedDigest() {
    }
    return CachedDigest;
}());
// allows for the caching of digests across all HttpClient's which each have their own DigestCache wrapper.
var digests = new Map();
var DigestCache = /** @class */ (function () {
    function DigestCache(_httpClient, _digests) {
        if (_digests === void 0) { _digests = digests; }
        this._httpClient = _httpClient;
        this._digests = _digests;
    }
    DigestCache.prototype.getDigest = function (webUrl) {
        var _this = this;
        var cachedDigest = this._digests.get(webUrl);
        if (cachedDigest !== undefined) {
            var now = new Date();
            if (now < cachedDigest.expiration) {
                return Promise.resolve(cachedDigest.value);
            }
        }
        var url = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(webUrl, "/_api/contextinfo");
        var headers = {
            "Accept": "application/json;odata=verbose",
            "Content-Type": "application/json;odata=verbose;charset=utf-8",
        };
        return this._httpClient.fetchRaw(url, {
            cache: "no-cache",
            credentials: "same-origin",
            headers: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(headers, SPRuntimeConfig.headers, true),
            method: "POST",
        }).then(function (response) {
            var parser = new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["ODataDefaultParser"]();
            return parser.parse(response).then(function (d) { return d.GetContextWebInformation; });
        }).then(function (data) {
            var newCachedDigest = new CachedDigest();
            newCachedDigest.value = data.FormDigestValue;
            var seconds = data.FormDigestTimeoutSeconds;
            var expiration = new Date();
            expiration.setTime(expiration.getTime() + 1000 * seconds);
            newCachedDigest.expiration = expiration;
            _this._digests.set(webUrl, newCachedDigest);
            return newCachedDigest.value;
        });
    };
    DigestCache.prototype.clear = function () {
        this._digests.clear();
    };
    return DigestCache;
}());

var SPHttpClient = /** @class */ (function () {
    function SPHttpClient(_impl) {
        if (_impl === void 0) { _impl = SPRuntimeConfig.fetchClientFactory(); }
        this._impl = _impl;
        this._digestCache = new DigestCache(this);
    }
    SPHttpClient.prototype.fetch = function (url, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var opts = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(options, { cache: "no-cache", credentials: "same-origin" }, true);
        var headers = new Headers();
        // first we add the global headers so they can be overwritten by any passed in locally to this call
        Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["mergeHeaders"])(headers, SPRuntimeConfig.headers);
        // second we add the local options so we can overwrite the globals
        Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["mergeHeaders"])(headers, options.headers);
        // lastly we apply any default headers we need that may not exist
        if (!headers.has("Accept")) {
            headers.append("Accept", "application/json");
        }
        if (!headers.has("Content-Type")) {
            headers.append("Content-Type", "application/json;odata=verbose;charset=utf-8");
        }
        if (!headers.has("X-ClientService-ClientTag")) {
            headers.append("X-ClientService-ClientTag", "PnPCoreJS:@pnp-1.2.3");
        }
        if (!headers.has("User-Agent")) {
            // this marks the requests for understanding by the service
            headers.append("User-Agent", "NONISV|SharePointPnP|PnPCoreJS/1.2.3");
        }
        opts = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(opts, { headers: headers });
        if (opts.method && opts.method.toUpperCase() !== "GET") {
            // if we have either a request digest or an authorization header we don't need a digest
            if (!headers.has("X-RequestDigest") && !headers.has("Authorization")) {
                return this._digestCache.getDigest(extractWebUrl(url))
                    .then(function (digest) {
                    headers.append("X-RequestDigest", digest);
                    return _this.fetchRaw(url, opts);
                });
            }
        }
        return this.fetchRaw(url, opts);
    };
    SPHttpClient.prototype.fetchRaw = function (url, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // here we need to normalize the headers
        var rawHeaders = new Headers();
        Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["mergeHeaders"])(rawHeaders, options.headers);
        options = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(options, { headers: rawHeaders });
        var retry = function (ctx) {
            // handles setting the proper timeout for a retry
            var setRetry = function (response) {
                var delay;
                if (response.headers.has("Retry-After")) {
                    // if we have gotten a header, use that value as the delay value
                    delay = parseInt(response.headers.get("Retry-After"), 10);
                }
                else {
                    // grab our current delay
                    delay = ctx.delay;
                    // Increment our counters.
                    ctx.delay *= 2;
                }
                ctx.attempts++;
                // If we have exceeded the retry count, reject.
                if (ctx.retryCount <= ctx.attempts) {
                    ctx.reject(Error("Retry count exceeded (" + ctx.retryCount + ") for request. Response status: [" + response.status + "] " + response.statusText));
                }
                else {
                    // Set our retry timeout for {delay} milliseconds.
                    setTimeout(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getCtxCallback"])(_this, retry, ctx), delay);
                }
            };
            // send the actual request
            _this._impl.fetch(url, options).then(function (response) {
                if (response.status === 429) {
                    // we have been throttled
                    setRetry(response);
                }
                else {
                    ctx.resolve(response);
                }
            }).catch(function (response) {
                if (response.status === 503) {
                    // http status code 503, we can retry this
                    setRetry(response);
                }
                else {
                    ctx.reject(response);
                }
            });
        };
        return new Promise(function (resolve, reject) {
            var retryContext = {
                attempts: 0,
                delay: 100,
                reject: reject,
                resolve: resolve,
                retryCount: 7,
            };
            retry.call(_this, retryContext);
        });
    };
    SPHttpClient.prototype.get = function (url, options) {
        if (options === void 0) { options = {}; }
        var opts = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(options, { method: "GET" });
        return this.fetch(url, opts);
    };
    SPHttpClient.prototype.post = function (url, options) {
        if (options === void 0) { options = {}; }
        var opts = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(options, { method: "POST" });
        return this.fetch(url, opts);
    };
    SPHttpClient.prototype.patch = function (url, options) {
        if (options === void 0) { options = {}; }
        var opts = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(options, { method: "PATCH" });
        return this.fetch(url, opts);
    };
    SPHttpClient.prototype.delete = function (url, options) {
        if (options === void 0) { options = {}; }
        var opts = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(options, { method: "DELETE" });
        return this.fetch(url, opts);
    };
    return SPHttpClient;
}());

var global$1 = (typeof global !== "undefined" ? global :
            typeof self !== "undefined" ? self :
            typeof window !== "undefined" ? window : {});

/**
 * Ensures that a given url is absolute for the current web based on context
 *
 * @param candidateUrl The url to make absolute
 *
 */
function toAbsoluteUrl(candidateUrl) {
    return new Promise(function (resolve) {
        if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["isUrlAbsolute"])(candidateUrl)) {
            // if we are already absolute, then just return the url
            return resolve(candidateUrl);
        }
        if (SPRuntimeConfig.baseUrl !== null) {
            // base url specified either with baseUrl of spfxContext config property
            return resolve(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(SPRuntimeConfig.baseUrl, candidateUrl));
        }
        if (global$1._spPageContextInfo !== undefined) {
            // operating in classic pages
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(global$1._spPageContextInfo, "webAbsoluteUrl")) {
                return resolve(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(global$1._spPageContextInfo.webAbsoluteUrl, candidateUrl));
            }
            else if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(global$1._spPageContextInfo, "webServerRelativeUrl")) {
                return resolve(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(global$1._spPageContextInfo.webServerRelativeUrl, candidateUrl));
            }
        }
        // does window.location exist and have a certain path part in it?
        if (global$1.location !== undefined) {
            var baseUrl_1 = global$1.location.toString().toLowerCase();
            ["/_layouts/", "/siteassets/"].forEach(function (s) {
                var index = baseUrl_1.indexOf(s);
                if (index > 0) {
                    return resolve(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(baseUrl_1.substr(0, index), candidateUrl));
                }
            });
        }
        return resolve(candidateUrl);
    });
}

function metadata(type) {
    return {
        "__metadata": { "type": type },
    };
}

/**
 * SharePointQueryable Base Class
 *
 */
var SharePointQueryable = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SharePointQueryable, _super);
    /**
     * Creates a new instance of the SharePointQueryable class
     *
     * @constructor
     * @param baseUrl A string or SharePointQueryable that should form the base part of the url
     *
     */
    function SharePointQueryable(baseUrl, path) {
        var _this = _super.call(this) || this;
        _this._forceCaching = false;
        if (typeof baseUrl === "string") {
            // we need to do some extra parsing to get the parent url correct if we are
            // being created from just a string.
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["isUrlAbsolute"])(baseUrl) || baseUrl.lastIndexOf("/") < 0) {
                _this._parentUrl = baseUrl;
                _this._url = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(baseUrl, path);
            }
            else if (baseUrl.lastIndexOf("/") > baseUrl.lastIndexOf("(")) {
                // .../items(19)/fields
                var index = baseUrl.lastIndexOf("/");
                _this._parentUrl = baseUrl.slice(0, index);
                path = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(baseUrl.slice(index), path);
                _this._url = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(_this._parentUrl, path);
            }
            else {
                // .../items(19)
                var index = baseUrl.lastIndexOf("(");
                _this._parentUrl = baseUrl.slice(0, index);
                _this._url = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(baseUrl, path);
            }
        }
        else {
            _this.extend(baseUrl, path);
            var target = baseUrl.query.get("@target");
            if (target !== undefined) {
                _this.query.set("@target", target);
            }
        }
        return _this;
    }
    /**
     * Creates a new instance of the supplied factory and extends this into that new instance
     *
     * @param factory constructor for the new SharePointQueryable
     */
    SharePointQueryable.prototype.as = function (factory) {
        var o = new factory(this._url, null);
        return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(o, this, true);
    };
    /**
     * Gets the full url with query information
     *
     */
    SharePointQueryable.prototype.toUrlAndQuery = function () {
        var aliasedParams = new Map(this.query);
        var url = this.toUrl().replace(/'!(@.*?)::(.*?)'/ig, function (match, labelName, value) {
            _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("Rewriting aliased parameter from match " + match + " to label: " + labelName + " value: " + value, 0 /* Verbose */);
            aliasedParams.set(labelName, "'" + value + "'");
            return labelName;
        });
        if (aliasedParams.size > 0) {
            var char = url.indexOf("?") > -1 ? "&" : "?";
            url += "" + char + Array.from(aliasedParams).map(function (v) { return v[0] + "=" + v[1]; }).join("&");
        }
        return url;
    };
    /**
     * Choose which fields to return
     *
     * @param selects One or more fields to return
     */
    SharePointQueryable.prototype.select = function () {
        var selects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            selects[_i] = arguments[_i];
        }
        if (selects.length > 0) {
            this.query.set("$select", selects.join(","));
        }
        return this;
    };
    /**
     * Expands fields such as lookups to get additional data
     *
     * @param expands The Fields for which to expand the values
     */
    SharePointQueryable.prototype.expand = function () {
        var expands = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            expands[_i] = arguments[_i];
        }
        if (expands.length > 0) {
            this.query.set("$expand", expands.join(","));
        }
        return this;
    };
    /**
     * Gets a parent for this instance as specified
     *
     * @param factory The contructor for the class to create
     */
    SharePointQueryable.prototype.getParent = function (factory, baseUrl, path, batch) {
        if (baseUrl === void 0) { baseUrl = this.parentUrl; }
        var parent = new factory(baseUrl, path).configureFrom(this);
        var t = "@target";
        if (this.query.has(t)) {
            parent.query.set(t, this.query.get(t));
        }
        if (batch !== undefined) {
            parent = parent.inBatch(batch);
        }
        return parent;
    };
    /**
     * Clones this SharePointQueryable into a new SharePointQueryable instance of T
     * @param factory Constructor used to create the new instance
     * @param additionalPath Any additional path to include in the clone
     * @param includeBatch If true this instance's batch will be added to the cloned instance
     */
    SharePointQueryable.prototype.clone = function (factory, additionalPath, includeBatch) {
        if (includeBatch === void 0) { includeBatch = true; }
        var clone = new factory(this, additionalPath).configureFrom(this);
        var t = "@target";
        if (this.query.has(t)) {
            clone.query.set(t, this.query.get(t));
        }
        if (includeBatch && this.hasBatch) {
            clone = clone.inBatch(this.batch);
        }
        return clone;
    };
    /**
     * Converts the current instance to a request context
     *
     * @param verb The request verb
     * @param options The set of supplied request options
     * @param parser The supplied ODataParser instance
     * @param pipeline Optional request processing pipeline
     */
    SharePointQueryable.prototype.toRequestContext = function (verb, options, parser, pipeline) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var dependencyDispose = this.hasBatch ? this.addBatchDependency() : function () { return; };
        return toAbsoluteUrl(this.toUrlAndQuery()).then(function (url) {
            Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["mergeOptions"])(options, _this._options);
            // build our request context
            var context = {
                batch: _this.batch,
                batchDependency: dependencyDispose,
                cachingOptions: _this._cachingOptions,
                clientFactory: function () { return new SPHttpClient(); },
                isBatched: _this.hasBatch,
                isCached: _this._forceCaching || (_this._useCaching && /^get$/i.test(verb)),
                options: options,
                parser: parser,
                pipeline: pipeline,
                requestAbsoluteUrl: url,
                requestId: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getGUID"])(),
                verb: verb,
            };
            return context;
        });
    };
    return SharePointQueryable;
}(_pnp_odata__WEBPACK_IMPORTED_MODULE_3__["ODataQueryable"]));
/**
 * Represents a REST collection which can be filtered, paged, and selected
 *
 */
var SharePointQueryableCollection = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SharePointQueryableCollection, _super);
    function SharePointQueryableCollection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Filters the returned collection (https://msdn.microsoft.com/en-us/library/office/fp142385.aspx#bk_supported)
     *
     * @param filter The string representing the filter query
     */
    SharePointQueryableCollection.prototype.filter = function (filter) {
        this.query.set("$filter", filter);
        return this;
    };
    /**
     * Orders based on the supplied fields
     *
     * @param orderby The name of the field on which to sort
     * @param ascending If false DESC is appended, otherwise ASC (default)
     */
    SharePointQueryableCollection.prototype.orderBy = function (orderBy, ascending) {
        if (ascending === void 0) { ascending = true; }
        var o = "$orderby";
        var query = this.query.has(o) ? this.query.get(o).split(",") : [];
        query.push(orderBy + " " + (ascending ? "asc" : "desc"));
        this.query.set(o, query.join(","));
        return this;
    };
    /**
     * Skips the specified number of items
     *
     * @param skip The number of items to skip
     */
    SharePointQueryableCollection.prototype.skip = function (skip) {
        this.query.set("$skip", skip.toString());
        return this;
    };
    /**
     * Limits the query to only return the specified number of items
     *
     * @param top The query row limit
     */
    SharePointQueryableCollection.prototype.top = function (top) {
        this.query.set("$top", top.toString());
        return this;
    };
    return SharePointQueryableCollection;
}(SharePointQueryable));
/**
 * Represents an instance that can be selected
 *
 */
var SharePointQueryableInstance = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SharePointQueryableInstance, _super);
    function SharePointQueryableInstance() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Curries the update function into the common pieces
     *
     * @param type
     * @param mapper
     */
    SharePointQueryableInstance.prototype._update = function (type, mapper) {
        var _this = this;
        return function (props) { return _this.postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata(type), props)),
            headers: {
                "X-HTTP-Method": "MERGE",
            },
        }).then(function (d) { return mapper(d, props); }); };
    };
    /**
    * Deletes this instance
    *
    */
    SharePointQueryableInstance.prototype._delete = function () {
        return this.postCore({
            headers: {
                "X-HTTP-Method": "DELETE",
            },
        });
    };
    /**
     * Deletes this instance with an etag value in the headers
     *
     * @param eTag eTag to delete
     */
    SharePointQueryableInstance.prototype._deleteWithETag = function (eTag) {
        if (eTag === void 0) { eTag = "*"; }
        return this.postCore({
            headers: {
                "IF-Match": eTag,
                "X-HTTP-Method": "DELETE",
            },
        });
    };
    return SharePointQueryableInstance;
}(SharePointQueryable));
/**
 * Decorator used to specify the default path for SharePointQueryable objects
 *
 * @param path
 */
function defaultPath(path) {
    return function (target) {
        return /** @class */ (function (_super) {
            Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _super.call(this, args[0], args.length > 1 && args[1] !== undefined ? args[1] : path) || this;
            }
            return class_1;
        }(target));
    };
}

/**
 * Describes a collection of all site collection users
 *
 */
var SiteUsers = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SiteUsers, _super);
    function SiteUsers() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SiteUsers_1 = SiteUsers;
    /**
     * Gets a user from the collection by id
     *
     * @param id The id of the user to retrieve
     */
    SiteUsers.prototype.getById = function (id) {
        return new SiteUser(this, "getById(" + id + ")");
    };
    /**
     * Gets a user from the collection by email
     *
     * @param email The email address of the user to retrieve
     */
    SiteUsers.prototype.getByEmail = function (email) {
        return new SiteUser(this, "getByEmail('" + email + "')");
    };
    /**
     * Gets a user from the collection by login name
     *
     * @param loginName The login name of the user to retrieve
     */
    SiteUsers.prototype.getByLoginName = function (loginName) {
        var su = new SiteUser(this);
        su.concat("('!@v::" + encodeURIComponent(loginName) + "')");
        return su;
    };
    /**
     * Removes a user from the collection by id
     *
     * @param id The id of the user to remove
     */
    SiteUsers.prototype.removeById = function (id) {
        return this.clone(SiteUsers_1, "removeById(" + id + ")").postCore();
    };
    /**
     * Removes a user from the collection by login name
     *
     * @param loginName The login name of the user to remove
     */
    SiteUsers.prototype.removeByLoginName = function (loginName) {
        var o = this.clone(SiteUsers_1, "removeByLoginName(@v)");
        o.query.set("@v", "'" + encodeURIComponent(loginName) + "'");
        return o.postCore();
    };
    /**
     * Adds a user to a group
     *
     * @param loginName The login name of the user to add to the group
     *
     */
    SiteUsers.prototype.add = function (loginName) {
        var _this = this;
        return this.clone(SiteUsers_1, null).postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.User"), { LoginName: loginName })),
        }).then(function () { return _this.getByLoginName(loginName); });
    };
    var SiteUsers_1;
    SiteUsers = SiteUsers_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("siteusers")
    ], SiteUsers);
    return SiteUsers;
}(SharePointQueryableCollection));
/**
 * Describes a single user
 *
 */
var SiteUser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SiteUser, _super);
    function SiteUser() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
        * Updates this user instance with the supplied properties
        *
        * @param properties A plain object of property names and values to update for the user
        */
        _this.update = _this._update("SP.User", function (data) { return ({ data: data, user: _this }); });
        /**
         * Delete this user
         *
         */
        _this.delete = _this._delete;
        return _this;
    }
    Object.defineProperty(SiteUser.prototype, "groups", {
        /**
         * Gets the groups for this user
         *
         */
        get: function () {
            return new SiteGroups(this, "groups");
        },
        enumerable: true,
        configurable: true
    });
    return SiteUser;
}(SharePointQueryableInstance));
/**
 * Represents the current user
 */
var CurrentUser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(CurrentUser, _super);
    function CurrentUser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CurrentUser = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("currentuser")
    ], CurrentUser);
    return CurrentUser;
}(SharePointQueryableInstance));

/**
 * Principal Type enum
 *
 */
var PrincipalType;
(function (PrincipalType) {
    PrincipalType[PrincipalType["None"] = 0] = "None";
    PrincipalType[PrincipalType["User"] = 1] = "User";
    PrincipalType[PrincipalType["DistributionList"] = 2] = "DistributionList";
    PrincipalType[PrincipalType["SecurityGroup"] = 4] = "SecurityGroup";
    PrincipalType[PrincipalType["SharePointGroup"] = 8] = "SharePointGroup";
    PrincipalType[PrincipalType["All"] = 15] = "All";
})(PrincipalType || (PrincipalType = {}));
/**
 * Describes a collection of site groups
 *
 */
var SiteGroups = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SiteGroups, _super);
    function SiteGroups() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SiteGroups_1 = SiteGroups;
    /**
     * Gets a group from the collection by id
     *
     * @param id The id of the group to retrieve
     */
    SiteGroups.prototype.getById = function (id) {
        var sg = new SiteGroup(this);
        sg.concat("(" + id + ")");
        return sg;
    };
    /**
     * Adds a new group to the site collection
     *
     * @param props The group properties object of property names and values to be set for the group
     */
    SiteGroups.prototype.add = function (properties) {
        var _this = this;
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.Group"), properties));
        return this.postCore({ body: postBody }).then(function (data) {
            return {
                data: data,
                group: _this.getById(data.Id),
            };
        });
    };
    /**
     * Gets a group from the collection by name
     *
     * @param groupName The name of the group to retrieve
     */
    SiteGroups.prototype.getByName = function (groupName) {
        return new SiteGroup(this, "getByName('" + groupName + "')");
    };
    /**
     * Removes the group with the specified member id from the collection
     *
     * @param id The id of the group to remove
     */
    SiteGroups.prototype.removeById = function (id) {
        return this.clone(SiteGroups_1, "removeById('" + id + "')").postCore();
    };
    /**
     * Removes the cross-site group with the specified name from the collection
     *
     * @param loginName The name of the group to remove
     */
    SiteGroups.prototype.removeByLoginName = function (loginName) {
        return this.clone(SiteGroups_1, "removeByLoginName('" + loginName + "')").postCore();
    };
    var SiteGroups_1;
    SiteGroups = SiteGroups_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("sitegroups")
    ], SiteGroups);
    return SiteGroups;
}(SharePointQueryableCollection));
/**
 * Describes a single group
 *
 */
var SiteGroup = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SiteGroup, _super);
    function SiteGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.update = _this._update("SP.Group", function (d, p) {
            var retGroup = _this;
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(p, "Title")) {
                /* tslint:disable-next-line no-string-literal */
                retGroup = _this.getParent(SiteGroup, _this.parentUrl, "getByName('" + p["Title"] + "')");
            }
            return {
                data: d,
                group: retGroup,
            };
        });
        return _this;
    }
    Object.defineProperty(SiteGroup.prototype, "users", {
        /**
         * Gets the users for this group
         *
         */
        get: function () {
            return new SiteUsers(this, "users");
        },
        enumerable: true,
        configurable: true
    });
    return SiteGroup;
}(SharePointQueryableInstance));

/**
 * Describes a set of role assignments for the current scope
 *
 */
var RoleAssignments = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(RoleAssignments, _super);
    function RoleAssignments() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RoleAssignments_1 = RoleAssignments;
    /**
     * Gets the role assignment associated with the specified principal id from the collection.
     *
     * @param id The id of the role assignment
     */
    RoleAssignments.prototype.getById = function (id) {
        var ra = new RoleAssignment(this);
        ra.concat("(" + id + ")");
        return ra;
    };
    /**
     * Adds a new role assignment with the specified principal and role definitions to the collection
     *
     * @param principalId The id of the user or group to assign permissions to
     * @param roleDefId The id of the role definition that defines the permissions to assign
     *
     */
    RoleAssignments.prototype.add = function (principalId, roleDefId) {
        return this.clone(RoleAssignments_1, "addroleassignment(principalid=" + principalId + ", roledefid=" + roleDefId + ")").postCore();
    };
    /**
     * Removes the role assignment with the specified principal and role definition from the collection
     *
     * @param principalId The id of the user or group in the role assignment
     * @param roleDefId The id of the role definition in the role assignment
     *
     */
    RoleAssignments.prototype.remove = function (principalId, roleDefId) {
        return this.clone(RoleAssignments_1, "removeroleassignment(principalid=" + principalId + ", roledefid=" + roleDefId + ")").postCore();
    };
    var RoleAssignments_1;
    RoleAssignments = RoleAssignments_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("roleassignments")
    ], RoleAssignments);
    return RoleAssignments;
}(SharePointQueryableCollection));
/**
 * Describes a role assignment
 *
 */
var RoleAssignment = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(RoleAssignment, _super);
    function RoleAssignment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Deletes this role assignment
         *
         */
        _this.delete = _this._delete;
        return _this;
    }
    Object.defineProperty(RoleAssignment.prototype, "groups", {
        /**
         * Gets the groups that directly belong to the access control list (ACL) for this securable object
         *
         */
        get: function () {
            return new SiteGroups(this, "groups");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RoleAssignment.prototype, "bindings", {
        /**
         * Gets the role definition bindings for this role assignment
         *
         */
        get: function () {
            return new RoleDefinitionBindings(this);
        },
        enumerable: true,
        configurable: true
    });
    return RoleAssignment;
}(SharePointQueryableInstance));
/**
 * Describes a collection of role definitions
 *
 */
var RoleDefinitions = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(RoleDefinitions, _super);
    function RoleDefinitions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets the role definition with the specified id from the collection
     *
     * @param id The id of the role definition
     *
     */
    RoleDefinitions.prototype.getById = function (id) {
        return new RoleDefinition(this, "getById(" + id + ")");
    };
    /**
     * Gets the role definition with the specified name
     *
     * @param name The name of the role definition
     *
     */
    RoleDefinitions.prototype.getByName = function (name) {
        return new RoleDefinition(this, "getbyname('" + name + "')");
    };
    /**
     * Gets the role definition with the specified role type
     *
     * @param roleTypeKind The roletypekind of the role definition (None=0, Guest=1, Reader=2, Contributor=3, WebDesigner=4, Administrator=5, Editor=6, System=7)
     *
     */
    RoleDefinitions.prototype.getByType = function (roleTypeKind) {
        return new RoleDefinition(this, "getbytype(" + roleTypeKind + ")");
    };
    /**
     * Creates a role definition
     *
     * @param name The new role definition's name
     * @param description The new role definition's description
     * @param order The order in which the role definition appears
     * @param basePermissions The permissions mask for this role definition
     *
     */
    RoleDefinitions.prototype.add = function (name, description, order, basePermissions) {
        var _this = this;
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            BasePermissions: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ __metadata: { type: "SP.BasePermissions" } }, basePermissions),
            Description: description,
            Name: name,
            Order: order,
            __metadata: { "type": "SP.RoleDefinition" },
        });
        return this.postCore({ body: postBody }).then(function (data) {
            return {
                data: data,
                definition: _this.getById(data.Id),
            };
        });
    };
    RoleDefinitions = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("roledefinitions")
    ], RoleDefinitions);
    return RoleDefinitions;
}(SharePointQueryableCollection));
/**
 * Describes a role definition
 *
 */
var RoleDefinition = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(RoleDefinition, _super);
    function RoleDefinition() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Deletes this role definition
         *
         */
        _this.delete = _this._delete;
        return _this;
        /* tslint:enable */
    }
    /**
     * Updates this role definition with the supplied properties
     *
     * @param properties A plain object hash of values to update for the role definition
     */
    /* tslint:disable no-string-literal */
    RoleDefinition.prototype.update = function (properties) {
        var _this = this;
        var s = ["BasePermissions"];
        if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(properties, s[0]) !== undefined) {
            properties[s[0]] = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ __metadata: { type: "SP." + s[0] } }, properties[s[0]]);
        }
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.RoleDefinition"), properties));
        return this.postCore({
            body: postBody,
            headers: {
                "X-HTTP-Method": "MERGE",
            },
        }).then(function (data) {
            var retDef = _this;
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(properties, "Name")) {
                var parent_1 = _this.getParent(RoleDefinitions, _this.parentUrl, "");
                retDef = parent_1.getByName(properties["Name"]);
            }
            return {
                data: data,
                definition: retDef,
            };
        });
    };
    return RoleDefinition;
}(SharePointQueryableInstance));
/**
 * Describes the role definitons bound to a role assignment object
 *
 */
var RoleDefinitionBindings = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(RoleDefinitionBindings, _super);
    function RoleDefinitionBindings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RoleDefinitionBindings = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("roledefinitionbindings")
    ], RoleDefinitionBindings);
    return RoleDefinitionBindings;
}(SharePointQueryableCollection));

/**
 * Determines the display mode of the given control or view
 */
var ControlMode;
(function (ControlMode) {
    ControlMode[ControlMode["Display"] = 1] = "Display";
    ControlMode[ControlMode["Edit"] = 2] = "Edit";
    ControlMode[ControlMode["New"] = 3] = "New";
})(ControlMode || (ControlMode = {}));
/**
 * Specifies the type of the field.
 */
var FieldTypes;
(function (FieldTypes) {
    FieldTypes[FieldTypes["Invalid"] = 0] = "Invalid";
    FieldTypes[FieldTypes["Integer"] = 1] = "Integer";
    FieldTypes[FieldTypes["Text"] = 2] = "Text";
    FieldTypes[FieldTypes["Note"] = 3] = "Note";
    FieldTypes[FieldTypes["DateTime"] = 4] = "DateTime";
    FieldTypes[FieldTypes["Counter"] = 5] = "Counter";
    FieldTypes[FieldTypes["Choice"] = 6] = "Choice";
    FieldTypes[FieldTypes["Lookup"] = 7] = "Lookup";
    FieldTypes[FieldTypes["Boolean"] = 8] = "Boolean";
    FieldTypes[FieldTypes["Number"] = 9] = "Number";
    FieldTypes[FieldTypes["Currency"] = 10] = "Currency";
    FieldTypes[FieldTypes["URL"] = 11] = "URL";
    FieldTypes[FieldTypes["Computed"] = 12] = "Computed";
    FieldTypes[FieldTypes["Threading"] = 13] = "Threading";
    FieldTypes[FieldTypes["Guid"] = 14] = "Guid";
    FieldTypes[FieldTypes["MultiChoice"] = 15] = "MultiChoice";
    FieldTypes[FieldTypes["GridChoice"] = 16] = "GridChoice";
    FieldTypes[FieldTypes["Calculated"] = 17] = "Calculated";
    FieldTypes[FieldTypes["File"] = 18] = "File";
    FieldTypes[FieldTypes["Attachments"] = 19] = "Attachments";
    FieldTypes[FieldTypes["User"] = 20] = "User";
    FieldTypes[FieldTypes["Recurrence"] = 21] = "Recurrence";
    FieldTypes[FieldTypes["CrossProjectLink"] = 22] = "CrossProjectLink";
    FieldTypes[FieldTypes["ModStat"] = 23] = "ModStat";
    FieldTypes[FieldTypes["Error"] = 24] = "Error";
    FieldTypes[FieldTypes["ContentTypeId"] = 25] = "ContentTypeId";
    FieldTypes[FieldTypes["PageSeparator"] = 26] = "PageSeparator";
    FieldTypes[FieldTypes["ThreadIndex"] = 27] = "ThreadIndex";
    FieldTypes[FieldTypes["WorkflowStatus"] = 28] = "WorkflowStatus";
    FieldTypes[FieldTypes["AllDayEvent"] = 29] = "AllDayEvent";
    FieldTypes[FieldTypes["WorkflowEventType"] = 30] = "WorkflowEventType";
})(FieldTypes || (FieldTypes = {}));
var DateTimeFieldFormatType;
(function (DateTimeFieldFormatType) {
    DateTimeFieldFormatType[DateTimeFieldFormatType["DateOnly"] = 0] = "DateOnly";
    DateTimeFieldFormatType[DateTimeFieldFormatType["DateTime"] = 1] = "DateTime";
})(DateTimeFieldFormatType || (DateTimeFieldFormatType = {}));
/**
 * Specifies the control settings while adding a field.
 */
var AddFieldOptions;
(function (AddFieldOptions) {
    /**
     *  Specify that a new field added to the list must also be added to the default content type in the site collection
     */
    AddFieldOptions[AddFieldOptions["DefaultValue"] = 0] = "DefaultValue";
    /**
     * Specify that a new field added to the list must also be added to the default content type in the site collection.
     */
    AddFieldOptions[AddFieldOptions["AddToDefaultContentType"] = 1] = "AddToDefaultContentType";
    /**
     * Specify that a new field must not be added to any other content type
     */
    AddFieldOptions[AddFieldOptions["AddToNoContentType"] = 2] = "AddToNoContentType";
    /**
     *  Specify that a new field that is added to the specified list must also be added to all content types in the site collection
     */
    AddFieldOptions[AddFieldOptions["AddToAllContentTypes"] = 4] = "AddToAllContentTypes";
    /**
     * Specify adding an internal field name hint for the purpose of avoiding possible database locking or field renaming operations
     */
    AddFieldOptions[AddFieldOptions["AddFieldInternalNameHint"] = 8] = "AddFieldInternalNameHint";
    /**
     * Specify that a new field that is added to the specified list must also be added to the default list view
     */
    AddFieldOptions[AddFieldOptions["AddFieldToDefaultView"] = 16] = "AddFieldToDefaultView";
    /**
     * Specify to confirm that no other field has the same display name
     */
    AddFieldOptions[AddFieldOptions["AddFieldCheckDisplayName"] = 32] = "AddFieldCheckDisplayName";
})(AddFieldOptions || (AddFieldOptions = {}));
var CalendarType;
(function (CalendarType) {
    CalendarType[CalendarType["Gregorian"] = 1] = "Gregorian";
    CalendarType[CalendarType["Japan"] = 3] = "Japan";
    CalendarType[CalendarType["Taiwan"] = 4] = "Taiwan";
    CalendarType[CalendarType["Korea"] = 5] = "Korea";
    CalendarType[CalendarType["Hijri"] = 6] = "Hijri";
    CalendarType[CalendarType["Thai"] = 7] = "Thai";
    CalendarType[CalendarType["Hebrew"] = 8] = "Hebrew";
    CalendarType[CalendarType["GregorianMEFrench"] = 9] = "GregorianMEFrench";
    CalendarType[CalendarType["GregorianArabic"] = 10] = "GregorianArabic";
    CalendarType[CalendarType["GregorianXLITEnglish"] = 11] = "GregorianXLITEnglish";
    CalendarType[CalendarType["GregorianXLITFrench"] = 12] = "GregorianXLITFrench";
    CalendarType[CalendarType["KoreaJapanLunar"] = 14] = "KoreaJapanLunar";
    CalendarType[CalendarType["ChineseLunar"] = 15] = "ChineseLunar";
    CalendarType[CalendarType["SakaEra"] = 16] = "SakaEra";
    CalendarType[CalendarType["UmAlQura"] = 23] = "UmAlQura";
})(CalendarType || (CalendarType = {}));
var UrlFieldFormatType;
(function (UrlFieldFormatType) {
    UrlFieldFormatType[UrlFieldFormatType["Hyperlink"] = 0] = "Hyperlink";
    UrlFieldFormatType[UrlFieldFormatType["Image"] = 1] = "Image";
})(UrlFieldFormatType || (UrlFieldFormatType = {}));
var PermissionKind;
(function (PermissionKind) {
    /**
     * Has no permissions on the Site. Not available through the user interface.
     */
    PermissionKind[PermissionKind["EmptyMask"] = 0] = "EmptyMask";
    /**
     * View items in lists, documents in document libraries, and Web discussion comments.
     */
    PermissionKind[PermissionKind["ViewListItems"] = 1] = "ViewListItems";
    /**
     * Add items to lists, documents to document libraries, and Web discussion comments.
     */
    PermissionKind[PermissionKind["AddListItems"] = 2] = "AddListItems";
    /**
     * Edit items in lists, edit documents in document libraries, edit Web discussion comments
     * in documents, and customize Web Part Pages in document libraries.
     */
    PermissionKind[PermissionKind["EditListItems"] = 3] = "EditListItems";
    /**
     * Delete items from a list, documents from a document library, and Web discussion
     * comments in documents.
     */
    PermissionKind[PermissionKind["DeleteListItems"] = 4] = "DeleteListItems";
    /**
     * Approve a minor version of a list item or document.
     */
    PermissionKind[PermissionKind["ApproveItems"] = 5] = "ApproveItems";
    /**
     * View the source of documents with server-side file handlers.
     */
    PermissionKind[PermissionKind["OpenItems"] = 6] = "OpenItems";
    /**
     * View past versions of a list item or document.
     */
    PermissionKind[PermissionKind["ViewVersions"] = 7] = "ViewVersions";
    /**
     * Delete past versions of a list item or document.
     */
    PermissionKind[PermissionKind["DeleteVersions"] = 8] = "DeleteVersions";
    /**
     * Discard or check in a document which is checked out to another user.
     */
    PermissionKind[PermissionKind["CancelCheckout"] = 9] = "CancelCheckout";
    /**
     * Create, change, and delete personal views of lists.
     */
    PermissionKind[PermissionKind["ManagePersonalViews"] = 10] = "ManagePersonalViews";
    /**
     * Create and delete lists, add or remove columns in a list, and add or remove public views of a list.
     */
    PermissionKind[PermissionKind["ManageLists"] = 12] = "ManageLists";
    /**
     * View forms, views, and application pages, and enumerate lists.
     */
    PermissionKind[PermissionKind["ViewFormPages"] = 13] = "ViewFormPages";
    /**
     * Make content of a list or document library retrieveable for anonymous users through SharePoint search.
     * The list permissions in the site do not change.
     */
    PermissionKind[PermissionKind["AnonymousSearchAccessList"] = 14] = "AnonymousSearchAccessList";
    /**
     * Allow users to open a Site, list, or folder to access items inside that container.
     */
    PermissionKind[PermissionKind["Open"] = 17] = "Open";
    /**
     * View pages in a Site.
     */
    PermissionKind[PermissionKind["ViewPages"] = 18] = "ViewPages";
    /**
     * Add, change, or delete HTML pages or Web Part Pages, and edit the Site using
     * a Windows SharePoint Services compatible editor.
     */
    PermissionKind[PermissionKind["AddAndCustomizePages"] = 19] = "AddAndCustomizePages";
    /**
     * Apply a theme or borders to the entire Site.
     */
    PermissionKind[PermissionKind["ApplyThemeAndBorder"] = 20] = "ApplyThemeAndBorder";
    /**
     * Apply a style sheet (.css file) to the Site.
     */
    PermissionKind[PermissionKind["ApplyStyleSheets"] = 21] = "ApplyStyleSheets";
    /**
     * View reports on Site usage.
     */
    PermissionKind[PermissionKind["ViewUsageData"] = 22] = "ViewUsageData";
    /**
     * Create a Site using Self-Service Site Creation.
     */
    PermissionKind[PermissionKind["CreateSSCSite"] = 23] = "CreateSSCSite";
    /**
     * Create subsites such as team sites, Meeting Workspace sites, and Document Workspace sites.
     */
    PermissionKind[PermissionKind["ManageSubwebs"] = 24] = "ManageSubwebs";
    /**
     * Create a group of users that can be used anywhere within the site collection.
     */
    PermissionKind[PermissionKind["CreateGroups"] = 25] = "CreateGroups";
    /**
     * Create and change permission levels on the Site and assign permissions to users
     * and groups.
     */
    PermissionKind[PermissionKind["ManagePermissions"] = 26] = "ManagePermissions";
    /**
     * Enumerate files and folders in a Site using Microsoft Office SharePoint Designer
     * and WebDAV interfaces.
     */
    PermissionKind[PermissionKind["BrowseDirectories"] = 27] = "BrowseDirectories";
    /**
     * View information about users of the Site.
     */
    PermissionKind[PermissionKind["BrowseUserInfo"] = 28] = "BrowseUserInfo";
    /**
     * Add or remove personal Web Parts on a Web Part Page.
     */
    PermissionKind[PermissionKind["AddDelPrivateWebParts"] = 29] = "AddDelPrivateWebParts";
    /**
     * Update Web Parts to display personalized information.
     */
    PermissionKind[PermissionKind["UpdatePersonalWebParts"] = 30] = "UpdatePersonalWebParts";
    /**
     * Grant the ability to perform all administration tasks for the Site as well as
     * manage content, activate, deactivate, or edit properties of Site scoped Features
     * through the object model or through the user interface (UI). When granted on the
     * root Site of a Site Collection, activate, deactivate, or edit properties of
     * site collection scoped Features through the object model. To browse to the Site
     * Collection Features page and activate or deactivate Site Collection scoped Features
     * through the UI, you must be a Site Collection administrator.
     */
    PermissionKind[PermissionKind["ManageWeb"] = 31] = "ManageWeb";
    /**
     * Content of lists and document libraries in the Web site will be retrieveable for anonymous users through
     * SharePoint search if the list or document library has AnonymousSearchAccessList set.
     */
    PermissionKind[PermissionKind["AnonymousSearchAccessWebLists"] = 32] = "AnonymousSearchAccessWebLists";
    /**
     * Use features that launch client applications. Otherwise, users must work on documents
     * locally and upload changes.
     */
    PermissionKind[PermissionKind["UseClientIntegration"] = 37] = "UseClientIntegration";
    /**
     * Use SOAP, WebDAV, or Microsoft Office SharePoint Designer interfaces to access the Site.
     */
    PermissionKind[PermissionKind["UseRemoteAPIs"] = 38] = "UseRemoteAPIs";
    /**
     * Manage alerts for all users of the Site.
     */
    PermissionKind[PermissionKind["ManageAlerts"] = 39] = "ManageAlerts";
    /**
     * Create e-mail alerts.
     */
    PermissionKind[PermissionKind["CreateAlerts"] = 40] = "CreateAlerts";
    /**
     * Allows a user to change his or her user information, such as adding a picture.
     */
    PermissionKind[PermissionKind["EditMyUserInfo"] = 41] = "EditMyUserInfo";
    /**
     * Enumerate permissions on Site, list, folder, document, or list item.
     */
    PermissionKind[PermissionKind["EnumeratePermissions"] = 63] = "EnumeratePermissions";
    /**
     * Has all permissions on the Site. Not available through the user interface.
     */
    PermissionKind[PermissionKind["FullMask"] = 65] = "FullMask";
})(PermissionKind || (PermissionKind = {}));
/**
 * Specifies the type of a principal.
 */
/* tslint:disable:no-bitwise */
var PrincipalType$1;
(function (PrincipalType) {
    /**
     * Enumeration whose value specifies no principal type.
     */
    PrincipalType[PrincipalType["None"] = 0] = "None";
    /**
     * Enumeration whose value specifies a user as the principal type.
     */
    PrincipalType[PrincipalType["User"] = 1] = "User";
    /**
     * Enumeration whose value specifies a distribution list as the principal type.
     */
    PrincipalType[PrincipalType["DistributionList"] = 2] = "DistributionList";
    /**
     * Enumeration whose value specifies a security group as the principal type.
     */
    PrincipalType[PrincipalType["SecurityGroup"] = 4] = "SecurityGroup";
    /**
     * Enumeration whose value specifies a group as the principal type.
     */
    PrincipalType[PrincipalType["SharePointGroup"] = 8] = "SharePointGroup";
    /**
     * Enumeration whose value specifies all principal types.
     */
    PrincipalType[PrincipalType["All"] = 15] = "All";
})(PrincipalType$1 || (PrincipalType$1 = {}));
/* tslint:enable:no-bitwise */
/**
 * Specifies the source of a principal.
 */
/* tslint:disable:no-bitwise */
var PrincipalSource;
(function (PrincipalSource) {
    /**
     * Enumeration whose value specifies no principal source.
     */
    PrincipalSource[PrincipalSource["None"] = 0] = "None";
    /**
     * Enumeration whose value specifies user information list as the principal source.
     */
    PrincipalSource[PrincipalSource["UserInfoList"] = 1] = "UserInfoList";
    /**
     * Enumeration whose value specifies Active Directory as the principal source.
     */
    PrincipalSource[PrincipalSource["Windows"] = 2] = "Windows";
    /**
     * Enumeration whose value specifies the current membership provider as the principal source.
     */
    PrincipalSource[PrincipalSource["MembershipProvider"] = 4] = "MembershipProvider";
    /**
     * Enumeration whose value specifies the current role provider as the principal source.
     */
    PrincipalSource[PrincipalSource["RoleProvider"] = 8] = "RoleProvider";
    /**
     * Enumeration whose value specifies all principal sources.
     */
    PrincipalSource[PrincipalSource["All"] = 15] = "All";
})(PrincipalSource || (PrincipalSource = {}));
/* tslint:enable:no-bitwise */
var RoleType;
(function (RoleType) {
    RoleType[RoleType["None"] = 0] = "None";
    RoleType[RoleType["Guest"] = 1] = "Guest";
    RoleType[RoleType["Reader"] = 2] = "Reader";
    RoleType[RoleType["Contributor"] = 3] = "Contributor";
    RoleType[RoleType["WebDesigner"] = 4] = "WebDesigner";
    RoleType[RoleType["Administrator"] = 5] = "Administrator";
})(RoleType || (RoleType = {}));
var PageType;
(function (PageType) {
    PageType[PageType["Invalid"] = -1] = "Invalid";
    PageType[PageType["DefaultView"] = 0] = "DefaultView";
    PageType[PageType["NormalView"] = 1] = "NormalView";
    PageType[PageType["DialogView"] = 2] = "DialogView";
    PageType[PageType["View"] = 3] = "View";
    PageType[PageType["DisplayForm"] = 4] = "DisplayForm";
    PageType[PageType["DisplayFormDialog"] = 5] = "DisplayFormDialog";
    PageType[PageType["EditForm"] = 6] = "EditForm";
    PageType[PageType["EditFormDialog"] = 7] = "EditFormDialog";
    PageType[PageType["NewForm"] = 8] = "NewForm";
    PageType[PageType["NewFormDialog"] = 9] = "NewFormDialog";
    PageType[PageType["SolutionForm"] = 10] = "SolutionForm";
    PageType[PageType["PAGE_MAXITEMS"] = 11] = "PAGE_MAXITEMS";
})(PageType || (PageType = {}));
var SharingLinkKind;
(function (SharingLinkKind) {
    /**
     * Uninitialized link
     */
    SharingLinkKind[SharingLinkKind["Uninitialized"] = 0] = "Uninitialized";
    /**
     * Direct link to the object being shared
     */
    SharingLinkKind[SharingLinkKind["Direct"] = 1] = "Direct";
    /**
     * Organization-shareable link to the object being shared with view permissions
     */
    SharingLinkKind[SharingLinkKind["OrganizationView"] = 2] = "OrganizationView";
    /**
     * Organization-shareable link to the object being shared with edit permissions
     */
    SharingLinkKind[SharingLinkKind["OrganizationEdit"] = 3] = "OrganizationEdit";
    /**
     * View only anonymous link
     */
    SharingLinkKind[SharingLinkKind["AnonymousView"] = 4] = "AnonymousView";
    /**
     * Read/Write anonymous link
     */
    SharingLinkKind[SharingLinkKind["AnonymousEdit"] = 5] = "AnonymousEdit";
    /**
     * Flexible sharing Link where properties can change without affecting link URL
     */
    SharingLinkKind[SharingLinkKind["Flexible"] = 6] = "Flexible";
})(SharingLinkKind || (SharingLinkKind = {}));
/**
 * Indicates the role of the sharing link
 */
var SharingRole;
(function (SharingRole) {
    SharingRole[SharingRole["None"] = 0] = "None";
    SharingRole[SharingRole["View"] = 1] = "View";
    SharingRole[SharingRole["Edit"] = 2] = "Edit";
    SharingRole[SharingRole["Owner"] = 3] = "Owner";
})(SharingRole || (SharingRole = {}));
var SharingOperationStatusCode;
(function (SharingOperationStatusCode) {
    /**
     * The share operation completed without errors.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["CompletedSuccessfully"] = 0] = "CompletedSuccessfully";
    /**
     * The share operation completed and generated requests for access.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["AccessRequestsQueued"] = 1] = "AccessRequestsQueued";
    /**
     * The share operation failed as there were no resolved users.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["NoResolvedUsers"] = -1] = "NoResolvedUsers";
    /**
     * The share operation failed due to insufficient permissions.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["AccessDenied"] = -2] = "AccessDenied";
    /**
     * The share operation failed when attempting a cross site share, which is not supported.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["CrossSiteRequestNotSupported"] = -3] = "CrossSiteRequestNotSupported";
    /**
     * The sharing operation failed due to an unknown error.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["UnknowError"] = -4] = "UnknowError";
    /**
     * The text you typed is too long. Please shorten it.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["EmailBodyTooLong"] = -5] = "EmailBodyTooLong";
    /**
     * The maximum number of unique scopes in the list has been exceeded.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["ListUniqueScopesExceeded"] = -6] = "ListUniqueScopesExceeded";
    /**
     * The share operation failed because a sharing capability is disabled in the site.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["CapabilityDisabled"] = -7] = "CapabilityDisabled";
    /**
     * The specified object for the share operation is not supported.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["ObjectNotSupported"] = -8] = "ObjectNotSupported";
    /**
     * A SharePoint group cannot contain another SharePoint group.
     */
    SharingOperationStatusCode[SharingOperationStatusCode["NestedGroupsNotSupported"] = -9] = "NestedGroupsNotSupported";
})(SharingOperationStatusCode || (SharingOperationStatusCode = {}));
var SPSharedObjectType;
(function (SPSharedObjectType) {
    SPSharedObjectType[SPSharedObjectType["Unknown"] = 0] = "Unknown";
    SPSharedObjectType[SPSharedObjectType["File"] = 1] = "File";
    SPSharedObjectType[SPSharedObjectType["Folder"] = 2] = "Folder";
    SPSharedObjectType[SPSharedObjectType["Item"] = 3] = "Item";
    SPSharedObjectType[SPSharedObjectType["List"] = 4] = "List";
    SPSharedObjectType[SPSharedObjectType["Web"] = 5] = "Web";
    SPSharedObjectType[SPSharedObjectType["Max"] = 6] = "Max";
})(SPSharedObjectType || (SPSharedObjectType = {}));
var SharingDomainRestrictionMode;
(function (SharingDomainRestrictionMode) {
    SharingDomainRestrictionMode[SharingDomainRestrictionMode["None"] = 0] = "None";
    SharingDomainRestrictionMode[SharingDomainRestrictionMode["AllowList"] = 1] = "AllowList";
    SharingDomainRestrictionMode[SharingDomainRestrictionMode["BlockList"] = 2] = "BlockList";
})(SharingDomainRestrictionMode || (SharingDomainRestrictionMode = {}));
var RenderListDataOptions;
(function (RenderListDataOptions) {
    RenderListDataOptions[RenderListDataOptions["None"] = 0] = "None";
    RenderListDataOptions[RenderListDataOptions["ContextInfo"] = 1] = "ContextInfo";
    RenderListDataOptions[RenderListDataOptions["ListData"] = 2] = "ListData";
    RenderListDataOptions[RenderListDataOptions["ListSchema"] = 4] = "ListSchema";
    RenderListDataOptions[RenderListDataOptions["MenuView"] = 8] = "MenuView";
    RenderListDataOptions[RenderListDataOptions["ListContentType"] = 16] = "ListContentType";
    RenderListDataOptions[RenderListDataOptions["FileSystemItemId"] = 32] = "FileSystemItemId";
    RenderListDataOptions[RenderListDataOptions["ClientFormSchema"] = 64] = "ClientFormSchema";
    RenderListDataOptions[RenderListDataOptions["QuickLaunch"] = 128] = "QuickLaunch";
    RenderListDataOptions[RenderListDataOptions["Spotlight"] = 256] = "Spotlight";
    RenderListDataOptions[RenderListDataOptions["Visualization"] = 512] = "Visualization";
    RenderListDataOptions[RenderListDataOptions["ViewMetadata"] = 1024] = "ViewMetadata";
    RenderListDataOptions[RenderListDataOptions["DisableAutoHyperlink"] = 2048] = "DisableAutoHyperlink";
    RenderListDataOptions[RenderListDataOptions["EnableMediaTAUrls"] = 4096] = "EnableMediaTAUrls";
    RenderListDataOptions[RenderListDataOptions["ParentInfo"] = 8192] = "ParentInfo";
    RenderListDataOptions[RenderListDataOptions["PageContextInfo"] = 16384] = "PageContextInfo";
    RenderListDataOptions[RenderListDataOptions["ClientSideComponentManifest"] = 32768] = "ClientSideComponentManifest";
})(RenderListDataOptions || (RenderListDataOptions = {}));
var FieldUserSelectionMode;
(function (FieldUserSelectionMode) {
    FieldUserSelectionMode[FieldUserSelectionMode["PeopleAndGroups"] = 1] = "PeopleAndGroups";
    FieldUserSelectionMode[FieldUserSelectionMode["PeopleOnly"] = 0] = "PeopleOnly";
})(FieldUserSelectionMode || (FieldUserSelectionMode = {}));
var ChoiceFieldFormatType;
(function (ChoiceFieldFormatType) {
    ChoiceFieldFormatType[ChoiceFieldFormatType["Dropdown"] = 0] = "Dropdown";
    ChoiceFieldFormatType[ChoiceFieldFormatType["RadioButtons"] = 1] = "RadioButtons";
})(ChoiceFieldFormatType || (ChoiceFieldFormatType = {}));
/**
 * Specifies the originating zone of a request received.
 */
var UrlZone;
(function (UrlZone) {
    /**
     * Specifies the default zone used for requests unless another zone is specified.
     */
    UrlZone[UrlZone["DefaultZone"] = 0] = "DefaultZone";
    /**
     * Specifies an intranet zone.
     */
    UrlZone[UrlZone["Intranet"] = 1] = "Intranet";
    /**
     * Specifies an Internet zone.
     */
    UrlZone[UrlZone["Internet"] = 2] = "Internet";
    /**
     * Specifies a custom zone.
     */
    UrlZone[UrlZone["Custom"] = 3] = "Custom";
    /**
     * Specifies an extranet zone.
     */
    UrlZone[UrlZone["Extranet"] = 4] = "Extranet";
})(UrlZone || (UrlZone = {}));

var SharePointQueryableSecurable = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SharePointQueryableSecurable, _super);
    function SharePointQueryableSecurable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(SharePointQueryableSecurable.prototype, "roleAssignments", {
        /**
         * Gets the set of role assignments for this item
         *
         */
        get: function () {
            return new RoleAssignments(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SharePointQueryableSecurable.prototype, "firstUniqueAncestorSecurableObject", {
        /**
         * Gets the closest securable up the security hierarchy whose permissions are applied to this list item
         *
         */
        get: function () {
            return new SharePointQueryableInstance(this, "FirstUniqueAncestorSecurableObject");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the effective permissions for the user supplied
     *
     * @param loginName The claims username for the user (ex: i:0#.f|membership|user@domain.com)
     */
    SharePointQueryableSecurable.prototype.getUserEffectivePermissions = function (loginName) {
        var q = this.clone(SharePointQueryable, "getUserEffectivePermissions(@user)");
        q.query.set("@user", "'" + encodeURIComponent(loginName) + "'");
        return q.get().then(function (r) {
            // handle verbose mode
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(r, "GetUserEffectivePermissions") ? r.GetUserEffectivePermissions : r;
        });
    };
    /**
     * Gets the effective permissions for the current user
     */
    SharePointQueryableSecurable.prototype.getCurrentUserEffectivePermissions = function () {
        var _this = this;
        // remove need to reference Web here, which created a circular build issue
        var w = new SharePointQueryableInstance("_api/web", "currentuser");
        return w.select("LoginName").get().then(function (user) {
            return _this.getUserEffectivePermissions(user.LoginName);
        });
    };
    /**
     * Breaks the security inheritance at this level optinally copying permissions and clearing subscopes
     *
     * @param copyRoleAssignments If true the permissions are copied from the current parent scope
     * @param clearSubscopes Optional. true to make all child securable objects inherit role assignments from the current object
     */
    SharePointQueryableSecurable.prototype.breakRoleInheritance = function (copyRoleAssignments, clearSubscopes) {
        if (copyRoleAssignments === void 0) { copyRoleAssignments = false; }
        if (clearSubscopes === void 0) { clearSubscopes = false; }
        return this.clone(SharePointQueryableSecurable, "breakroleinheritance(copyroleassignments=" + copyRoleAssignments + ", clearsubscopes=" + clearSubscopes + ")").postCore();
    };
    /**
     * Removes the local role assignments so that it re-inherit role assignments from the parent object.
     *
     */
    SharePointQueryableSecurable.prototype.resetRoleInheritance = function () {
        return this.clone(SharePointQueryableSecurable, "resetroleinheritance").postCore();
    };
    /**
     * Determines if a given user has the appropriate permissions
     *
     * @param loginName The user to check
     * @param permission The permission being checked
     */
    SharePointQueryableSecurable.prototype.userHasPermissions = function (loginName, permission) {
        var _this = this;
        return this.getUserEffectivePermissions(loginName).then(function (perms) {
            return _this.hasPermissions(perms, permission);
        });
    };
    /**
     * Determines if the current user has the requested permissions
     *
     * @param permission The permission we wish to check
     */
    SharePointQueryableSecurable.prototype.currentUserHasPermissions = function (permission) {
        var _this = this;
        return this.getCurrentUserEffectivePermissions().then(function (perms) {
            return _this.hasPermissions(perms, permission);
        });
    };
    /**
     * Taken from sp.js, checks the supplied permissions against the mask
     *
     * @param value The security principal's permissions on the given object
     * @param perm The permission checked against the value
     */
    /* tslint:disable:no-bitwise */
    SharePointQueryableSecurable.prototype.hasPermissions = function (value, perm) {
        if (!perm) {
            return true;
        }
        if (perm === PermissionKind.FullMask) {
            return (value.High & 32767) === 32767 && value.Low === 65535;
        }
        perm = perm - 1;
        var num = 1;
        if (perm >= 0 && perm < 32) {
            num = num << perm;
            return 0 !== (value.Low & num);
        }
        else if (perm >= 32 && perm < 64) {
            num = num << perm - 32;
            return 0 !== (value.High & num);
        }
        return false;
    };
    return SharePointQueryableSecurable;
}(SharePointQueryableInstance));

/**
 * Internal helper class used to augment classes to include sharing functionality
 */
var SharePointQueryableShareable = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SharePointQueryableShareable, _super);
    function SharePointQueryableShareable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a sharing link for the supplied
     *
     * @param kind The kind of link to share
     * @param expiration The optional expiration for this link
     */
    SharePointQueryableShareable.prototype.getShareLink = function (kind, expiration) {
        if (expiration === void 0) { expiration = null; }
        // date needs to be an ISO string or null
        var expString = expiration !== null ? expiration.toISOString() : null;
        // clone using the factory and send the request
        return this.clone(SharePointQueryableShareable, "shareLink").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                request: {
                    createLink: true,
                    emailData: null,
                    settings: {
                        expiration: expString,
                        linkKind: kind,
                    },
                },
            }),
        });
    };
    /**
     * Shares this instance with the supplied users
     *
     * @param loginNames Resolved login names to share
     * @param role The role
     * @param requireSignin True to require the user is authenticated, otherwise false
     * @param propagateAcl True to apply this share to all children
     * @param emailData If supplied an email will be sent with the indicated properties
     */
    SharePointQueryableShareable.prototype.shareWith = function (loginNames, role, requireSignin, propagateAcl, emailData) {
        var _this = this;
        if (requireSignin === void 0) { requireSignin = false; }
        if (propagateAcl === void 0) { propagateAcl = false; }
        // handle the multiple input types
        if (!Array.isArray(loginNames)) {
            loginNames = [loginNames];
        }
        var userStr = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(loginNames.map(function (login) { return { Key: login }; }));
        var roleFilter = role === SharingRole.Edit ? RoleType.Contributor : RoleType.Reader;
        // start by looking up the role definition id we need to set the roleValue
        // remove need to reference Web here, which created a circular build issue
        var w = new SharePointQueryableCollection("_api/web", "roledefinitions");
        return w.select("Id").filter("RoleTypeKind eq " + roleFilter).get().then(function (def) {
            if (!Array.isArray(def) || def.length < 1) {
                throw Error("Could not locate a role defintion with RoleTypeKind " + roleFilter);
            }
            var postBody = {
                includeAnonymousLinkInEmail: requireSignin,
                peoplePickerInput: userStr,
                propagateAcl: propagateAcl,
                roleValue: "role:" + def[0].Id,
                useSimplifiedRoles: true,
            };
            if (emailData !== undefined) {
                postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(postBody, {
                    emailBody: emailData.body,
                    emailSubject: emailData.subject !== undefined ? emailData.subject : "",
                    sendEmail: true,
                });
            }
            return _this.clone(SharePointQueryableShareable, "shareObject").postCore({
                body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(postBody),
            });
        });
    };
    /**
     * Shares an object based on the supplied options
     *
     * @param options The set of options to send to the ShareObject method
     * @param bypass If true any processing is skipped and the options are sent directly to the ShareObject method
     */
    SharePointQueryableShareable.prototype.shareObject = function (options, bypass) {
        var _this = this;
        if (bypass === void 0) { bypass = false; }
        if (bypass) {
            // if the bypass flag is set send the supplied parameters directly to the service
            return this.sendShareObjectRequest(options);
        }
        // extend our options with some defaults
        options = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(options, {
            group: null,
            includeAnonymousLinkInEmail: false,
            propagateAcl: false,
            useSimplifiedRoles: true,
        }, true);
        return this.getRoleValue(options.role, options.group).then(function (roleValue) {
            // handle the multiple input types
            if (!Array.isArray(options.loginNames)) {
                options.loginNames = [options.loginNames];
            }
            var userStr = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(options.loginNames.map(function (login) { return { Key: login }; }));
            var postBody = {
                peoplePickerInput: userStr,
                roleValue: roleValue,
                url: options.url,
            };
            if (options.emailData !== undefined && options.emailData !== null) {
                postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(postBody, {
                    emailBody: options.emailData.body,
                    emailSubject: options.emailData.subject !== undefined ? options.emailData.subject : "Shared with you.",
                    sendEmail: true,
                });
            }
            return _this.sendShareObjectRequest(postBody);
        });
    };
    /**
     * Calls the web's UnshareObject method
     *
     * @param url The url of the object to unshare
     */
    SharePointQueryableShareable.prototype.unshareObjectWeb = function (url) {
        return this.clone(SharePointQueryableShareable, "unshareObject").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                url: url,
            }),
        });
    };
    /**
     * Checks Permissions on the list of Users and returns back role the users have on the Item.
     *
     * @param recipients The array of Entities for which Permissions need to be checked.
     */
    SharePointQueryableShareable.prototype.checkPermissions = function (recipients) {
        return this.clone(SharePointQueryableShareable, "checkPermissions").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                recipients: recipients,
            }),
        });
    };
    /**
     * Get Sharing Information.
     *
     * @param request The SharingInformationRequest Object.
     */
    SharePointQueryableShareable.prototype.getSharingInformation = function (request) {
        if (request === void 0) { request = null; }
        return this.clone(SharePointQueryableShareable, "getSharingInformation").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                request: request,
            }),
        });
    };
    /**
     * Gets the sharing settings of an item.
     *
     * @param useSimplifiedRoles Determines whether to use simplified roles.
     */
    SharePointQueryableShareable.prototype.getObjectSharingSettings = function (useSimplifiedRoles) {
        if (useSimplifiedRoles === void 0) { useSimplifiedRoles = true; }
        return this.clone(SharePointQueryableShareable, "getObjectSharingSettings").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                useSimplifiedRoles: useSimplifiedRoles,
            }),
        });
    };
    /**
     * Unshares this object
     */
    SharePointQueryableShareable.prototype.unshareObject = function () {
        return this.clone(SharePointQueryableShareable, "unshareObject").postCore();
    };
    /**
     * Deletes a link by type
     *
     * @param kind Deletes a sharing link by the kind of link
     */
    SharePointQueryableShareable.prototype.deleteLinkByKind = function (kind) {
        return this.clone(SharePointQueryableShareable, "deleteLinkByKind").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ linkKind: kind }),
        });
    };
    /**
     * Removes the specified link to the item.
     *
     * @param kind The kind of link to be deleted.
     * @param shareId
     */
    SharePointQueryableShareable.prototype.unshareLink = function (kind, shareId) {
        if (shareId === void 0) { shareId = "00000000-0000-0000-0000-000000000000"; }
        return this.clone(SharePointQueryableShareable, "unshareLink").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ linkKind: kind, shareId: shareId }),
        });
    };
    /**
     * Calculates the roleValue string used in the sharing query
     *
     * @param role The Sharing Role
     * @param group The Group type
     */
    SharePointQueryableShareable.prototype.getRoleValue = function (role, group) {
        // we will give group precedence, because we had to make a choice
        if (group !== undefined && group !== null) {
            switch (group) {
                case RoleType.Contributor:
                    // remove need to reference Web here, which created a circular build issue
                    var memberGroup = new SharePointQueryableInstance("_api/web", "associatedmembergroup");
                    return memberGroup.select("Id").get().then(function (g) { return "group: " + g.Id; });
                case RoleType.Reader:
                case RoleType.Guest:
                    // remove need to reference Web here, which created a circular build issue
                    var visitorGroup = new SharePointQueryableInstance("_api/web", "associatedvisitorgroup");
                    return visitorGroup.select("Id").get().then(function (g) { return "group: " + g.Id; });
                default:
                    throw Error("Could not determine role value for supplied value. Contributor, Reader, and Guest are supported");
            }
        }
        else {
            var roleFilter = role === SharingRole.Edit ? RoleType.Contributor : RoleType.Reader;
            // remove need to reference Web here, which created a circular build issue
            var roleDefs = new SharePointQueryableCollection("_api/web", "roledefinitions");
            return roleDefs.select("Id").top(1).filter("RoleTypeKind eq " + roleFilter).get().then(function (def) {
                if (def.length < 1) {
                    throw Error("Could not locate associated role definition for supplied role. Edit and View are supported");
                }
                return "role: " + def[0].Id;
            });
        }
    };
    SharePointQueryableShareable.prototype.getShareObjectWeb = function (candidate) {
        return Promise.resolve(new SharePointQueryableInstance(extractWebUrl(candidate), "/_api/SP.Web.ShareObject"));
    };
    SharePointQueryableShareable.prototype.sendShareObjectRequest = function (options) {
        return this.getShareObjectWeb(this.toUrl()).then(function (web) {
            return web.expand("UsersWithAccessRequests", "GroupsSharedWith").as(SharePointQueryableShareable).postCore({
                body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(options),
            });
        });
    };
    return SharePointQueryableShareable;
}(SharePointQueryable));
var SharePointQueryableShareableWeb = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SharePointQueryableShareableWeb, _super);
    function SharePointQueryableShareableWeb() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Shares this web with the supplied users
     * @param loginNames The resolved login names to share
     * @param role The role to share this web
     * @param emailData Optional email data
     */
    SharePointQueryableShareableWeb.prototype.shareWith = function (loginNames, role, emailData) {
        var _this = this;
        if (role === void 0) { role = SharingRole.View; }
        var dependency = this.addBatchDependency();
        // remove need to reference Web here, which created a circular build issue
        var web = new SharePointQueryableInstance(extractWebUrl(this.toUrl()), "/_api/web/url");
        return web.get().then(function (url) {
            dependency();
            return _this.shareObject(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(url, "/_layouts/15/aclinv.aspx?forSharing=1&mbypass=1"), loginNames, role, emailData);
        });
    };
    /**
     * Provides direct access to the static web.ShareObject method
     *
     * @param url The url to share
     * @param loginNames Resolved loginnames string[] of a single login name string
     * @param roleValue Role value
     * @param emailData Optional email data
     * @param groupId Optional group id
     * @param propagateAcl
     * @param includeAnonymousLinkInEmail
     * @param useSimplifiedRoles
     */
    SharePointQueryableShareableWeb.prototype.shareObject = function (url, loginNames, role, emailData, group, propagateAcl, includeAnonymousLinkInEmail, useSimplifiedRoles) {
        if (propagateAcl === void 0) { propagateAcl = false; }
        if (includeAnonymousLinkInEmail === void 0) { includeAnonymousLinkInEmail = false; }
        if (useSimplifiedRoles === void 0) { useSimplifiedRoles = true; }
        return this.clone(SharePointQueryableShareable, null).shareObject({
            emailData: emailData,
            group: group,
            includeAnonymousLinkInEmail: includeAnonymousLinkInEmail,
            loginNames: loginNames,
            propagateAcl: propagateAcl,
            role: role,
            url: url,
            useSimplifiedRoles: useSimplifiedRoles,
        });
    };
    /**
     * Supplies a method to pass any set of arguments to ShareObject
     *
     * @param options The set of options to send to ShareObject
     */
    SharePointQueryableShareableWeb.prototype.shareObjectRaw = function (options) {
        return this.clone(SharePointQueryableShareable, null).shareObject(options, true);
    };
    /**
     * Unshares the object
     *
     * @param url The url of the object to stop sharing
     */
    SharePointQueryableShareableWeb.prototype.unshareObject = function (url) {
        return this.clone(SharePointQueryableShareable, null).unshareObjectWeb(url);
    };
    return SharePointQueryableShareableWeb;
}(SharePointQueryableSecurable));
var SharePointQueryableShareableItem = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SharePointQueryableShareableItem, _super);
    function SharePointQueryableShareableItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a link suitable for sharing for this item
     *
     * @param kind The type of link to share
     * @param expiration The optional expiration date
     */
    SharePointQueryableShareableItem.prototype.getShareLink = function (kind, expiration) {
        if (kind === void 0) { kind = SharingLinkKind.OrganizationView; }
        if (expiration === void 0) { expiration = null; }
        return this.clone(SharePointQueryableShareable, null).getShareLink(kind, expiration);
    };
    /**
     * Shares this item with one or more users
     *
     * @param loginNames string or string[] of resolved login names to which this item will be shared
     * @param role The role (View | Edit) applied to the share
     * @param emailData Optional, if inlucded an email will be sent. Note subject currently has no effect.
     */
    SharePointQueryableShareableItem.prototype.shareWith = function (loginNames, role, requireSignin, emailData) {
        if (role === void 0) { role = SharingRole.View; }
        if (requireSignin === void 0) { requireSignin = false; }
        return this.clone(SharePointQueryableShareable, null).shareWith(loginNames, role, requireSignin, false, emailData);
    };
    /**
     * Checks Permissions on the list of Users and returns back role the users have on the Item.
     *
     * @param recipients The array of Entities for which Permissions need to be checked.
     */
    SharePointQueryableShareableItem.prototype.checkSharingPermissions = function (recipients) {
        return this.clone(SharePointQueryableShareable, null).checkPermissions(recipients);
    };
    /**
     * Get Sharing Information.
     *
     * @param request The SharingInformationRequest Object.
     */
    SharePointQueryableShareableItem.prototype.getSharingInformation = function (request) {
        if (request === void 0) { request = null; }
        return this.clone(SharePointQueryableShareable, null).getSharingInformation(request);
    };
    /**
     * Gets the sharing settings of an item.
     *
     * @param useSimplifiedRoles Determines whether to use simplified roles.
     */
    SharePointQueryableShareableItem.prototype.getObjectSharingSettings = function (useSimplifiedRoles) {
        if (useSimplifiedRoles === void 0) { useSimplifiedRoles = true; }
        return this.clone(SharePointQueryableShareable, null).getObjectSharingSettings(useSimplifiedRoles);
    };
    /**
     * Unshare this item
     */
    SharePointQueryableShareableItem.prototype.unshare = function () {
        return this.clone(SharePointQueryableShareable, null).unshareObject();
    };
    /**
     * Deletes a sharing link by kind
     *
     * @param kind Deletes a sharing link by the kind of link
     */
    SharePointQueryableShareableItem.prototype.deleteSharingLinkByKind = function (kind) {
        return this.clone(SharePointQueryableShareable, null).deleteLinkByKind(kind);
    };
    /**
     * Removes the specified link to the item.
     *
     * @param kind The kind of link to be deleted.
     * @param shareId
     */
    SharePointQueryableShareableItem.prototype.unshareLink = function (kind, shareId) {
        return this.clone(SharePointQueryableShareable, null).unshareLink(kind, shareId);
    };
    return SharePointQueryableShareableItem;
}(SharePointQueryableSecurable));
var FileFolderShared = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(FileFolderShared, _super);
    function FileFolderShared() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a link suitable for sharing
     *
     * @param kind The kind of link to get
     * @param expiration Optional, an expiration for this link
     */
    FileFolderShared.prototype.getShareLink = function (kind, expiration) {
        if (kind === void 0) { kind = SharingLinkKind.OrganizationView; }
        if (expiration === void 0) { expiration = null; }
        var dependency = this.addBatchDependency();
        return this.getShareable().then(function (shareable) {
            dependency();
            return shareable.getShareLink(kind, expiration);
        });
    };
    /**
         * Checks Permissions on the list of Users and returns back role the users have on the Item.
         *
         * @param recipients The array of Entities for which Permissions need to be checked.
         */
    FileFolderShared.prototype.checkSharingPermissions = function (recipients) {
        var dependency = this.addBatchDependency();
        return this.getShareable().then(function (shareable) {
            dependency();
            return shareable.checkPermissions(recipients);
        });
    };
    /**
     * Get Sharing Information.
     *
     * @param request The SharingInformationRequest Object.
     */
    FileFolderShared.prototype.getSharingInformation = function (request) {
        if (request === void 0) { request = null; }
        var dependency = this.addBatchDependency();
        return this.getShareable().then(function (shareable) {
            dependency();
            return shareable.getSharingInformation(request);
        });
    };
    /**
     * Gets the sharing settings of an item.
     *
     * @param useSimplifiedRoles Determines whether to use simplified roles.
     */
    FileFolderShared.prototype.getObjectSharingSettings = function (useSimplifiedRoles) {
        if (useSimplifiedRoles === void 0) { useSimplifiedRoles = true; }
        var dependency = this.addBatchDependency();
        return this.getShareable().then(function (shareable) {
            dependency();
            return shareable.getObjectSharingSettings(useSimplifiedRoles);
        });
    };
    /**
     * Unshare this item
     */
    FileFolderShared.prototype.unshare = function () {
        var dependency = this.addBatchDependency();
        return this.getShareable().then(function (shareable) {
            dependency();
            return shareable.unshareObject();
        });
    };
    /**
     * Deletes a sharing link by the kind of link
     *
     * @param kind The kind of link to be deleted.
     */
    FileFolderShared.prototype.deleteSharingLinkByKind = function (kind) {
        var dependency = this.addBatchDependency();
        return this.getShareable().then(function (shareable) {
            dependency();
            return shareable.deleteLinkByKind(kind);
        });
    };
    /**
     * Removes the specified link to the item.
     *
     * @param kind The kind of link to be deleted.
     * @param shareId The share id to delete
     */
    FileFolderShared.prototype.unshareLink = function (kind, shareId) {
        var dependency = this.addBatchDependency();
        return this.getShareable().then(function (shareable) {
            dependency();
            return shareable.unshareLink(kind, shareId);
        });
    };
    /**
     * For files and folders we need to use the associated item end point
     */
    FileFolderShared.prototype.getShareable = function () {
        var _this = this;
        // sharing only works on the item end point, not the file one - so we create a folder instance with the item url internally
        return this.clone(SharePointQueryableShareableFile, "listItemAllFields", false).select("odata.id").get().then(function (d) {
            var shareable = new SharePointQueryableShareable(odataUrlFrom(d));
            // we need to handle batching
            if (_this.hasBatch) {
                shareable = shareable.inBatch(_this.batch);
            }
            return shareable;
        });
    };
    return FileFolderShared;
}(SharePointQueryableInstance));
var SharePointQueryableShareableFile = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SharePointQueryableShareableFile, _super);
    function SharePointQueryableShareableFile() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Shares this item with one or more users
     *
     * @param loginNames string or string[] of resolved login names to which this item will be shared
     * @param role The role (View | Edit) applied to the share
     * @param shareEverything Share everything in this folder, even items with unique permissions.
     * @param requireSignin If true the user must signin to view link, otherwise anyone with the link can access the resource
     * @param emailData Optional, if inlucded an email will be sent. Note subject currently has no effect.
     */
    SharePointQueryableShareableFile.prototype.shareWith = function (loginNames, role, requireSignin, emailData) {
        if (role === void 0) { role = SharingRole.View; }
        if (requireSignin === void 0) { requireSignin = false; }
        var dependency = this.addBatchDependency();
        return this.getShareable().then(function (shareable) {
            dependency();
            return shareable.shareWith(loginNames, role, requireSignin, false, emailData);
        });
    };
    return SharePointQueryableShareableFile;
}(FileFolderShared));
var SharePointQueryableShareableFolder = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SharePointQueryableShareableFolder, _super);
    function SharePointQueryableShareableFolder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Shares this item with one or more users
     *
     * @param loginNames string or string[] of resolved login names to which this item will be shared
     * @param role The role (View | Edit) applied to the share
     * @param shareEverything Share everything in this folder, even items with unique permissions.
     * @param requireSignin If true the user must signin to view link, otherwise anyone with the link can access the resource
     * @param emailData Optional, if inlucded an email will be sent. Note subject currently has no effect.
     */
    SharePointQueryableShareableFolder.prototype.shareWith = function (loginNames, role, requireSignin, shareEverything, emailData) {
        if (role === void 0) { role = SharingRole.View; }
        if (requireSignin === void 0) { requireSignin = false; }
        if (shareEverything === void 0) { shareEverything = false; }
        var dependency = this.addBatchDependency();
        return this.getShareable().then(function (shareable) {
            dependency();
            return shareable.shareWith(loginNames, role, requireSignin, shareEverything, emailData);
        });
    };
    return SharePointQueryableShareableFolder;
}(FileFolderShared));

var LimitedWebPartManager = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(LimitedWebPartManager, _super);
    function LimitedWebPartManager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(LimitedWebPartManager.prototype, "webparts", {
        /**
         * Gets the set of web part definitions contained by this web part manager
         *
         */
        get: function () {
            return new WebPartDefinitions(this, "webparts");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Exports a webpart definition
     *
     * @param id the GUID id of the definition to export
     */
    LimitedWebPartManager.prototype.export = function (id) {
        return this.clone(LimitedWebPartManager, "ExportWebPart").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ webPartId: id }),
        });
    };
    /**
     * Imports a webpart
     *
     * @param xml webpart definition which must be valid XML in the .dwp or .webpart format
     */
    LimitedWebPartManager.prototype.import = function (xml) {
        return this.clone(LimitedWebPartManager, "ImportWebPart").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ webPartXml: xml }),
        });
    };
    return LimitedWebPartManager;
}(SharePointQueryable));
var WebPartDefinitions = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(WebPartDefinitions, _super);
    function WebPartDefinitions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a web part definition from the collection by id
     *
     * @param id The storage ID of the SPWebPartDefinition to retrieve
     */
    WebPartDefinitions.prototype.getById = function (id) {
        return new WebPartDefinition(this, "getbyid('" + id + "')");
    };
    /**
     * Gets a web part definition from the collection by storage id
     *
     * @param id The WebPart.ID of the SPWebPartDefinition to retrieve
     */
    WebPartDefinitions.prototype.getByControlId = function (id) {
        return new WebPartDefinition(this, "getByControlId('" + id + "')");
    };
    return WebPartDefinitions;
}(SharePointQueryableCollection));
var WebPartDefinition = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(WebPartDefinition, _super);
    function WebPartDefinition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(WebPartDefinition.prototype, "webpart", {
        /**
         * Gets the webpart information associated with this definition
         */
        get: function () {
            return new WebPart(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Saves changes to the Web Part made using other properties and methods on the SPWebPartDefinition object
     */
    WebPartDefinition.prototype.saveChanges = function () {
        return this.clone(WebPartDefinition, "SaveWebPartChanges").postCore();
    };
    /**
     * Moves the Web Part to a different location on a Web Part Page
     *
     * @param zoneId The ID of the Web Part Zone to which to move the Web Part
     * @param zoneIndex A Web Part zone index that specifies the position at which the Web Part is to be moved within the destination Web Part zone
     */
    WebPartDefinition.prototype.moveTo = function (zoneId, zoneIndex) {
        return this.clone(WebPartDefinition, "MoveWebPartTo(zoneID='" + zoneId + "', zoneIndex=" + zoneIndex + ")").postCore();
    };
    /**
     * Closes the Web Part. If the Web Part is already closed, this method does nothing
     */
    WebPartDefinition.prototype.close = function () {
        return this.clone(WebPartDefinition, "CloseWebPart").postCore();
    };
    /**
     * Opens the Web Part. If the Web Part is already closed, this method does nothing
     */
    WebPartDefinition.prototype.open = function () {
        return this.clone(WebPartDefinition, "OpenWebPart").postCore();
    };
    /**
     * Removes a webpart from a page, all settings will be lost
     */
    WebPartDefinition.prototype.delete = function () {
        return this.clone(WebPartDefinition, "DeleteWebPart").postCore();
    };
    return WebPartDefinition;
}(SharePointQueryableInstance));
var WebPart = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(WebPart, _super);
    function WebPart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebPart = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("webpart")
    ], WebPart);
    return WebPart;
}(SharePointQueryableInstance));

/**
 * Describes a collection of Folder objects
 *
 */
var Folders = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Folders, _super);
    function Folders() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Folders_1 = Folders;
    /**
     * Gets a folder by folder name
     *
     */
    Folders.prototype.getByName = function (name) {
        var f = new Folder(this);
        f.concat("('" + name + "')");
        return f;
    };
    /**
     * Adds a new folder to the current folder (relative) or any folder (absolute)
     *
     * @param url The relative or absolute url where the new folder will be created. Urls starting with a forward slash are absolute.
     * @returns The new Folder and the raw response.
     */
    Folders.prototype.add = function (url) {
        var _this = this;
        return this.clone(Folders_1, "add('" + url + "')").postCore().then(function (response) {
            return {
                data: response,
                folder: _this.getByName(url),
            };
        });
    };
    var Folders_1;
    Folders = Folders_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("folders")
    ], Folders);
    return Folders;
}(SharePointQueryableCollection));
/**
 * Describes a single Folder instance
 *
 */
var Folder = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Folder, _super);
    function Folder() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.update = _this._update("SP.Folder", function (data) { return ({ data: data, folder: _this }); });
        return _this;
    }
    Object.defineProperty(Folder.prototype, "contentTypeOrder", {
        /**
         * Specifies the sequence in which content types are displayed.
         *
         */
        get: function () {
            return new SharePointQueryableCollection(this, "contentTypeOrder");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "files", {
        /**
         * Gets this folder's files
         *
         */
        get: function () {
            return new Files(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "folders", {
        /**
         * Gets this folder's sub folders
         *
         */
        get: function () {
            return new Folders(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "listItemAllFields", {
        /**
         * Gets this folder's list item field values
         *
         */
        get: function () {
            return new SharePointQueryableInstance(this, "listItemAllFields");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "parentFolder", {
        /**
         * Gets the parent folder, if available
         *
         */
        get: function () {
            return new Folder(this, "parentFolder");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "properties", {
        /**
         * Gets this folder's properties
         *
         */
        get: function () {
            return new SharePointQueryableInstance(this, "properties");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "serverRelativeUrl", {
        /**
         * Gets this folder's server relative url
         *
         */
        get: function () {
            return new SharePointQueryable(this, "serverRelativeUrl");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Folder.prototype, "uniqueContentTypeOrder", {
        /**
         * Gets a value that specifies the content type order.
         *
         */
        get: function () {
            return new SharePointQueryableCollection(this, "uniqueContentTypeOrder");
        },
        enumerable: true,
        configurable: true
    });
    /**
    * Delete this folder
    *
    * @param eTag Value used in the IF-Match header, by default "*"
    */
    Folder.prototype.delete = function (eTag) {
        if (eTag === void 0) { eTag = "*"; }
        return this.clone(Folder, null).postCore({
            headers: {
                "IF-Match": eTag,
                "X-HTTP-Method": "DELETE",
            },
        });
    };
    /**
     * Moves the folder to the Recycle Bin and returns the identifier of the new Recycle Bin item.
     */
    Folder.prototype.recycle = function () {
        return this.clone(Folder, "recycle").postCore();
    };
    /**
     * Gets the associated list item for this folder, loading the default properties
     */
    Folder.prototype.getItem = function () {
        var selects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            selects[_i] = arguments[_i];
        }
        var q = this.listItemAllFields;
        return q.select.apply(q, selects).get().then(function (d) {
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(new Item(odataUrlFrom(d)), d);
        });
    };
    /**
     * Moves a folder to destination path
     *
     * @param destUrl Absolute or relative URL of the destination path
     */
    Folder.prototype.moveTo = function (destUrl) {
        var _this = this;
        return this.select("ServerRelativeUrl").get().then(function (_a) {
            var srcUrl = _a.ServerRelativeUrl;
            var client = new SPHttpClient();
            var webBaseUrl = _this.toUrl().split("/_api")[0];
            var hostUrl = webBaseUrl.replace("://", "___").split("/")[0].replace("___", "://");
            var methodUrl = webBaseUrl + "/_api/SP.MoveCopyUtil.MoveFolder()";
            return client.post(methodUrl, {
                body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                    destUrl: destUrl.indexOf("http") === 0 ? destUrl : "" + hostUrl + destUrl,
                    srcUrl: "" + hostUrl + srcUrl,
                }),
            }).then(function (r) { return r.json(); });
        });
    };
    return Folder;
}(SharePointQueryableShareableFolder));

/**
 * Describes a collection of content types
 *
 */
var ContentTypes = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ContentTypes, _super);
    function ContentTypes() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ContentTypes_1 = ContentTypes;
    /**
     * Adds an existing contenttype to a content type collection
     *
     * @param contentTypeId in the following format, for example: 0x010102
     */
    ContentTypes.prototype.addAvailableContentType = function (contentTypeId) {
        var _this = this;
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            "contentTypeId": contentTypeId,
        });
        return this.clone(ContentTypes_1, "addAvailableContentType").postCore({ body: postBody }).then(function (data) {
            return {
                contentType: _this.getById(data.id),
                data: data,
            };
        });
    };
    /**
     * Gets a ContentType by content type id
     */
    ContentTypes.prototype.getById = function (id) {
        var ct = new ContentType(this);
        ct.concat("('" + id + "')");
        return ct;
    };
    /**
     * Adds a new content type to the collection
     *
     * @param id The desired content type id for the new content type (also determines the parent content type)
     * @param name The name of the content type
     * @param description The description of the content type
     * @param group The group in which to add the content type
     * @param additionalSettings Any additional settings to provide when creating the content type
     *
     */
    ContentTypes.prototype.add = function (id, name, description, group, additionalSettings) {
        var _this = this;
        if (description === void 0) { description = ""; }
        if (group === void 0) { group = "Custom Content Types"; }
        if (additionalSettings === void 0) { additionalSettings = {}; }
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object.assign(metadata("SP.ContentType"), {
            "Description": description,
            "Group": group,
            "Id": { "StringValue": id },
            "Name": name,
        }, additionalSettings));
        return this.postCore({ body: postBody }).then(function (data) {
            return { contentType: _this.getById(data.id), data: data };
        });
    };
    var ContentTypes_1;
    ContentTypes = ContentTypes_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("contenttypes")
    ], ContentTypes);
    return ContentTypes;
}(SharePointQueryableCollection));
/**
 * Describes a single ContentType instance
 *
 */
var ContentType = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ContentType, _super);
    function ContentType() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Delete this content type
         */
        _this.delete = _this._delete;
        return _this;
    }
    Object.defineProperty(ContentType.prototype, "fieldLinks", {
        /**
         * Gets the column (also known as field) references in the content type.
        */
        get: function () {
            return new FieldLinks(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContentType.prototype, "fields", {
        /**
         * Gets a value that specifies the collection of fields for the content type.
         */
        get: function () {
            return new SharePointQueryableCollection(this, "fields");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContentType.prototype, "parent", {
        /**
         * Gets the parent content type of the content type.
         */
        get: function () {
            return new ContentType(this, "parent");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContentType.prototype, "workflowAssociations", {
        /**
         * Gets a value that specifies the collection of workflow associations for the content type.
         */
        get: function () {
            return new SharePointQueryableCollection(this, "workflowAssociations");
        },
        enumerable: true,
        configurable: true
    });
    return ContentType;
}(SharePointQueryableInstance));
/**
 * Represents a collection of field link instances
 */
var FieldLinks = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(FieldLinks, _super);
    function FieldLinks() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a FieldLink by GUID id
     *
     * @param id The GUID id of the field link
     */
    FieldLinks.prototype.getById = function (id) {
        var fl = new FieldLink(this);
        fl.concat("(guid'" + id + "')");
        return fl;
    };
    FieldLinks = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("fieldlinks")
    ], FieldLinks);
    return FieldLinks;
}(SharePointQueryableCollection));
/**
 * Represents a field link instance
 */
var FieldLink = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(FieldLink, _super);
    function FieldLink() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FieldLink;
}(SharePointQueryableInstance));

/**
 * Describes a collection of Item objects
 *
 */
var AttachmentFiles = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(AttachmentFiles, _super);
    function AttachmentFiles() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AttachmentFiles_1 = AttachmentFiles;
    /**
     * Gets a Attachment File by filename
     *
     * @param name The name of the file, including extension.
     */
    AttachmentFiles.prototype.getByName = function (name) {
        var f = new AttachmentFile(this);
        f.concat("('" + name + "')");
        return f;
    };
    /**
     * Adds a new attachment to the collection. Not supported for batching.
     *
     * @param name The name of the file, including extension.
     * @param content The Base64 file content.
     */
    AttachmentFiles.prototype.add = function (name, content) {
        var _this = this;
        return this.clone(AttachmentFiles_1, "add(FileName='" + name + "')", false).postCore({
            body: content,
        }).then(function (response) {
            return {
                data: response,
                file: _this.getByName(name),
            };
        });
    };
    /**
     * Adds multiple new attachment to the collection. Not supported for batching.
     *
     * @files name The collection of files to add
     */
    AttachmentFiles.prototype.addMultiple = function (files) {
        var _this = this;
        // add the files in series so we don't get update conflicts
        return files.reduce(function (chain, file) { return chain.then(function () { return _this.clone(AttachmentFiles_1, "add(FileName='" + file.name + "')", false).postCore({
            body: file.content,
        }); }); }, Promise.resolve());
    };
    /**
     * Delete multiple attachments from the collection. Not supported for batching.
     *
     * @files name The collection of files to delete
     */
    AttachmentFiles.prototype.deleteMultiple = function () {
        var _this = this;
        var files = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            files[_i] = arguments[_i];
        }
        return files.reduce(function (chain, file) { return chain.then(function () { return _this.getByName(file).delete(); }); }, Promise.resolve());
    };
    var AttachmentFiles_1;
    AttachmentFiles = AttachmentFiles_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("AttachmentFiles")
    ], AttachmentFiles);
    return AttachmentFiles;
}(SharePointQueryableCollection));
/**
 * Describes a single attachment file instance
 *
 */
var AttachmentFile = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(AttachmentFile, _super);
    function AttachmentFile() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.delete = _this._deleteWithETag;
        return _this;
    }
    /**
     * Gets the contents of the file as text
     *
     */
    AttachmentFile.prototype.getText = function () {
        return this.getParsed(new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["TextParser"]());
    };
    /**
     * Gets the contents of the file as a blob, does not work in Node.js
     *
     */
    AttachmentFile.prototype.getBlob = function () {
        return this.getParsed(new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["BlobParser"]());
    };
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js
     */
    AttachmentFile.prototype.getBuffer = function () {
        return this.getParsed(new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["BufferParser"]());
    };
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js
     */
    AttachmentFile.prototype.getJSON = function () {
        return this.getParsed(new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["JSONParser"]());
    };
    /**
     * Sets the content of a file. Not supported for batching
     *
     * @param content The value to set for the file contents
     */
    AttachmentFile.prototype.setContent = function (content) {
        var _this = this;
        return this.clone(AttachmentFile, "$value", false).postCore({
            body: content,
            headers: {
                "X-HTTP-Method": "PUT",
            },
        }).then(function (_) { return new AttachmentFile(_this); });
    };
    // /**
    //  * Delete this attachment file
    //  *
    //  * @param eTag Value used in the IF-Match header, by default "*"
    //  */
    // public delete(eTag = "*"): Promise<void> {
    //     return this.postCore({
    //         headers: {
    //             "IF-Match": eTag,
    //             "X-HTTP-Method": "DELETE",
    //         },
    //     });
    // }
    AttachmentFile.prototype.getParsed = function (parser) {
        return this.clone(AttachmentFile, "$value", false).get(parser);
    };
    return AttachmentFile;
}(SharePointQueryableInstance));

/**
 * Describes the views available in the current context
 *
 */
var Views = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Views, _super);
    function Views() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Views_1 = Views;
    /**
     * Gets a view by guid id
     *
     * @param id The GUID id of the view
     */
    Views.prototype.getById = function (id) {
        var v = new View(this);
        v.concat("('" + id + "')");
        return v;
    };
    /**
     * Gets a view by title (case-sensitive)
     *
     * @param title The case-sensitive title of the view
     */
    Views.prototype.getByTitle = function (title) {
        return new View(this, "getByTitle('" + title + "')");
    };
    /**
     * Adds a new view to the collection
     *
     * @param title The new views's title
     * @param personalView True if this is a personal view, otherwise false, default = false
     * @param additionalSettings Will be passed as part of the view creation body
     */
    Views.prototype.add = function (title, personalView, additionalSettings) {
        var _this = this;
        if (personalView === void 0) { personalView = false; }
        if (additionalSettings === void 0) { additionalSettings = {}; }
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object.assign(metadata("SP.View"), {
            "PersonalView": personalView,
            "Title": title,
        }, additionalSettings));
        return this.clone(Views_1, null).postCore({ body: postBody }).then(function (data) {
            return {
                data: data,
                view: _this.getById(data.Id),
            };
        });
    };
    var Views_1;
    Views = Views_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("views")
    ], Views);
    return Views;
}(SharePointQueryableCollection));
/**
 * Describes a single View instance
 *
 */
var View = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(View, _super);
    function View() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Updates this view intance with the supplied properties
         *
         * @param properties A plain object hash of values to update for the view
         */
        _this.update = _this._update("SP.View", function (data) { return ({ data: data, view: _this }); });
        /**
         * Delete this view
         *
         */
        _this.delete = _this._delete;
        return _this;
    }
    Object.defineProperty(View.prototype, "fields", {
        get: function () {
            return new ViewFields(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the list view as HTML.
     *
     */
    View.prototype.renderAsHtml = function () {
        return this.clone(SharePointQueryable, "renderashtml").get();
    };
    return View;
}(SharePointQueryableInstance));
var ViewFields = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ViewFields, _super);
    function ViewFields() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ViewFields_1 = ViewFields;
    /**
     * Gets a value that specifies the XML schema that represents the collection.
     */
    ViewFields.prototype.getSchemaXml = function () {
        return this.clone(SharePointQueryable, "schemaxml").get();
    };
    /**
     * Adds the field with the specified field internal name or display name to the collection.
     *
     * @param fieldTitleOrInternalName The case-sensitive internal name or display name of the field to add.
     */
    ViewFields.prototype.add = function (fieldTitleOrInternalName) {
        return this.clone(ViewFields_1, "addviewfield('" + fieldTitleOrInternalName + "')").postCore();
    };
    /**
     * Moves the field with the specified field internal name to the specified position in the collection.
     *
     * @param fieldInternalName The case-sensitive internal name of the field to move.
     * @param index The zero-based index of the new position for the field.
     */
    ViewFields.prototype.move = function (fieldInternalName, index) {
        return this.clone(ViewFields_1, "moveviewfieldto").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ "field": fieldInternalName, "index": index }),
        });
    };
    /**
     * Removes all the fields from the collection.
     */
    ViewFields.prototype.removeAll = function () {
        return this.clone(ViewFields_1, "removeallviewfields").postCore();
    };
    /**
     * Removes the field with the specified field internal name from the collection.
     *
     * @param fieldInternalName The case-sensitive internal name of the field to remove from the view.
     */
    ViewFields.prototype.remove = function (fieldInternalName) {
        return this.clone(ViewFields_1, "removeviewfield('" + fieldInternalName + "')").postCore();
    };
    var ViewFields_1;
    ViewFields = ViewFields_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("viewfields")
    ], ViewFields);
    return ViewFields;
}(SharePointQueryableCollection));

/**
 * Describes a collection of Field objects
 *
 */
var Fields = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Fields, _super);
    function Fields() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Fields_1 = Fields;
    /**
     * Gets a field from the collection by id
     *
     * @param id The Id of the list
     */
    Fields.prototype.getById = function (id) {
        var f = new Field(this);
        f.concat("('" + id + "')");
        return f;
    };
    /**
     * Gets a field from the collection by title
     *
     * @param title The case-sensitive title of the field
     */
    Fields.prototype.getByTitle = function (title) {
        return new Field(this, "getByTitle('" + title + "')");
    };
    /**
     * Gets a field from the collection by using internal name or title
     *
     * @param name The case-sensitive internal name or title of the field
     */
    Fields.prototype.getByInternalNameOrTitle = function (name) {
        return new Field(this, "getByInternalNameOrTitle('" + name + "')");
    };
    /**
     * Creates a field based on the specified schema
     */
    Fields.prototype.createFieldAsXml = function (xml) {
        var _this = this;
        var info;
        if (typeof xml === "string") {
            info = { SchemaXml: xml };
        }
        else {
            info = xml;
        }
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            "parameters": Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.XmlSchemaFieldCreationInformation"), info),
        });
        return this.clone(Fields_1, "createfieldasxml").postCore({ body: postBody }).then(function (data) {
            return {
                data: data,
                field: _this.getById(data.Id),
            };
        });
    };
    /**
     * Adds a new field to the collection
     *
     * @param title The new field's title
     * @param fieldType The new field's type (ex: SP.FieldText)
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     */
    Fields.prototype.add = function (title, fieldType, properties) {
        var _this = this;
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object.assign(metadata(fieldType), {
            "Title": title,
        }, properties));
        return this.clone(Fields_1, null).postCore({ body: postBody }).then(function (data) {
            return {
                data: data,
                field: _this.getById(data.Id),
            };
        });
    };
    /**
     * Adds a new SP.FieldText to the collection
     *
     * @param title The field title
     * @param maxLength The maximum number of characters allowed in the value of the field.
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     */
    Fields.prototype.addText = function (title, maxLength, properties) {
        if (maxLength === void 0) { maxLength = 255; }
        var props = {
            FieldTypeKind: 2,
            MaxLength: maxLength,
        };
        return this.add(title, "SP.FieldText", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /**
     * Adds a new SP.FieldCalculated to the collection
     *
     * @param title The field title.
     * @param formula The formula for the field.
     * @param dateFormat The date and time format that is displayed in the field.
     * @param outputType Specifies the output format for the field. Represents a FieldType value.
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     */
    Fields.prototype.addCalculated = function (title, formula, dateFormat, outputType, properties) {
        if (outputType === void 0) { outputType = FieldTypes.Text; }
        var props = {
            DateFormat: dateFormat,
            FieldTypeKind: 17,
            Formula: formula,
            OutputType: outputType,
        };
        return this.add(title, "SP.FieldCalculated", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /**
     * Adds a new SP.FieldDateTime to the collection
     *
     * @param title The field title
     * @param displayFormat The format of the date and time that is displayed in the field.
     * @param calendarType Specifies the calendar type of the field.
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     */
    Fields.prototype.addDateTime = function (title, displayFormat, calendarType, friendlyDisplayFormat, properties) {
        if (displayFormat === void 0) { displayFormat = DateTimeFieldFormatType.DateOnly; }
        if (calendarType === void 0) { calendarType = CalendarType.Gregorian; }
        if (friendlyDisplayFormat === void 0) { friendlyDisplayFormat = 0; }
        var props = {
            DateTimeCalendarType: calendarType,
            DisplayFormat: displayFormat,
            FieldTypeKind: 4,
            FriendlyDisplayFormat: friendlyDisplayFormat,
        };
        return this.add(title, "SP.FieldDateTime", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /**
     * Adds a new SP.FieldNumber to the collection
     *
     * @param title The field title
     * @param minValue The field's minimum value
     * @param maxValue The field's maximum value
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     */
    Fields.prototype.addNumber = function (title, minValue, maxValue, properties) {
        var props = { FieldTypeKind: 9 };
        if (minValue !== undefined) {
            props = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ MinimumValue: minValue }, props);
        }
        if (maxValue !== undefined) {
            props = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ MaximumValue: maxValue }, props);
        }
        return this.add(title, "SP.FieldNumber", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /**
     * Adds a new SP.FieldCurrency to the collection
     *
     * @param title The field title
     * @param minValue The field's minimum value
     * @param maxValue The field's maximum value
     * @param currencyLocalId Specifies the language code identifier (LCID) used to format the value of the field
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     */
    Fields.prototype.addCurrency = function (title, minValue, maxValue, currencyLocalId, properties) {
        if (currencyLocalId === void 0) { currencyLocalId = 1033; }
        var props = {
            CurrencyLocaleId: currencyLocalId,
            FieldTypeKind: 10,
        };
        if (minValue !== undefined) {
            props = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ MinimumValue: minValue }, props);
        }
        if (maxValue !== undefined) {
            props = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ MaximumValue: maxValue }, props);
        }
        return this.add(title, "SP.FieldCurrency", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /**
     * Adds a new SP.FieldMultiLineText to the collection
     *
     * @param title The field title
     * @param numberOfLines Specifies the number of lines of text to display for the field.
     * @param richText Specifies whether the field supports rich formatting.
     * @param restrictedMode Specifies whether the field supports a subset of rich formatting.
     * @param appendOnly Specifies whether all changes to the value of the field are displayed in list forms.
     * @param allowHyperlink Specifies whether a hyperlink is allowed as a value of the field.
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     *
     */
    Fields.prototype.addMultilineText = function (title, numberOfLines, richText, restrictedMode, appendOnly, allowHyperlink, properties) {
        if (numberOfLines === void 0) { numberOfLines = 6; }
        if (richText === void 0) { richText = true; }
        if (restrictedMode === void 0) { restrictedMode = false; }
        if (appendOnly === void 0) { appendOnly = false; }
        if (allowHyperlink === void 0) { allowHyperlink = true; }
        var props = {
            AllowHyperlink: allowHyperlink,
            AppendOnly: appendOnly,
            FieldTypeKind: 3,
            NumberOfLines: numberOfLines,
            RestrictedMode: restrictedMode,
            RichText: richText,
        };
        return this.add(title, "SP.FieldMultiLineText", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /**
     * Adds a new SP.FieldUrl to the collection
     *
     * @param title The field title
     */
    Fields.prototype.addUrl = function (title, displayFormat, properties) {
        if (displayFormat === void 0) { displayFormat = UrlFieldFormatType.Hyperlink; }
        var props = {
            DisplayFormat: displayFormat,
            FieldTypeKind: 11,
        };
        return this.add(title, "SP.FieldUrl", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /** Adds a user field to the colleciton
    *
    * @param title The new field's title
    * @param selectionMode The selection mode of the field
    * @param selectionGroup Value that specifies the identifier of the SharePoint group whose members can be selected as values of the field
    * @param properties
    */
    Fields.prototype.addUser = function (title, selectionMode, properties) {
        var props = {
            FieldTypeKind: 20,
            SelectionMode: selectionMode,
        };
        return this.add(title, "SP.FieldUser", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /**
     * Adds a SP.FieldLookup to the collection
     *
     * @param title The new field's title
     * @param lookupListId The guid id of the list where the source of the lookup is found
     * @param lookupFieldName The internal name of the field in the source list
     * @param properties Set of additional properties to set on the new field
     */
    Fields.prototype.addLookup = function (title, lookupListId, lookupFieldName, properties) {
        var _this = this;
        var props = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({
            FieldTypeKind: 7,
            LookupFieldName: lookupFieldName,
            LookupListId: lookupListId,
            Title: title,
        }, properties);
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            "parameters": Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.FieldCreationInformation"), props),
        });
        return this.clone(Fields_1, "addfield").postCore({ body: postBody }).then(function (data) {
            return {
                data: data,
                field: _this.getById(data.Id),
            };
        });
    };
    /**
     * Adds a new SP.FieldChoice to the collection
     *
     * @param title The field title.
     * @param choices The choices for the field.
     * @param format The display format of the available options for the field.
     * @param fillIn Specifies whether the field allows fill-in values.
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     */
    Fields.prototype.addChoice = function (title, choices, format, fillIn, properties) {
        if (format === void 0) { format = ChoiceFieldFormatType.Dropdown; }
        var props = {
            Choices: {
                results: choices,
            },
            EditFormat: format,
            FieldTypeKind: 6,
            FillInChoice: fillIn,
        };
        return this.add(title, "SP.FieldChoice", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /**
     * Adds a new SP.FieldMultiChoice to the collection
     *
     * @param title The field title.
     * @param choices The choices for the field.
     * @param fillIn Specifies whether the field allows fill-in values.
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     */
    Fields.prototype.addMultiChoice = function (title, choices, fillIn, properties) {
        var props = {
            Choices: {
                results: choices,
            },
            FieldTypeKind: 15,
            FillInChoice: fillIn,
        };
        return this.add(title, "SP.FieldMultiChoice", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    /**
     * Adds a new SP.FieldBoolean to the collection
     *
     * @param title The field title.
     * @param properties Differ by type of field being created (see: https://msdn.microsoft.com/en-us/library/office/dn600182.aspx)
     */
    Fields.prototype.addBoolean = function (title, properties) {
        var props = {
            FieldTypeKind: 8,
        };
        return this.add(title, "SP.Field", Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(props, properties));
    };
    var Fields_1;
    Fields = Fields_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("fields")
    ], Fields);
    return Fields;
}(SharePointQueryableCollection));
/**
 * Describes a single of Field instance
 *
 */
var Field = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Field, _super);
    function Field() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Delete this fields
         *
         */
        _this.delete = _this._delete;
        return _this;
    }
    /**
     * Updates this field intance with the supplied properties
     *
     * @param properties A plain object hash of values to update for the list
     * @param fieldType The type value, required to update child field type properties
     */
    Field.prototype.update = function (properties, fieldType) {
        var _this = this;
        if (fieldType === void 0) { fieldType = "SP.Field"; }
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata(fieldType), properties));
        return this.postCore({
            body: postBody,
            headers: {
                "X-HTTP-Method": "MERGE",
            },
        }).then(function (data) {
            return {
                data: data,
                field: _this,
            };
        });
    };
    /**
     * Sets the value of the ShowInDisplayForm property for this field.
     */
    Field.prototype.setShowInDisplayForm = function (show) {
        return this.clone(Field, "setshowindisplayform(" + show + ")").postCore();
    };
    /**
     * Sets the value of the ShowInEditForm property for this field.
     */
    Field.prototype.setShowInEditForm = function (show) {
        return this.clone(Field, "setshowineditform(" + show + ")").postCore();
    };
    /**
     * Sets the value of the ShowInNewForm property for this field.
     */
    Field.prototype.setShowInNewForm = function (show) {
        return this.clone(Field, "setshowinnewform(" + show + ")").postCore();
    };
    return Field;
}(SharePointQueryableInstance));

/**
 * Describes a collection of Field objects
 *
 */
var Forms = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Forms, _super);
    function Forms() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a form by id
     *
     * @param id The guid id of the item to retrieve
     */
    Forms.prototype.getById = function (id) {
        var i = new Form(this);
        i.concat("('" + id + "')");
        return i;
    };
    Forms = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("forms")
    ], Forms);
    return Forms;
}(SharePointQueryableCollection));
/**
 * Describes a single of Form instance
 *
 */
var Form = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Form, _super);
    function Form() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Form;
}(SharePointQueryableInstance));

/**
 * Describes a collection of webhook subscriptions
 *
 */
var Subscriptions = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Subscriptions, _super);
    function Subscriptions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns all the webhook subscriptions or the specified webhook subscription
     *
     * @param subscriptionId The id of a specific webhook subscription to retrieve, omit to retrieve all the webhook subscriptions
     */
    Subscriptions.prototype.getById = function (subscriptionId) {
        var s = new Subscription(this);
        s.concat("('" + subscriptionId + "')");
        return s;
    };
    /**
     * Creates a new webhook subscription
     *
     * @param notificationUrl The url to receive the notifications
     * @param expirationDate The date and time to expire the subscription in the form YYYY-MM-ddTHH:mm:ss+00:00 (maximum of 6 months)
     * @param clientState A client specific string (defaults to pnp-js-core-subscription when omitted)
     */
    Subscriptions.prototype.add = function (notificationUrl, expirationDate, clientState) {
        var _this = this;
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            "clientState": clientState || "pnp-js-core-subscription",
            "expirationDateTime": expirationDate,
            "notificationUrl": notificationUrl,
            "resource": this.toUrl(),
        });
        return this.postCore({ body: postBody, headers: { "Content-Type": "application/json" } }).then(function (result) {
            return { data: result, subscription: _this.getById(result.id) };
        });
    };
    Subscriptions = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("subscriptions")
    ], Subscriptions);
    return Subscriptions;
}(SharePointQueryableCollection));
/**
 * Describes a single webhook subscription instance
 *
 */
var Subscription = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Subscription, _super);
    function Subscription() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Renews this webhook subscription
     *
     * @param expirationDate The date and time to expire the subscription in the form YYYY-MM-ddTHH:mm:ss+00:00 (maximum of 6 months)
     */
    Subscription.prototype.update = function (expirationDate) {
        var _this = this;
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            "expirationDateTime": expirationDate,
        });
        return this.patchCore({ body: postBody, headers: { "Content-Type": "application/json" } }).then(function (data) {
            return { data: data, subscription: _this };
        });
    };
    /**
     * Removes this webhook subscription
     *
     */
    Subscription.prototype.delete = function () {
        return _super.prototype.deleteCore.call(this);
    };
    return Subscription;
}(SharePointQueryableInstance));

/**
 * Describes a collection of user custom actions
 *
 */
var UserCustomActions = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(UserCustomActions, _super);
    function UserCustomActions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UserCustomActions_1 = UserCustomActions;
    /**
     * Returns the user custom action with the specified id
     *
     * @param id The GUID id of the user custom action to retrieve
     */
    UserCustomActions.prototype.getById = function (id) {
        var uca = new UserCustomAction(this);
        uca.concat("('" + id + "')");
        return uca;
    };
    /**
     * Creates a user custom action
     *
     * @param properties The information object of property names and values which define the new user custom action
     *
     */
    UserCustomActions.prototype.add = function (properties) {
        var _this = this;
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ __metadata: { "type": "SP.UserCustomAction" } }, properties));
        return this.postCore({ body: postBody }).then(function (data) {
            return {
                action: _this.getById(data.Id),
                data: data,
            };
        });
    };
    /**
     * Deletes all user custom actions in the collection
     *
     */
    UserCustomActions.prototype.clear = function () {
        return this.clone(UserCustomActions_1, "clear").postCore();
    };
    var UserCustomActions_1;
    UserCustomActions = UserCustomActions_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("usercustomactions")
    ], UserCustomActions);
    return UserCustomActions;
}(SharePointQueryableCollection));
/**
 * Describes a single user custom action
 *
 */
var UserCustomAction = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(UserCustomAction, _super);
    function UserCustomAction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
        * Updates this user custom action with the supplied properties
        *
        * @param properties An information object of property names and values to update for this user custom action
        */
        _this.update = _this._update("SP.UserCustomAction", function (data) { return ({ data: data, action: _this }); });
        return _this;
    }
    /**
    * Removes this user custom action
    *
    */
    UserCustomAction.prototype.delete = function () {
        return _super.prototype.deleteCore.call(this);
    };
    return UserCustomAction;
}(SharePointQueryableInstance));

/**
 * Describes a collection of List objects
 *
 */
var Lists = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Lists, _super);
    function Lists() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Lists_1 = Lists;
    /**
     * Gets a list from the collection by guid id
     *
     * @param id The Id of the list (GUID)
     */
    Lists.prototype.getById = function (id) {
        var list = new List(this);
        list.concat("('" + id + "')");
        return list;
    };
    /**
     * Gets a list from the collection by title
     *
     * @param title The title of the list
     */
    Lists.prototype.getByTitle = function (title) {
        return new List(this, "getByTitle('" + title + "')");
    };
    /**
     * Adds a new list to the collection
     *
     * @param title The new list's title
     * @param description The new list's description
     * @param template The list template value
     * @param enableContentTypes If true content types will be allowed and enabled, otherwise they will be disallowed and not enabled
     * @param additionalSettings Will be passed as part of the list creation body
     */
    Lists.prototype.add = function (title, description, template, enableContentTypes, additionalSettings) {
        var _this = this;
        if (description === void 0) { description = ""; }
        if (template === void 0) { template = 100; }
        if (enableContentTypes === void 0) { enableContentTypes = false; }
        if (additionalSettings === void 0) { additionalSettings = {}; }
        var addSettings = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({
            "AllowContentTypes": enableContentTypes,
            "BaseTemplate": template,
            "ContentTypesEnabled": enableContentTypes,
            "Description": description,
            "Title": title,
            "__metadata": { "type": "SP.List" },
        }, additionalSettings);
        return this.postCore({ body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(addSettings) }).then(function (data) {
            return { data: data, list: _this.getByTitle(addSettings.Title) };
        });
    };
    /**
     * Ensures that the specified list exists in the collection (note: this method not supported for batching)
     *
     * @param title The new list's title
     * @param description The new list's description
     * @param template The list template value
     * @param enableContentTypes If true content types will be allowed and enabled, otherwise they will be disallowed and not enabled
     * @param additionalSettings Will be passed as part of the list creation body or used to update an existing list
     */
    Lists.prototype.ensure = function (title, description, template, enableContentTypes, additionalSettings) {
        var _this = this;
        if (description === void 0) { description = ""; }
        if (template === void 0) { template = 100; }
        if (enableContentTypes === void 0) { enableContentTypes = false; }
        if (additionalSettings === void 0) { additionalSettings = {}; }
        if (this.hasBatch) {
            throw Error("The ensure list method is not supported for use in a batch.");
        }
        return new Promise(function (resolve, reject) {
            var addOrUpdateSettings = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(additionalSettings, { Title: title, Description: description, ContentTypesEnabled: enableContentTypes }, true);
            var list = _this.getByTitle(addOrUpdateSettings.Title);
            list.get().then(function (_) {
                list.update(addOrUpdateSettings).then(function (d) {
                    resolve({ created: false, data: d, list: _this.getByTitle(addOrUpdateSettings.Title) });
                }).catch(function (e) { return reject(e); });
            }).catch(function (_) {
                _this.add(title, description, template, enableContentTypes, addOrUpdateSettings).then(function (r) {
                    resolve({ created: true, data: r.data, list: _this.getByTitle(addOrUpdateSettings.Title) });
                }).catch(function (e) { return reject(e); });
            });
        });
    };
    /**
     * Gets a list that is the default asset location for images or other files, which the users upload to their wiki pages.
     */
    Lists.prototype.ensureSiteAssetsLibrary = function () {
        return this.clone(Lists_1, "ensuresiteassetslibrary").postCore().then(function (json) {
            return new List(odataUrlFrom(json));
        });
    };
    /**
     * Gets a list that is the default location for wiki pages.
     */
    Lists.prototype.ensureSitePagesLibrary = function () {
        return this.clone(Lists_1, "ensuresitepageslibrary").postCore().then(function (json) {
            return new List(odataUrlFrom(json));
        });
    };
    var Lists_1;
    Lists = Lists_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("lists")
    ], Lists);
    return Lists;
}(SharePointQueryableCollection));
/**
 * Describes a single List instance
 *
 */
var List = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(List, _super);
    function List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(List.prototype, "contentTypes", {
        /**
         * Gets the content types in this list
         *
         */
        get: function () {
            return new ContentTypes(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "items", {
        /**
         * Gets the items in this list
         *
         */
        get: function () {
            return new Items(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "views", {
        /**
         * Gets the views in this list
         *
         */
        get: function () {
            return new Views(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "fields", {
        /**
         * Gets the fields in this list
         *
         */
        get: function () {
            return new Fields(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "forms", {
        /**
         * Gets the forms in this list
         *
         */
        get: function () {
            return new Forms(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "defaultView", {
        /**
         * Gets the default view of this list
         *
         */
        get: function () {
            return new View(this, "DefaultView");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "userCustomActions", {
        /**
         * Get all custom actions on a site collection
         *
         */
        get: function () {
            return new UserCustomActions(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "effectiveBasePermissions", {
        /**
         * Gets the effective base permissions of this list
         *
         */
        get: function () {
            return new SharePointQueryable(this, "EffectiveBasePermissions");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "eventReceivers", {
        /**
         * Gets the event receivers attached to this list
         *
         */
        get: function () {
            return new SharePointQueryableCollection(this, "EventReceivers");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "relatedFields", {
        /**
         * Gets the related fields of this list
         *
         */
        get: function () {
            return new SharePointQueryable(this, "getRelatedFields");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "informationRightsManagementSettings", {
        /**
         * Gets the IRM settings for this list
         *
         */
        get: function () {
            return new SharePointQueryable(this, "InformationRightsManagementSettings");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "subscriptions", {
        /**
         * Gets the webhook subscriptions of this list
         *
         */
        get: function () {
            return new Subscriptions(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(List.prototype, "rootFolder", {
        /**
         * The root folder of the list
         */
        get: function () {
            return new Folder(this, "rootFolder");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a view by view guid id
     *
     */
    List.prototype.getView = function (viewId) {
        return new View(this, "getView('" + viewId + "')");
    };
    /**
     * Updates this list intance with the supplied properties
     *
     * @param properties A plain object hash of values to update for the list
     * @param eTag Value used in the IF-Match header, by default "*"
     */
    /* tslint:disable no-string-literal */
    List.prototype.update = function (properties, eTag) {
        var _this = this;
        if (eTag === void 0) { eTag = "*"; }
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({
            "__metadata": { "type": "SP.List" },
        }, properties));
        return this.postCore({
            body: postBody,
            headers: {
                "IF-Match": eTag,
                "X-HTTP-Method": "MERGE",
            },
        }).then(function (data) {
            var retList = _this;
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(properties, "Title")) {
                retList = _this.getParent(List, _this.parentUrl, "getByTitle('" + properties["Title"] + "')");
            }
            return {
                data: data,
                list: retList,
            };
        });
    };
    /* tslint:enable */
    /**
     * Delete this list
     *
     * @param eTag Value used in the IF-Match header, by default "*"
     */
    List.prototype.delete = function (eTag) {
        if (eTag === void 0) { eTag = "*"; }
        return this.postCore({
            headers: {
                "IF-Match": eTag,
                "X-HTTP-Method": "DELETE",
            },
        });
    };
    /**
     * Returns the collection of changes from the change log that have occurred within the list, based on the specified query.
     */
    List.prototype.getChanges = function (query) {
        return this.clone(List, "getchanges").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ "query": Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ "__metadata": { "type": "SP.ChangeQuery" } }, query) }),
        });
    };
    /**
     * Returns a collection of items from the list based on the specified query.
     *
     * @param CamlQuery The Query schema of Collaborative Application Markup
     * Language (CAML) is used in various ways within the context of Microsoft SharePoint Foundation
     * to define queries against list data.
     * see:
     *
     * https://msdn.microsoft.com/en-us/library/office/ms467521.aspx
     *
     * @param expands A URI with a $expand System Query Option indicates that Entries associated with
     * the Entry or Collection of Entries identified by the Resource Path
     * section of the URI must be represented inline (i.e. eagerly loaded).
     * see:
     *
     * https://msdn.microsoft.com/en-us/library/office/fp142385.aspx
     *
     * http://www.odata.org/documentation/odata-version-2-0/uri-conventions/#ExpandSystemQueryOption
     */
    List.prototype.getItemsByCAMLQuery = function (query) {
        var expands = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            expands[_i - 1] = arguments[_i];
        }
        var q = this.clone(List, "getitems");
        return q.expand.apply(q, expands).postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ "query": Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ "__metadata": { "type": "SP.CamlQuery" } }, query) }),
        });
    };
    /**
     * See: https://msdn.microsoft.com/en-us/library/office/dn292554.aspx
     */
    List.prototype.getListItemChangesSinceToken = function (query) {
        return this.clone(List, "getlistitemchangessincetoken").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ "query": Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ "__metadata": { "type": "SP.ChangeLogItemQuery" } }, query) }),
        }, { parse: function (r) { return r.text(); } });
    };
    /**
     * Moves the list to the Recycle Bin and returns the identifier of the new Recycle Bin item.
     */
    List.prototype.recycle = function () {
        return this.clone(List, "recycle").postCore().then(function (data) {
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(data, "Recycle")) {
                return data.Recycle;
            }
            else {
                return data;
            }
        });
    };
    /**
     * Renders list data based on the view xml provided
     */
    List.prototype.renderListData = function (viewXml) {
        var q = this.clone(List, "renderlistdata(@viewXml)");
        q.query.set("@viewXml", "'" + viewXml + "'");
        return q.postCore().then(function (data) {
            // data will be a string, so we parse it again
            return JSON.parse(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(data, "RenderListData") ? data.RenderListData : data);
        });
    };
    /**
     * Returns the data for the specified query view
     *
     * @param parameters The parameters to be used to render list data as JSON string.
     * @param overrideParameters The parameters that are used to override and extend the regular SPRenderListDataParameters.
     */
    List.prototype.renderListDataAsStream = function (parameters, overrideParameters) {
        if (overrideParameters === void 0) { overrideParameters = null; }
        var postBody = {
            overrideParameters: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.RenderListDataOverrideParameters"), overrideParameters),
            parameters: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.RenderListDataParameters"), parameters),
        };
        return this.clone(List, "RenderListDataAsStream", true).postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(postBody),
        });
    };
    /**
     * Gets the field values and field schema attributes for a list item.
     */
    List.prototype.renderListFormData = function (itemId, formId, mode) {
        return this.clone(List, "renderlistformdata(itemid=" + itemId + ", formid='" + formId + "', mode='" + mode + "')").postCore().then(function (data) {
            // data will be a string, so we parse it again
            return JSON.parse(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(data, "RenderListFormData") ? data.RenderListFormData : data);
        });
    };
    /**
     * Reserves a list item ID for idempotent list item creation.
     */
    List.prototype.reserveListItemId = function () {
        return this.clone(List, "reservelistitemid").postCore().then(function (data) {
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(data, "ReserveListItemId")) {
                return data.ReserveListItemId;
            }
            else {
                return data;
            }
        });
    };
    /**
     * Returns the ListItemEntityTypeFullName for this list, used when adding/updating list items. Does not support batching.
     *
     */
    List.prototype.getListItemEntityTypeFullName = function () {
        return this.clone(List, null, false).select("ListItemEntityTypeFullName").get().then(function (o) { return o.ListItemEntityTypeFullName; });
    };
    /**
     * Creates an item using path (in a folder), validates and sets its field values.
     *
     * @param formValues The fields to change and their new values.
     * @param decodedUrl Path decoded url; folder's server relative path.
     * @param bNewDocumentUpdate true if the list item is a document being updated after upload; otherwise false.
     * @param checkInComment Optional check in comment.
     */
    List.prototype.addValidateUpdateItemUsingPath = function (formValues, decodedUrl, bNewDocumentUpdate, checkInComment) {
        if (bNewDocumentUpdate === void 0) { bNewDocumentUpdate = false; }
        return this.clone(List, "AddValidateUpdateItemUsingPath()").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                bNewDocumentUpdate: bNewDocumentUpdate,
                checkInComment: checkInComment,
                formValues: formValues,
                listItemCreateInfo: {
                    FolderPath: {
                        DecodedUrl: decodedUrl,
                        __metadata: { type: "SP.ResourcePath" },
                    },
                    __metadata: { type: "SP.ListItemCreationInformationUsingPath" },
                },
            }),
        }).then(function (res) {
            if (typeof res.AddValidateUpdateItemUsingPath !== "undefined") {
                return res.AddValidateUpdateItemUsingPath.results;
            }
            return res;
        });
    };
    return List;
}(SharePointQueryableSecurable));

/**
 * Represents a Collection of comments
 */
var Comments = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Comments, _super);
    function Comments() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Comments_1 = Comments;
    /**
     * Adds a new comment to this collection
     *
     * @param info Comment information to add
     */
    Comments.prototype.add = function (info) {
        var _this = this;
        if (typeof info === "string") {
            info = { text: info };
        }
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("Microsoft.SharePoint.Comments.comment"), info));
        return this.clone(Comments_1, null).postCore({ body: postBody }).then(function (d) {
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(_this.getById(d.id), d);
        });
    };
    /**
     * Gets a comment by id
     *
     * @param id Id of the comment to load
     */
    Comments.prototype.getById = function (id) {
        var c = new Comment(this);
        c.concat("(" + id + ")");
        return c;
    };
    /**
     * Deletes all the comments in this collection
     */
    Comments.prototype.clear = function () {
        return this.clone(Comments_1, "DeleteAll").postCore();
    };
    var Comments_1;
    Comments = Comments_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("comments")
    ], Comments);
    return Comments;
}(SharePointQueryableCollection));
/**
 * Represents a comment
 */
var Comment = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Comment, _super);
    function Comment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Comment.prototype, "replies", {
        get: function () {
            return new Replies(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Likes the comment as the current user
     */
    Comment.prototype.like = function () {
        return this.clone(Comment, "Like").postCore();
    };
    /**
     * Unlikes the comment as the current user
     */
    Comment.prototype.unlike = function () {
        return this.clone(Comment, "Unlike").postCore();
    };
    /**
     * Deletes this comment
     */
    Comment.prototype.delete = function () {
        return this.clone(Comment, "DeleteComment").postCore();
    };
    return Comment;
}(SharePointQueryableInstance));
/**
 * Represents a Collection of comments
 */
var Replies = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Replies, _super);
    function Replies() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Replies_1 = Replies;
    /**
     * Adds a new reply to this collection
     *
     * @param info Comment information to add
     */
    Replies.prototype.add = function (info) {
        if (typeof info === "string") {
            info = { text: info };
        }
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("Microsoft.SharePoint.Comments.comment"), info));
        return this.clone(Replies_1, null).postCore({ body: postBody }).then(function (d) {
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(new Comment(odataUrlFrom(d)), d);
        });
    };
    var Replies_1;
    Replies = Replies_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("replies")
    ], Replies);
    return Replies;
}(SharePointQueryableCollection));

/**
 * Describes a collection of Item objects
 *
 */
var Items = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Items, _super);
    function Items() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Items_1 = Items;
    /**
    * Gets an Item by id
    *
    * @param id The integer id of the item to retrieve
    */
    Items.prototype.getById = function (id) {
        var i = new Item(this);
        i.concat("(" + id + ")");
        return i;
    };
    /**
     * Gets BCS Item by string id
     *
     * @param stringId The string id of the BCS item to retrieve
     */
    Items.prototype.getItemByStringId = function (stringId) {
        // creates an item with the parent list path and append out method call
        return new Item(this.parentUrl, "getItemByStringId('" + stringId + "')");
    };
    /**
     * Skips the specified number of items (https://msdn.microsoft.com/en-us/library/office/fp142385.aspx#sectionSection6)
     *
     * @param skip The starting id where the page should start, use with top to specify pages
     * @param reverse It true the PagedPrev=true parameter is added allowing backwards navigation in the collection
     */
    Items.prototype.skip = function (skip, reverse) {
        if (reverse === void 0) { reverse = false; }
        if (reverse) {
            this.query.set("$skiptoken", encodeURIComponent("Paged=TRUE&PagedPrev=TRUE&p_ID=" + skip));
        }
        else {
            this.query.set("$skiptoken", encodeURIComponent("Paged=TRUE&p_ID=" + skip));
        }
        return this;
    };
    /**
     * Gets a collection designed to aid in paging through data
     *
     */
    Items.prototype.getPaged = function () {
        return this.get(new PagedItemCollectionParser(this));
    };
    /**
     * Gets all the items in a list, regardless of count. Does not support batching or caching
     *
     *  @param requestSize Number of items to return in each request (Default: 2000)
     *  @param acceptHeader Allows for setting the value of the Accept header for SP 2013 support
     */
    Items.prototype.getAll = function (requestSize, acceptHeader) {
        if (requestSize === void 0) { requestSize = 2000; }
        if (acceptHeader === void 0) { acceptHeader = "application/json;odata=nometadata"; }
        _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("Calling items.getAll should be done sparingly. Ensure this is the correct choice. If you are unsure, it is not.", 2 /* Warning */);
        // this will be used for the actual query
        // and we set no metadata here to try and reduce traffic
        var items = new Items_1(this, "").top(requestSize).configure({
            headers: {
                "Accept": acceptHeader,
            },
        });
        // let's copy over the odata query params that can be applied
        // $top - allow setting the page size this way (override what we did above)
        // $select - allow picking the return fields (good behavior)
        // $filter - allow setting a filter, though this may fail due for large lists
        this.query.forEach(function (v, k) {
            if (/^\$select|filter|top|expand$/i.test(k)) {
                items.query.set(k, v);
            }
        });
        // give back the promise
        return new Promise(function (resolve, reject) {
            // this will eventually hold the items we return
            var itemsCollector = [];
            // action that will gather up our results recursively
            var gatherer = function (last) {
                // collect that set of results
                [].push.apply(itemsCollector, last.results);
                // if we have more, repeat - otherwise resolve with the collected items
                if (last.hasNext) {
                    last.getNext().then(gatherer).catch(reject);
                }
                else {
                    resolve(itemsCollector);
                }
            };
            // start the cycle
            items.getPaged().then(gatherer).catch(reject);
        });
    };
    /**
     * Adds a new item to the collection
     *
     * @param properties The new items's properties
     * @param listItemEntityTypeFullName The type name of the list's entities
     */
    Items.prototype.add = function (properties, listItemEntityTypeFullName) {
        var _this = this;
        if (properties === void 0) { properties = {}; }
        if (listItemEntityTypeFullName === void 0) { listItemEntityTypeFullName = null; }
        var removeDependency = this.addBatchDependency();
        return this.ensureListItemEntityTypeName(listItemEntityTypeFullName).then(function (listItemEntityType) {
            var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata(listItemEntityType), properties));
            var promise = _this.clone(Items_1, "").postCore({ body: postBody }).then(function (data) {
                return {
                    data: data,
                    item: _this.getById(data.Id),
                };
            });
            removeDependency();
            return promise;
        });
    };
    /**
     * Ensures we have the proper list item entity type name, either from the value provided or from the list
     *
     * @param candidatelistItemEntityTypeFullName The potential type name
     */
    Items.prototype.ensureListItemEntityTypeName = function (candidatelistItemEntityTypeFullName) {
        return candidatelistItemEntityTypeFullName ?
            Promise.resolve(candidatelistItemEntityTypeFullName) :
            this.getParent(List).getListItemEntityTypeFullName();
    };
    var Items_1;
    Items = Items_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("items")
    ], Items);
    return Items;
}(SharePointQueryableCollection));
/**
 * Descrines a single Item instance
 *
 */
var Item = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Item, _super);
    function Item() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Delete this item
         *
         * @param eTag Value used in the IF-Match header, by default "*"
         */
        _this.delete = _this._deleteWithETag;
        return _this;
    }
    Object.defineProperty(Item.prototype, "attachmentFiles", {
        /**
         * Gets the set of attachments for this item
         *
         */
        get: function () {
            return new AttachmentFiles(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "contentType", {
        /**
         * Gets the content type for this item
         *
         */
        get: function () {
            return new ContentType(this, "ContentType");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "comments", {
        /**
         * Gets the collection of comments associated with this list item
         */
        get: function () {
            return new Comments(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "effectiveBasePermissions", {
        /**
         * Gets the effective base permissions for the item
         *
         */
        get: function () {
            return new SharePointQueryable(this, "EffectiveBasePermissions");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "effectiveBasePermissionsForUI", {
        /**
         * Gets the effective base permissions for the item in a UI context
         *
         */
        get: function () {
            return new SharePointQueryable(this, "EffectiveBasePermissionsForUI");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "fieldValuesAsHTML", {
        /**
         * Gets the field values for this list item in their HTML representation
         *
         */
        get: function () {
            return new SharePointQueryableInstance(this, "FieldValuesAsHTML");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "fieldValuesAsText", {
        /**
         * Gets the field values for this list item in their text representation
         *
         */
        get: function () {
            return new SharePointQueryableInstance(this, "FieldValuesAsText");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "fieldValuesForEdit", {
        /**
         * Gets the field values for this list item for use in editing controls
         *
         */
        get: function () {
            return new SharePointQueryableInstance(this, "FieldValuesForEdit");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "folder", {
        /**
         * Gets the folder associated with this list item (if this item represents a folder)
         *
         */
        get: function () {
            return new Folder(this, "folder");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "file", {
        /**
         * Gets the folder associated with this list item (if this item represents a folder)
         *
         */
        get: function () {
            return new File(this, "file");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Item.prototype, "versions", {
        /**
         * Gets the collection of versions associated with this item
         */
        get: function () {
            return new ItemVersions(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates this list intance with the supplied properties
     *
     * @param properties A plain object hash of values to update for the list
     * @param eTag Value used in the IF-Match header, by default "*"
     * @param listItemEntityTypeFullName The type name of the list's entities
     */
    Item.prototype.update = function (properties, eTag, listItemEntityTypeFullName) {
        var _this = this;
        if (eTag === void 0) { eTag = "*"; }
        if (listItemEntityTypeFullName === void 0) { listItemEntityTypeFullName = null; }
        return new Promise(function (resolve, reject) {
            var removeDependency = _this.addBatchDependency();
            return _this.ensureListItemEntityTypeName(listItemEntityTypeFullName).then(function (listItemEntityType) {
                var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata(listItemEntityType), properties));
                removeDependency();
                return _this.postCore({
                    body: postBody,
                    headers: {
                        "IF-Match": eTag,
                        "X-HTTP-Method": "MERGE",
                    },
                }, new ItemUpdatedParser()).then(function (data) {
                    resolve({
                        data: data,
                        item: _this,
                    });
                });
            }).catch(function (e) { return reject(e); });
        });
    };
    /**
     * Gets the collection of people who have liked this item
     */
    Item.prototype.getLikedBy = function () {
        return this.clone(Item, "likedBy").postCore();
    };
    /**
     * Likes this item as the current user
     */
    Item.prototype.like = function () {
        return this.clone(Item, "like").postCore();
    };
    /**
     * Unlikes this item as the current user
     */
    Item.prototype.unlike = function () {
        return this.clone(Item, "unlike").postCore();
    };
    /**
     * Moves the list item to the Recycle Bin and returns the identifier of the new Recycle Bin item.
     */
    Item.prototype.recycle = function () {
        return this.clone(Item, "recycle").postCore();
    };
    /**
     * Gets a string representation of the full URL to the WOPI frame.
     * If there is no associated WOPI application, or no associated action, an empty string is returned.
     *
     * @param action Display mode: 0: view, 1: edit, 2: mobileView, 3: interactivePreview
     */
    Item.prototype.getWopiFrameUrl = function (action) {
        if (action === void 0) { action = 0; }
        var i = this.clone(Item, "getWOPIFrameUrl(@action)");
        i.query.set("@action", action);
        return i.postCore().then(function (data) {
            // handle verbose mode
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(data, "GetWOPIFrameUrl")) {
                return data.GetWOPIFrameUrl;
            }
            return data;
        });
    };
    /**
     * Validates and sets the values of the specified collection of fields for the list item.
     *
     * @param formValues The fields to change and their new values.
     * @param newDocumentUpdate true if the list item is a document being updated after upload; otherwise false.
     */
    Item.prototype.validateUpdateListItem = function (formValues, newDocumentUpdate) {
        if (newDocumentUpdate === void 0) { newDocumentUpdate = false; }
        return this.clone(Item, "validateupdatelistitem").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ "formValues": formValues, bNewDocumentUpdate: newDocumentUpdate }),
        });
    };
    /**
     * Ensures we have the proper list item entity type name, either from the value provided or from the list
     *
     * @param candidatelistItemEntityTypeFullName The potential type name
     */
    Item.prototype.ensureListItemEntityTypeName = function (candidatelistItemEntityTypeFullName) {
        return candidatelistItemEntityTypeFullName ?
            Promise.resolve(candidatelistItemEntityTypeFullName) :
            this.getParent(List, this.parentUrl.substr(0, this.parentUrl.lastIndexOf("/"))).getListItemEntityTypeFullName();
    };
    return Item;
}(SharePointQueryableShareableItem));
/**
 * Describes a collection of Version objects
 *
 */
var ItemVersions = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ItemVersions, _super);
    function ItemVersions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a version by id
     *
     * @param versionId The id of the version to retrieve
     */
    ItemVersions.prototype.getById = function (versionId) {
        var v = new ItemVersion(this);
        v.concat("(" + versionId + ")");
        return v;
    };
    ItemVersions = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("versions")
    ], ItemVersions);
    return ItemVersions;
}(SharePointQueryableCollection));
/**
 * Describes a single Version instance
 *
 */
var ItemVersion = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ItemVersion, _super);
    function ItemVersion() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
        * Delete a specific version of a file.
        *
        * @param eTag Value used in the IF-Match header, by default "*"
        */
        _this.delete = _this._deleteWithETag;
        return _this;
    }
    return ItemVersion;
}(SharePointQueryableInstance));
/**
 * Provides paging functionality for list items
 */
var PagedItemCollection = /** @class */ (function () {
    function PagedItemCollection(parent, nextUrl, results) {
        this.parent = parent;
        this.nextUrl = nextUrl;
        this.results = results;
    }
    Object.defineProperty(PagedItemCollection.prototype, "hasNext", {
        /**
         * If true there are more results available in the set, otherwise there are not
         */
        get: function () {
            return typeof this.nextUrl === "string" && this.nextUrl.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the next set of results, or resolves to null if no results are available
     */
    PagedItemCollection.prototype.getNext = function () {
        if (this.hasNext) {
            var items = new Items(this.nextUrl, null).configureFrom(this.parent);
            return items.getPaged();
        }
        return new Promise(function (r) { return r(null); });
    };
    return PagedItemCollection;
}());
var PagedItemCollectionParser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(PagedItemCollectionParser, _super);
    function PagedItemCollectionParser(_parent) {
        var _this = _super.call(this) || this;
        _this._parent = _parent;
        return _this;
    }
    PagedItemCollectionParser.prototype.parse = function (r) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.handleError(r, reject)) {
                r.json().then(function (json) {
                    var nextUrl = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(json, "d") && Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(json.d, "__next") ? json.d.__next : json["odata.nextLink"];
                    resolve(new PagedItemCollection(_this._parent, nextUrl, _this.parseODataJSON(json)));
                });
            }
        });
    };
    return PagedItemCollectionParser;
}(_pnp_odata__WEBPACK_IMPORTED_MODULE_3__["ODataParserBase"]));
var ItemUpdatedParser = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ItemUpdatedParser, _super);
    function ItemUpdatedParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ItemUpdatedParser.prototype.parse = function (r) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.handleError(r, reject)) {
                resolve({
                    "odata.etag": r.headers.get("etag"),
                });
            }
        });
    };
    return ItemUpdatedParser;
}(_pnp_odata__WEBPACK_IMPORTED_MODULE_3__["ODataParserBase"]));

/**
 * Describes a collection of File objects
 *
 */
var Files = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Files, _super);
    function Files() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Files_1 = Files;
    /**
     * Gets a File by filename
     *
     * @param name The name of the file, including extension.
     */
    Files.prototype.getByName = function (name) {
        var f = new File(this);
        f.concat("('" + name + "')");
        return f;
    };
    /**
     * Uploads a file. Not supported for batching
     *
     * @param url The folder-relative url of the file.
     * @param content The file contents blob.
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten? (default: true)
     * @returns The new File and the raw response.
     */
    Files.prototype.add = function (url, content, shouldOverWrite) {
        var _this = this;
        if (shouldOverWrite === void 0) { shouldOverWrite = true; }
        return new Files_1(this, "add(overwrite=" + shouldOverWrite + ",url='" + url + "')")
            .postCore({
            body: content,
        }).then(function (response) {
            return {
                data: response,
                file: _this.getByName(url),
            };
        });
    };
    /**
     * Uploads a file. Not supported for batching
     *
     * @param url The folder-relative url of the file.
     * @param content The Blob file content to add
     * @param progress A callback function which can be used to track the progress of the upload
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten? (default: true)
     * @param chunkSize The size of each file slice, in bytes (default: 10485760)
     * @returns The new File and the raw response.
     */
    Files.prototype.addChunked = function (url, content, progress, shouldOverWrite, chunkSize) {
        var _this = this;
        if (shouldOverWrite === void 0) { shouldOverWrite = true; }
        if (chunkSize === void 0) { chunkSize = 10485760; }
        var adder = this.clone(Files_1, "add(overwrite=" + shouldOverWrite + ",url='" + url + "')", false);
        return adder.postCore()
            .then(function () { return _this.getByName(url); })
            .then(function (file) { return file.setContentChunked(content, progress, chunkSize); });
    };
    /**
     * Adds a ghosted file to an existing list or document library. Not supported for batching.
     *
     * @param fileUrl The server-relative url where you want to save the file.
     * @param templateFileType The type of use to create the file.
     * @returns The template file that was added and the raw response.
     */
    Files.prototype.addTemplateFile = function (fileUrl, templateFileType) {
        var _this = this;
        return this.clone(Files_1, "addTemplateFile(urloffile='" + fileUrl + "',templatefiletype=" + templateFileType + ")", false)
            .postCore().then(function (response) {
            return {
                data: response,
                file: _this.getByName(fileUrl),
            };
        });
    };
    var Files_1;
    Files = Files_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("files")
    ], Files);
    return Files;
}(SharePointQueryableCollection));
/**
 * Describes a single File instance
 *
 */
var File = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(File, _super);
    function File() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(File.prototype, "listItemAllFields", {
        /**
         * Gets a value that specifies the list item field values for the list item corresponding to the file.
         *
         */
        get: function () {
            return new SharePointQueryableInstance(this, "listItemAllFields");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "versions", {
        /**
         * Gets a collection of versions
         *
         */
        get: function () {
            return new Versions(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Approves the file submitted for content approval with the specified comment.
     * Only documents in lists that are enabled for content approval can be approved.
     *
     * @param comment The comment for the approval.
     */
    File.prototype.approve = function (comment) {
        if (comment === void 0) { comment = ""; }
        return this.clone(File, "approve(comment='" + comment + "')").postCore();
    };
    /**
     * Stops the chunk upload session without saving the uploaded data. Does not support batching.
     * If the file doesn’t already exist in the library, the partially uploaded file will be deleted.
     * Use this in response to user action (as in a request to cancel an upload) or an error or exception.
     * Use the uploadId value that was passed to the StartUpload method that started the upload session.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     */
    File.prototype.cancelUpload = function (uploadId) {
        return this.clone(File, "cancelUpload(uploadId=guid'" + uploadId + "')", false).postCore();
    };
    /**
     * Checks the file in to a document library based on the check-in type.
     *
     * @param comment A comment for the check-in. Its length must be <= 1023.
     * @param checkinType The check-in type for the file.
     */
    File.prototype.checkin = function (comment, checkinType) {
        if (comment === void 0) { comment = ""; }
        if (checkinType === void 0) { checkinType = CheckinType.Major; }
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return this.clone(File, "checkin(comment='" + comment + "',checkintype=" + checkinType + ")").postCore();
    };
    /**
     * Checks out the file from a document library.
     */
    File.prototype.checkout = function () {
        return this.clone(File, "checkout").postCore();
    };
    /**
     * Copies the file to the destination url.
     *
     * @param url The absolute url or server relative url of the destination file path to copy to.
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten?
     */
    File.prototype.copyTo = function (url, shouldOverWrite) {
        if (shouldOverWrite === void 0) { shouldOverWrite = true; }
        return this.clone(File, "copyTo(strnewurl='" + url + "',boverwrite=" + shouldOverWrite + ")").postCore();
    };
    /**
     * Delete this file.
     *
     * @param eTag Value used in the IF-Match header, by default "*"
     */
    File.prototype.delete = function (eTag) {
        if (eTag === void 0) { eTag = "*"; }
        return this.clone(File, null).postCore({
            headers: {
                "IF-Match": eTag,
                "X-HTTP-Method": "DELETE",
            },
        });
    };
    /**
     * Denies approval for a file that was submitted for content approval.
     * Only documents in lists that are enabled for content approval can be denied.
     *
     * @param comment The comment for the denial.
     */
    File.prototype.deny = function (comment) {
        if (comment === void 0) { comment = ""; }
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return this.clone(File, "deny(comment='" + comment + "')").postCore();
    };
    /**
     * Specifies the control set used to access, modify, or add Web Parts associated with this Web Part Page and view.
     * An exception is thrown if the file is not an ASPX page.
     *
     * @param scope The WebPartsPersonalizationScope view on the Web Parts page.
     */
    File.prototype.getLimitedWebPartManager = function (scope) {
        if (scope === void 0) { scope = WebPartsPersonalizationScope.Shared; }
        return new LimitedWebPartManager(this, "getLimitedWebPartManager(scope=" + scope + ")");
    };
    /**
     * Moves the file to the specified destination url.
     *
     * @param url The absolute url or server relative url of the destination file path to move to.
     * @param moveOperations The bitwise MoveOperations value for how to move the file.
     */
    File.prototype.moveTo = function (url, moveOperations) {
        if (moveOperations === void 0) { moveOperations = MoveOperations.Overwrite; }
        return this.clone(File, "moveTo(newurl='" + url + "',flags=" + moveOperations + ")").postCore();
    };
    /**
     * Submits the file for content approval with the specified comment.
     *
     * @param comment The comment for the published file. Its length must be <= 1023.
     */
    File.prototype.publish = function (comment) {
        if (comment === void 0) { comment = ""; }
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return this.clone(File, "publish(comment='" + comment + "')").postCore();
    };
    /**
     * Moves the file to the Recycle Bin and returns the identifier of the new Recycle Bin item.
     *
     * @returns The GUID of the recycled file.
     */
    File.prototype.recycle = function () {
        return this.clone(File, "recycle").postCore();
    };
    /**
     * Reverts an existing checkout for the file.
     *
     */
    File.prototype.undoCheckout = function () {
        return this.clone(File, "undoCheckout").postCore();
    };
    /**
     * Removes the file from content approval or unpublish a major version.
     *
     * @param comment The comment for the unpublish operation. Its length must be <= 1023.
     */
    File.prototype.unpublish = function (comment) {
        if (comment === void 0) { comment = ""; }
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return this.clone(File, "unpublish(comment='" + comment + "')").postCore();
    };
    /**
     * Gets the contents of the file as text. Not supported in batching.
     *
     */
    File.prototype.getText = function () {
        return this.clone(File, "$value", false).get(new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["TextParser"](), { headers: { "binaryStringResponseBody": "true" } });
    };
    /**
     * Gets the contents of the file as a blob, does not work in Node.js. Not supported in batching.
     *
     */
    File.prototype.getBlob = function () {
        return this.clone(File, "$value", false).get(new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["BlobParser"](), { headers: { "binaryStringResponseBody": "true" } });
    };
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js. Not supported in batching.
     */
    File.prototype.getBuffer = function () {
        return this.clone(File, "$value", false).get(new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["BufferParser"](), { headers: { "binaryStringResponseBody": "true" } });
    };
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js. Not supported in batching.
     */
    File.prototype.getJSON = function () {
        return this.clone(File, "$value", false).get(new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["JSONParser"](), { headers: { "binaryStringResponseBody": "true" } });
    };
    /**
     * Sets the content of a file, for large files use setContentChunked. Not supported in batching.
     *
     * @param content The file content
     *
     */
    File.prototype.setContent = function (content) {
        var _this = this;
        return this.clone(File, "$value", false).postCore({
            body: content,
            headers: {
                "X-HTTP-Method": "PUT",
            },
        }).then(function (_) { return new File(_this); });
    };
    /**
     * Gets the associated list item for this folder, loading the default properties
     */
    File.prototype.getItem = function () {
        var selects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            selects[_i] = arguments[_i];
        }
        var q = this.listItemAllFields;
        return q.select.apply(q, selects).get().then(function (d) {
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(new Item(odataUrlFrom(d)), d);
        });
    };
    /**
     * Sets the contents of a file using a chunked upload approach. Not supported in batching.
     *
     * @param file The file to upload
     * @param progress A callback function which can be used to track the progress of the upload
     * @param chunkSize The size of each file slice, in bytes (default: 10485760)
     */
    File.prototype.setContentChunked = function (file, progress, chunkSize) {
        var _this = this;
        if (chunkSize === void 0) { chunkSize = 10485760; }
        if (progress === undefined) {
            progress = function () { return null; };
        }
        var fileSize = file.size;
        var blockCount = parseInt((file.size / chunkSize).toString(), 10) + ((file.size % chunkSize === 0) ? 1 : 0);
        var uploadId = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getGUID"])();
        // start the chain with the first fragment
        progress({ uploadId: uploadId, blockNumber: 1, chunkSize: chunkSize, currentPointer: 0, fileSize: fileSize, stage: "starting", totalBlocks: blockCount });
        var chain = this.startUpload(uploadId, file.slice(0, chunkSize));
        var _loop_1 = function (i) {
            chain = chain.then(function (pointer) {
                progress({ uploadId: uploadId, blockNumber: i, chunkSize: chunkSize, currentPointer: pointer, fileSize: fileSize, stage: "continue", totalBlocks: blockCount });
                return _this.continueUpload(uploadId, pointer, file.slice(pointer, pointer + chunkSize));
            });
        };
        // skip the first and last blocks
        for (var i = 2; i < blockCount; i++) {
            _loop_1(i);
        }
        return chain.then(function (pointer) {
            progress({ uploadId: uploadId, blockNumber: blockCount, chunkSize: chunkSize, currentPointer: pointer, fileSize: fileSize, stage: "finishing", totalBlocks: blockCount });
            return _this.finishUpload(uploadId, pointer, file.slice(pointer));
        });
    };
    /**
     * Starts a new chunk upload session and uploads the first fragment.
     * The current file content is not changed when this method completes.
     * The method is idempotent (and therefore does not change the result) as long as you use the same values for uploadId and stream.
     * The upload session ends either when you use the CancelUpload method or when you successfully
     * complete the upload session by passing the rest of the file contents through the ContinueUpload and FinishUpload methods.
     * The StartUpload and ContinueUpload methods return the size of the running total of uploaded data in bytes,
     * so you can pass those return values to subsequent uses of ContinueUpload and FinishUpload.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     * @param fragment The file contents.
     * @returns The size of the total uploaded data in bytes.
     */
    File.prototype.startUpload = function (uploadId, fragment) {
        return this.clone(File, "startUpload(uploadId=guid'" + uploadId + "')", false)
            .postCore({ body: fragment })
            .then(function (n) {
            // When OData=verbose the payload has the following shape:
            // { StartUpload: "10485760" }
            if (typeof n === "object") {
                n = n.StartUpload;
            }
            return parseFloat(n);
        });
    };
    /**
     * Continues the chunk upload session with an additional fragment.
     * The current file content is not changed.
     * Use the uploadId value that was passed to the StartUpload method that started the upload session.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     * @param fileOffset The size of the offset into the file where the fragment starts.
     * @param fragment The file contents.
     * @returns The size of the total uploaded data in bytes.
     */
    File.prototype.continueUpload = function (uploadId, fileOffset, fragment) {
        return this.clone(File, "continueUpload(uploadId=guid'" + uploadId + "',fileOffset=" + fileOffset + ")", false)
            .postCore({ body: fragment })
            .then(function (n) {
            // When OData=verbose the payload has the following shape:
            // { ContinueUpload: "20971520" }
            if (typeof n === "object") {
                n = n.ContinueUpload;
            }
            return parseFloat(n);
        });
    };
    /**
     * Uploads the last file fragment and commits the file. The current file content is changed when this method completes.
     * Use the uploadId value that was passed to the StartUpload method that started the upload session.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     * @param fileOffset The size of the offset into the file where the fragment starts.
     * @param fragment The file contents.
     * @returns The newly uploaded file.
     */
    File.prototype.finishUpload = function (uploadId, fileOffset, fragment) {
        return this.clone(File, "finishUpload(uploadId=guid'" + uploadId + "',fileOffset=" + fileOffset + ")", false)
            .postCore({ body: fragment })
            .then(function (response) {
            return {
                data: response,
                file: new File(odataUrlFrom(response)),
            };
        });
    };
    return File;
}(SharePointQueryableShareableFile));
/**
 * Describes a collection of Version objects
 *
 */
var Versions = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Versions, _super);
    function Versions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Versions_1 = Versions;
    /**
     * Gets a version by id
     *
     * @param versionId The id of the version to retrieve
     */
    Versions.prototype.getById = function (versionId) {
        var v = new Version(this);
        v.concat("(" + versionId + ")");
        return v;
    };
    /**
     * Deletes all the file version objects in the collection.
     *
     */
    Versions.prototype.deleteAll = function () {
        return new Versions_1(this, "deleteAll").postCore();
    };
    /**
     * Deletes the specified version of the file.
     *
     * @param versionId The ID of the file version to delete.
     */
    Versions.prototype.deleteById = function (versionId) {
        return this.clone(Versions_1, "deleteById(vid=" + versionId + ")").postCore();
    };
    /**
     * Recycles the specified version of the file.
     *
     * @param versionId The ID of the file version to delete.
     */
    Versions.prototype.recycleByID = function (versionId) {
        return this.clone(Versions_1, "recycleByID(vid=" + versionId + ")").postCore();
    };
    /**
     * Deletes the file version object with the specified version label.
     *
     * @param label The version label of the file version to delete, for example: 1.2
     */
    Versions.prototype.deleteByLabel = function (label) {
        return this.clone(Versions_1, "deleteByLabel(versionlabel='" + label + "')").postCore();
    };
    /**
     * Recycles the file version object with the specified version label.
     *
     * @param label The version label of the file version to delete, for example: 1.2
     */
    Versions.prototype.recycleByLabel = function (label) {
        return this.clone(Versions_1, "recycleByLabel(versionlabel='" + label + "')").postCore();
    };
    /**
     * Creates a new file version from the file specified by the version label.
     *
     * @param label The version label of the file version to restore, for example: 1.2
     */
    Versions.prototype.restoreByLabel = function (label) {
        return this.clone(Versions_1, "restoreByLabel(versionlabel='" + label + "')").postCore();
    };
    var Versions_1;
    Versions = Versions_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("versions")
    ], Versions);
    return Versions;
}(SharePointQueryableCollection));
/**
 * Describes a single Version instance
 *
 */
var Version = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Version, _super);
    function Version() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
        * Delete a specific version of a file.
        *
        * @param eTag Value used in the IF-Match header, by default "*"
        */
        _this.delete = _this._deleteWithETag;
        return _this;
        // /**
        // * Delete a specific version of a file.
        // *
        // * @param eTag Value used in the IF-Match header, by default "*"
        // */
        // public delete(eTag = "*"): Promise<void> {
        //     return this.postCore({
        //         headers: {
        //             "IF-Match": eTag,
        //             "X-HTTP-Method": "DELETE",
        //         },
        //     });
        // }
    }
    return Version;
}(SharePointQueryableInstance));
var CheckinType;
(function (CheckinType) {
    CheckinType[CheckinType["Minor"] = 0] = "Minor";
    CheckinType[CheckinType["Major"] = 1] = "Major";
    CheckinType[CheckinType["Overwrite"] = 2] = "Overwrite";
})(CheckinType || (CheckinType = {}));
var WebPartsPersonalizationScope;
(function (WebPartsPersonalizationScope) {
    WebPartsPersonalizationScope[WebPartsPersonalizationScope["User"] = 0] = "User";
    WebPartsPersonalizationScope[WebPartsPersonalizationScope["Shared"] = 1] = "Shared";
})(WebPartsPersonalizationScope || (WebPartsPersonalizationScope = {}));
var MoveOperations;
(function (MoveOperations) {
    MoveOperations[MoveOperations["Overwrite"] = 1] = "Overwrite";
    MoveOperations[MoveOperations["AllowBrokenThickets"] = 8] = "AllowBrokenThickets";
})(MoveOperations || (MoveOperations = {}));
var TemplateFileType;
(function (TemplateFileType) {
    TemplateFileType[TemplateFileType["StandardPage"] = 0] = "StandardPage";
    TemplateFileType[TemplateFileType["WikiPage"] = 1] = "WikiPage";
    TemplateFileType[TemplateFileType["FormPage"] = 2] = "FormPage";
    TemplateFileType[TemplateFileType["ClientSidePage"] = 3] = "ClientSidePage";
})(TemplateFileType || (TemplateFileType = {}));

/**
 * Represents an app catalog
 */
var AppCatalog = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(AppCatalog, _super);
    function AppCatalog(baseUrl, path) {
        if (path === void 0) { path = "_api/web/tenantappcatalog/AvailableApps"; }
        return _super.call(this, extractWebUrl(typeof baseUrl === "string" ? baseUrl : baseUrl.toUrl()), path) || this;
    }
    /**
     * Get details of specific app from the app catalog
     * @param id - Specify the guid of the app
     */
    AppCatalog.prototype.getAppById = function (id) {
        return new App(this, "getById('" + id + "')");
    };
    /**
     * Uploads an app package. Not supported for batching
     *
     * @param filename Filename to create.
     * @param content app package data (eg: the .app or .sppkg file).
     * @param shouldOverWrite Should an app with the same name in the same location be overwritten? (default: true)
     * @returns Promise<AppAddResult>
     */
    AppCatalog.prototype.add = function (filename, content, shouldOverWrite) {
        if (shouldOverWrite === void 0) { shouldOverWrite = true; }
        // you don't add to the availableapps collection
        var adder = new AppCatalog(extractWebUrl(this.toUrl()), "_api/web/tenantappcatalog/add(overwrite=" + shouldOverWrite + ",url='" + filename + "')");
        return adder.postCore({
            body: content,
        }).then(function (r) {
            return {
                data: r,
                file: new File(odataUrlFrom(r)),
            };
        });
    };
    return AppCatalog;
}(SharePointQueryableCollection));
/**
 * Represents the actions you can preform on a given app within the catalog
 */
var App = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(App, _super);
    function App() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This method deploys an app on the app catalog.  It must be called in the context
     * of the tenant app catalog web or it will fail.
     */
    App.prototype.deploy = function () {
        return this.clone(App, "Deploy").postCore();
    };
    /**
     * This method retracts a deployed app on the app catalog.  It must be called in the context
     * of the tenant app catalog web or it will fail.
     */
    App.prototype.retract = function () {
        return this.clone(App, "Retract").postCore();
    };
    /**
     * This method allows an app which is already deployed to be installed on a web
     */
    App.prototype.install = function () {
        return this.clone(App, "Install").postCore();
    };
    /**
     * This method allows an app which is already insatlled to be uninstalled on a web
     */
    App.prototype.uninstall = function () {
        return this.clone(App, "Uninstall").postCore();
    };
    /**
     * This method allows an app which is already insatlled to be upgraded on a web
     */
    App.prototype.upgrade = function () {
        return this.clone(App, "Upgrade").postCore();
    };
    /**
     * This method removes an app from the app catalog.  It must be called in the context
     * of the tenant app catalog web or it will fail.
     */
    App.prototype.remove = function () {
        return this.clone(App, "Remove").postCore();
    };
    return App;
}(SharePointQueryableInstance));

/**
 * Manages a batch of OData operations
 */
var SPBatch = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SPBatch, _super);
    function SPBatch(baseUrl) {
        var _this = _super.call(this) || this;
        _this.baseUrl = baseUrl;
        return _this;
    }
    /**
     * Parses the response from a batch request into an array of Response instances
     *
     * @param body Text body of the response from the batch request
     */
    SPBatch.ParseResponse = function (body) {
        return new Promise(function (resolve, reject) {
            var responses = [];
            var header = "--batchresponse_";
            // Ex. "HTTP/1.1 500 Internal Server Error"
            var statusRegExp = new RegExp("^HTTP/[0-9.]+ +([0-9]+) +(.*)", "i");
            var lines = body.split("\n");
            var state = "batch";
            var status;
            var statusText;
            for (var i = 0; i < lines.length; ++i) {
                var line = lines[i];
                switch (state) {
                    case "batch":
                        if (line.substr(0, header.length) === header) {
                            state = "batchHeaders";
                        }
                        else {
                            if (line.trim() !== "") {
                                throw Error("Invalid response, line " + i);
                            }
                        }
                        break;
                    case "batchHeaders":
                        if (line.trim() === "") {
                            state = "status";
                        }
                        break;
                    case "status":
                        var parts = statusRegExp.exec(line);
                        if (parts.length !== 3) {
                            throw Error("Invalid status, line " + i);
                        }
                        status = parseInt(parts[1], 10);
                        statusText = parts[2];
                        state = "statusHeaders";
                        break;
                    case "statusHeaders":
                        if (line.trim() === "") {
                            state = "body";
                        }
                        break;
                    case "body":
                        responses.push((status === 204) ? new Response() : new Response(line, { status: status, statusText: statusText }));
                        state = "batch";
                        break;
                }
            }
            if (state !== "status") {
                reject(Error("Unexpected end of input"));
            }
            resolve(responses);
        });
    };
    SPBatch.prototype.executeImpl = function () {
        var _this = this;
        _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + this.batchId + "] (" + (new Date()).getTime() + ") Executing batch with " + this.requests.length + " requests.", 1 /* Info */);
        // if we don't have any requests, don't bother sending anything
        // this could be due to caching further upstream, or just an empty batch
        if (this.requests.length < 1) {
            _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("Resolving empty batch.", 1 /* Info */);
            return Promise.resolve();
        }
        // creating the client here allows the url to be populated for nodejs client as well as potentially
        // any other hacks needed for other types of clients. Essentially allows the absoluteRequestUrl
        // below to be correct
        var client = new SPHttpClient();
        // due to timing we need to get the absolute url here so we can use it for all the individual requests
        // and for sending the entire batch
        return toAbsoluteUrl(this.baseUrl).then(function (absoluteRequestUrl) {
            // build all the requests, send them, pipe results in order to parsers
            var batchBody = [];
            var currentChangeSetId = "";
            for (var i = 0; i < _this.requests.length; i++) {
                var reqInfo = _this.requests[i];
                if (reqInfo.method === "GET") {
                    if (currentChangeSetId.length > 0) {
                        // end an existing change set
                        batchBody.push("--changeset_" + currentChangeSetId + "--\n\n");
                        currentChangeSetId = "";
                    }
                    batchBody.push("--batch_" + _this.batchId + "\n");
                }
                else {
                    if (currentChangeSetId.length < 1) {
                        // start new change set
                        currentChangeSetId = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getGUID"])();
                        batchBody.push("--batch_" + _this.batchId + "\n");
                        batchBody.push("Content-Type: multipart/mixed; boundary=\"changeset_" + currentChangeSetId + "\"\n\n");
                    }
                    batchBody.push("--changeset_" + currentChangeSetId + "\n");
                }
                // common batch part prefix
                batchBody.push("Content-Type: application/http\n");
                batchBody.push("Content-Transfer-Encoding: binary\n\n");
                var headers = new Headers();
                // this is the url of the individual request within the batch
                var url = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["isUrlAbsolute"])(reqInfo.url) ? reqInfo.url : Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(absoluteRequestUrl, reqInfo.url);
                _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + _this.batchId + "] (" + (new Date()).getTime() + ") Adding request " + reqInfo.method + " " + url + " to batch.", 0 /* Verbose */);
                if (reqInfo.method !== "GET") {
                    var method = reqInfo.method;
                    var castHeaders = reqInfo.options.headers;
                    if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(reqInfo, "options") && Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(reqInfo.options, "headers") && castHeaders["X-HTTP-Method"] !== undefined) {
                        method = castHeaders["X-HTTP-Method"];
                        delete castHeaders["X-HTTP-Method"];
                    }
                    batchBody.push(method + " " + url + " HTTP/1.1\n");
                    headers.set("Content-Type", "application/json;odata=verbose;charset=utf-8");
                }
                else {
                    batchBody.push(reqInfo.method + " " + url + " HTTP/1.1\n");
                }
                // merge global config headers
                Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["mergeHeaders"])(headers, SPRuntimeConfig.headers);
                // merge per-request headers
                if (reqInfo.options) {
                    Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["mergeHeaders"])(headers, reqInfo.options.headers);
                }
                // lastly we apply any default headers we need that may not exist
                if (!headers.has("Accept")) {
                    headers.append("Accept", "application/json");
                }
                if (!headers.has("Content-Type")) {
                    headers.append("Content-Type", "application/json;odata=verbose;charset=utf-8");
                }
                if (!headers.has("X-ClientService-ClientTag")) {
                    headers.append("X-ClientService-ClientTag", "PnPCoreJS:@pnp-1.2.3");
                }
                // write headers into batch body
                headers.forEach(function (value, name) {
                    batchBody.push(name + ": " + value + "\n");
                });
                batchBody.push("\n");
                if (reqInfo.options.body) {
                    batchBody.push(reqInfo.options.body + "\n\n");
                }
            }
            if (currentChangeSetId.length > 0) {
                // Close the changeset
                batchBody.push("--changeset_" + currentChangeSetId + "--\n\n");
                currentChangeSetId = "";
            }
            batchBody.push("--batch_" + _this.batchId + "--\n");
            var batchOptions = {
                "body": batchBody.join(""),
                "headers": {
                    "Content-Type": "multipart/mixed; boundary=batch_" + _this.batchId,
                },
                "method": "POST",
            };
            _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + _this.batchId + "] (" + (new Date()).getTime() + ") Sending batch request.", 1 /* Info */);
            return client.fetch(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])(absoluteRequestUrl, "/_api/$batch"), batchOptions)
                .then(function (r) { return r.text(); })
                .then(SPBatch.ParseResponse)
                .then(function (responses) {
                if (responses.length !== _this.requests.length) {
                    throw Error("Could not properly parse responses to match requests in batch.");
                }
                _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + _this.batchId + "] (" + (new Date()).getTime() + ") Resolving batched requests.", 1 /* Info */);
                return responses.reduce(function (chain, response, index) {
                    var request = _this.requests[index];
                    _pnp_logging__WEBPACK_IMPORTED_MODULE_2__["Logger"].write("[" + request.id + "] (" + (new Date()).getTime() + ") Resolving request in batch " + _this.batchId + ".", 1 /* Info */);
                    return chain.then(function (_) { return request.parser.parse(response).then(request.resolve).catch(request.reject); });
                }, Promise.resolve());
            });
        });
    };
    return SPBatch;
}(_pnp_odata__WEBPACK_IMPORTED_MODULE_3__["ODataBatch"]));

/**
 * Page promotion state
 */
var PromotedState;
(function (PromotedState) {
    /**
     * Regular client side page
     */
    PromotedState[PromotedState["NotPromoted"] = 0] = "NotPromoted";
    /**
     * Page that will be promoted as news article after publishing
     */
    PromotedState[PromotedState["PromoteOnPublish"] = 1] = "PromoteOnPublish";
    /**
     * Page that is promoted as news article
     */
    PromotedState[PromotedState["Promoted"] = 2] = "Promoted";
})(PromotedState || (PromotedState = {}));
/**
 * Gets the next order value 1 based for the provided collection
 *
 * @param collection Collection of orderable things
 */
function getNextOrder(collection) {
    if (collection.length < 1) {
        return 1;
    }
    return Math.max.apply(null, collection.map(function (i) { return i.order; })) + 1;
}
/**
 * After https://stackoverflow.com/questions/273789/is-there-a-version-of-javascripts-string-indexof-that-allows-for-regular-expr/274094#274094
 *
 * @param this Types the called context this to a string in which the search will be conducted
 * @param regex A regex or string to match
 * @param startpos A starting position from which the search will begin
 */
function regexIndexOf(regex, startpos) {
    if (startpos === void 0) { startpos = 0; }
    var indexOf = this.substring(startpos).search(regex);
    return (indexOf >= 0) ? (indexOf + (startpos)) : indexOf;
}
/**
 * Finds bounded blocks of markup bounded by divs, ensuring to match the ending div even with nested divs in the interstitial markup
 *
 * @param html HTML to search
 * @param boundaryStartPattern The starting pattern to find, typically a div with attribute
 * @param collector A func to take the found block and provide a way to form it into a useful return that is added into the return array
 */
function getBoundedDivMarkup(html, boundaryStartPattern, collector) {
    var blocks = [];
    if (html === undefined || html === null) {
        return blocks;
    }
    // remove some extra whitespace if present
    var cleanedHtml = html.replace(/[\t\r\n]/g, "");
    // find the first div
    var startIndex = regexIndexOf.call(cleanedHtml, boundaryStartPattern);
    if (startIndex < 0) {
        // we found no blocks in the supplied html
        return blocks;
    }
    // this loop finds each of the blocks
    while (startIndex > -1) {
        // we have one open div counting from the one found above using boundaryStartPattern so we need to ensure we find it's close
        var openCounter = 1;
        var searchIndex = startIndex + 1;
        var nextDivOpen = -1;
        var nextCloseDiv = -1;
        // this loop finds the </div> tag that matches the opening of the control
        while (true) {
            // find both the next opening and closing div tags from our current searching index
            nextDivOpen = regexIndexOf.call(cleanedHtml, /<div[^>]*>/i, searchIndex);
            nextCloseDiv = regexIndexOf.call(cleanedHtml, /<\/div>/i, searchIndex);
            if (nextDivOpen < 0) {
                // we have no more opening divs, just set this to simplify checks below
                nextDivOpen = cleanedHtml.length + 1;
            }
            // determine which we found first, then increment or decrement our counter
            // and set the location to begin searching again
            if (nextDivOpen < nextCloseDiv) {
                openCounter++;
                searchIndex = nextDivOpen + 1;
            }
            else if (nextCloseDiv < nextDivOpen) {
                openCounter--;
                searchIndex = nextCloseDiv + 1;
            }
            // once we have no open divs back to the level of the opening control div
            // meaning we have all of the markup we intended to find
            if (openCounter === 0) {
                // get the bounded markup, +6 is the size of the ending </div> tag
                var markup = cleanedHtml.substring(startIndex, nextCloseDiv + 6).trim();
                // save the control data we found to the array
                blocks.push(collector(markup));
                // get out of our while loop
                break;
            }
            if (openCounter > 1000 || openCounter < 0) {
                // this is an arbitrary cut-off but likely we will not have 1000 nested divs
                // something has gone wrong above and we are probably stuck in our while loop
                // let's get out of our while loop and not hang everything
                throw Error("getBoundedDivMarkup exceeded depth parameters.");
            }
        }
        // get the start of the next control
        startIndex = regexIndexOf.call(cleanedHtml, boundaryStartPattern, nextCloseDiv);
    }
    return blocks;
}
/**
 * Normalizes the order value for all the sections, columns, and controls to be 1 based and stepped (1, 2, 3...)
 *
 * @param collection The collection to normalize
 */
function reindex(collection) {
    for (var i = 0; i < collection.length; i++) {
        collection[i].order = i + 1;
        if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(collection[i], "columns")) {
            reindex(collection[i].columns);
        }
        else if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(collection[i], "controls")) {
            reindex(collection[i].controls);
        }
    }
}
/**
 * Represents the data and methods associated with client side "modern" pages
 */
var ClientSidePage = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ClientSidePage, _super);
    /**
     * Creates a new instance of the ClientSidePage class
     *
     * @param baseUrl The url or SharePointQueryable which forms the parent of this web collection
     * @param commentsDisabled Indicates if comments are disabled, not valid until load is called
     */
    function ClientSidePage(file, sections, commentsDisabled) {
        if (sections === void 0) { sections = []; }
        if (commentsDisabled === void 0) { commentsDisabled = false; }
        var _this = _super.call(this, file) || this;
        _this.sections = sections;
        _this.commentsDisabled = commentsDisabled;
        return _this;
    }
    /**
     * Creates a new blank page within the supplied library
     *
     * @param library The library in which to create the page
     * @param pageName Filename of the page, such as "page.aspx"
     * @param title The display title of the page
     * @param pageLayoutType Layout type of the page to use
     */
    ClientSidePage.create = function (library, pageName, title, pageLayoutType) {
        if (pageLayoutType === void 0) { pageLayoutType = "Article"; }
        // see if file exists, if not create it
        return library.rootFolder.files.select("Name").filter("Name eq '" + pageName + "'").get().then(function (fs) {
            if (fs.length > 0) {
                throw Error("A file with the name '" + pageName + "' already exists in the library '" + library.toUrl() + "'.");
            }
            // get our server relative path
            return library.rootFolder.select("ServerRelativePath").get().then(function (path) {
                var pageServerRelPath = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["combine"])("/", path.ServerRelativePath.DecodedUrl, pageName);
                // add the template file
                return library.rootFolder.files.addTemplateFile(pageServerRelPath, TemplateFileType.ClientSidePage).then(function (far) {
                    // get the item associated with the file
                    return far.file.getItem().then(function (i) {
                        // update the item to have the correct values to create the client side page
                        return i.update({
                            BannerImageUrl: {
                                Url: "/_layouts/15/images/sitepagethumbnail.png",
                            },
                            CanvasContent1: "",
                            ClientSideApplicationId: "b6917cb1-93a0-4b97-a84d-7cf49975d4ec",
                            ContentTypeId: "0x0101009D1CB255DA76424F860D91F20E6C4118",
                            PageLayoutType: pageLayoutType,
                            PromotedState: 0 /* NotPromoted */,
                            Title: title,
                        }).then(function (iar) { return new ClientSidePage(iar.item.file, iar.item.CommentsDisabled); });
                    });
                });
            });
        });
    };
    /**
     * Creates a new ClientSidePage instance from the provided html content string
     *
     * @param html HTML markup representing the page
     */
    ClientSidePage.fromFile = function (file) {
        var page = new ClientSidePage(file);
        return page.load().then(function (_) { return page; });
    };
    /**
     * Converts a json object to an escaped string appropriate for use in attributes when storing client-side controls
     *
     * @param json The json object to encode into a string
     */
    ClientSidePage.jsonToEscapedString = function (json) {
        return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(json)
            .replace(/"/g, "&quot;")
            .replace(/:/g, "&#58;")
            .replace(/{/g, "&#123;")
            .replace(/}/g, "&#125;")
            .replace(/\[/g, "\[")
            .replace(/\]/g, "\]")
            .replace(/\./g, "\.");
    };
    /**
     * Converts an escaped string from a client-side control attribute to a json object
     *
     * @param escapedString
     */
    ClientSidePage.escapedStringToJson = function (escapedString) {
        var unespace = function (escaped) {
            var mapDict = [
                [/&quot;/g, "\""], [/&#58;/g, ":"], [/&#123;/g, "{"], [/&#125;/g, "}"],
                [/\\\\/g, "\\"], [/\\\?/g, "?"], [/\\\./g, "."], [/\\\[/g, "["], [/\\\]/g, "]"],
                [/\\\(/g, "("], [/\\\)/g, ")"], [/\\\|/g, "|"], [/\\\+/g, "+"],
            ];
            return mapDict.reduce(function (r, m) { return r.replace(m[0], m[1]); }, escaped);
        };
        return JSON.parse(unespace(escapedString));
    };
    /**
     * Add a section to this page
     */
    ClientSidePage.prototype.addSection = function () {
        var section = new CanvasSection(this, getNextOrder(this.sections));
        this.sections.push(section);
        return section;
    };
    /**
     * Converts this page's content to html markup
     */
    ClientSidePage.prototype.toHtml = function () {
        // trigger reindex of the entire tree
        reindex(this.sections);
        var html = [];
        html.push("<div>");
        for (var i = 0; i < this.sections.length; i++) {
            html.push(this.sections[i].toHtml());
        }
        html.push("</div>");
        return html.join("");
    };
    /**
     * Loads this page instance's content from the supplied html
     *
     * @param html html string representing the page's content
     */
    ClientSidePage.prototype.fromHtml = function (html) {
        var _this = this;
        // reset sections
        this.sections = [];
        // gather our controls from the supplied html
        getBoundedDivMarkup(html, /<div\b[^>]*data-sp-canvascontrol[^>]*?>/i, function (markup) {
            // get the control type
            var ct = /controlType&quot;&#58;(\d*?),/i.exec(markup);
            // if no control type is present this is a column which we give type 0 to let us process it
            var controlType = ct == null || ct.length < 2 ? 0 : parseInt(ct[1], 10);
            var control = null;
            switch (controlType) {
                case 0:
                    // empty canvas column
                    control = new CanvasColumn(null, 0);
                    control.fromHtml(markup);
                    _this.mergeColumnToTree(control);
                    break;
                case 3:
                    // client side webpart
                    control = new ClientSideWebpart("");
                    control.fromHtml(markup);
                    _this.mergePartToTree(control);
                    break;
                case 4:
                    // client side text
                    control = new ClientSideText();
                    control.fromHtml(markup);
                    _this.mergePartToTree(control);
                    break;
            }
        });
        // refresh all the orders within the tree
        reindex(this.sections);
        return this;
    };
    /**
     * Loads this page's content from the server
     */
    ClientSidePage.prototype.load = function () {
        var _this = this;
        return this.getItem("CanvasContent1", "CommentsDisabled").then(function (item) {
            _this.fromHtml(item.CanvasContent1);
            _this.commentsDisabled = item.CommentsDisabled;
        });
    };
    /**
     * Persists the content changes (sections, columns, and controls)
     */
    ClientSidePage.prototype.save = function () {
        return this.updateProperties({ CanvasContent1: this.toHtml() });
    };
    /**
     * Enables comments on this page
     */
    ClientSidePage.prototype.enableComments = function () {
        var _this = this;
        return this.setCommentsOn(true).then(function (r) {
            _this.commentsDisabled = false;
            return r;
        });
    };
    /**
     * Disables comments on this page
     */
    ClientSidePage.prototype.disableComments = function () {
        var _this = this;
        return this.setCommentsOn(false).then(function (r) {
            _this.commentsDisabled = true;
            return r;
        });
    };
    /**
     * Finds a control by the specified instance id
     *
     * @param id Instance id of the control to find
     */
    ClientSidePage.prototype.findControlById = function (id) {
        return this.findControl(function (c) { return c.id === id; });
    };
    /**
     * Finds a control within this page's control tree using the supplied predicate
     *
     * @param predicate Takes a control and returns true or false, if true that control is returned by findControl
     */
    ClientSidePage.prototype.findControl = function (predicate) {
        // check all sections
        for (var i = 0; i < this.sections.length; i++) {
            // check all columns
            for (var j = 0; j < this.sections[i].columns.length; j++) {
                // check all controls
                for (var k = 0; k < this.sections[i].columns[j].controls.length; k++) {
                    // check to see if the predicate likes this control
                    if (predicate(this.sections[i].columns[j].controls[k])) {
                        return this.sections[i].columns[j].controls[k];
                    }
                }
            }
        }
        // we found nothing so give nothing back
        return null;
    };
    /**
     * Sets the comments flag for a page
     *
     * @param on If true comments are enabled, false they are disabled
     */
    ClientSidePage.prototype.setCommentsOn = function (on) {
        return this.getItem().then(function (i) {
            var updater = new Item(i, "SetCommentsDisabled(" + !on + ")");
            return updater.update({});
        });
    };
    /**
     * Merges the control into the tree of sections and columns for this page
     *
     * @param control The control to merge
     */
    ClientSidePage.prototype.mergePartToTree = function (control) {
        var section = null;
        var column = null;
        var sections = this.sections.filter(function (s) { return s.order === control.controlData.position.zoneIndex; });
        if (sections.length < 1) {
            section = new CanvasSection(this, control.controlData.position.zoneIndex);
            this.sections.push(section);
        }
        else {
            section = sections[0];
        }
        var columns = section.columns.filter(function (c) { return c.order === control.controlData.position.sectionIndex; });
        if (columns.length < 1) {
            column = new CanvasColumn(section, control.controlData.position.sectionIndex, control.controlData.position.sectionFactor);
            section.columns.push(column);
        }
        else {
            column = columns[0];
        }
        control.column = column;
        column.addControl(control);
    };
    /**
     * Merges the supplied column into the tree
     *
     * @param column Column to merge
     * @param position The position data for the column
     */
    ClientSidePage.prototype.mergeColumnToTree = function (column) {
        var section = null;
        var sections = this.sections.filter(function (s) { return s.order === column.controlData.position.zoneIndex; });
        if (sections.length < 1) {
            section = new CanvasSection(this, column.controlData.position.zoneIndex);
            this.sections.push(section);
        }
        else {
            section = sections[0];
        }
        column.section = section;
        section.columns.push(column);
    };
    /**
     * Updates the properties of the underlying ListItem associated with this ClientSidePage
     *
     * @param properties Set of properties to update
     * @param eTag Value used in the IF-Match header, by default "*"
     */
    ClientSidePage.prototype.updateProperties = function (properties, eTag) {
        if (eTag === void 0) { eTag = "*"; }
        return this.getItem().then(function (i) { return i.update(properties, eTag); });
    };
    return ClientSidePage;
}(File));
var CanvasSection = /** @class */ (function () {
    function CanvasSection(page, order, columns) {
        if (columns === void 0) { columns = []; }
        this.page = page;
        this.order = order;
        this.columns = columns;
        this._memId = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getGUID"])();
    }
    Object.defineProperty(CanvasSection.prototype, "defaultColumn", {
        /**
         * Default column (this.columns[0]) for this section
         */
        get: function () {
            if (this.columns.length < 1) {
                this.addColumn(12);
            }
            return this.columns[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a new column to this section
     */
    CanvasSection.prototype.addColumn = function (factor) {
        var column = new CanvasColumn(this, getNextOrder(this.columns), factor);
        this.columns.push(column);
        return column;
    };
    /**
     * Adds a control to the default column for this section
     *
     * @param control Control to add to the default column
     */
    CanvasSection.prototype.addControl = function (control) {
        this.defaultColumn.addControl(control);
        return this;
    };
    CanvasSection.prototype.toHtml = function () {
        var html = [];
        for (var i = 0; i < this.columns.length; i++) {
            html.push(this.columns[i].toHtml());
        }
        return html.join("");
    };
    /**
     * Removes this section and all contained columns and controls from the collection
     */
    CanvasSection.prototype.remove = function () {
        var _this = this;
        this.page.sections = this.page.sections.filter(function (section) { return section._memId !== _this._memId; });
        reindex(this.page.sections);
    };
    return CanvasSection;
}());
var CanvasControl = /** @class */ (function () {
    function CanvasControl(controlType, dataVersion, column, order, id, controlData) {
        if (column === void 0) { column = null; }
        if (order === void 0) { order = 1; }
        if (id === void 0) { id = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getGUID"])(); }
        if (controlData === void 0) { controlData = null; }
        this.controlType = controlType;
        this.dataVersion = dataVersion;
        this.column = column;
        this.order = order;
        this.id = id;
        this.controlData = controlData;
    }
    Object.defineProperty(CanvasControl.prototype, "jsonData", {
        /**
         * Value of the control's "data-sp-controldata" attribute
         */
        get: function () {
            return ClientSidePage.jsonToEscapedString(this.getControlData());
        },
        enumerable: true,
        configurable: true
    });
    CanvasControl.prototype.fromHtml = function (html) {
        this.controlData = ClientSidePage.escapedStringToJson(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getAttrValueFromString"])(html, "data-sp-controldata"));
        this.dataVersion = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getAttrValueFromString"])(html, "data-sp-canvasdataversion");
        this.controlType = this.controlData.controlType;
        this.id = this.controlData.id;
    };
    return CanvasControl;
}());
var CanvasColumn = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(CanvasColumn, _super);
    function CanvasColumn(section, order, factor, controls, dataVersion) {
        if (factor === void 0) { factor = 12; }
        if (controls === void 0) { controls = []; }
        if (dataVersion === void 0) { dataVersion = "1.0"; }
        var _this = _super.call(this, 0, dataVersion) || this;
        _this.section = section;
        _this.order = order;
        _this.factor = factor;
        _this.controls = controls;
        return _this;
    }
    CanvasColumn.prototype.addControl = function (control) {
        control.column = this;
        this.controls.push(control);
        return this;
    };
    CanvasColumn.prototype.getControl = function (index) {
        return this.controls[index];
    };
    CanvasColumn.prototype.toHtml = function () {
        var html = [];
        if (this.controls.length < 1) {
            html.push("<div data-sp-canvascontrol=\"\" data-sp-canvasdataversion=\"" + this.dataVersion + "\" data-sp-controldata=\"" + this.jsonData + "\"></div>");
        }
        else {
            for (var i = 0; i < this.controls.length; i++) {
                html.push(this.controls[i].toHtml(i + 1));
            }
        }
        return html.join("");
    };
    CanvasColumn.prototype.fromHtml = function (html) {
        _super.prototype.fromHtml.call(this, html);
        this.controlData = ClientSidePage.escapedStringToJson(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getAttrValueFromString"])(html, "data-sp-controldata"));
        this.factor = this.controlData.position.sectionFactor;
        this.order = this.controlData.position.sectionIndex;
    };
    CanvasColumn.prototype.getControlData = function () {
        return {
            displayMode: 2,
            position: {
                sectionFactor: this.factor,
                sectionIndex: this.order,
                zoneIndex: this.section.order,
            },
        };
    };
    /**
     * Removes this column and all contained controls from the collection
     */
    CanvasColumn.prototype.remove = function () {
        var _this = this;
        this.section.columns = this.section.columns.filter(function (column) { return column.id !== _this.id; });
        reindex(this.column.controls);
    };
    return CanvasColumn;
}(CanvasControl));
/**
 * Abstract class with shared functionality for parts
 */
var ClientSidePart = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ClientSidePart, _super);
    function ClientSidePart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Removes this column and all contained controls from the collection
     */
    ClientSidePart.prototype.remove = function () {
        var _this = this;
        this.column.controls = this.column.controls.filter(function (control) { return control.id !== _this.id; });
        reindex(this.column.controls);
    };
    return ClientSidePart;
}(CanvasControl));
var ClientSideText = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ClientSideText, _super);
    function ClientSideText(text) {
        if (text === void 0) { text = ""; }
        var _this = _super.call(this, 4, "1.0") || this;
        _this.text = text;
        return _this;
    }
    Object.defineProperty(ClientSideText.prototype, "text", {
        /**
         * The text markup of this control
         */
        get: function () {
            return this._text;
        },
        set: function (text) {
            if (!text.startsWith("<p>")) {
                text = "<p>" + text + "</p>";
            }
            this._text = text;
        },
        enumerable: true,
        configurable: true
    });
    ClientSideText.prototype.getControlData = function () {
        return {
            controlType: this.controlType,
            editorType: "CKEditor",
            id: this.id,
            position: {
                controlIndex: this.order,
                sectionFactor: this.column.factor,
                sectionIndex: this.column.order,
                zoneIndex: this.column.section.order,
            },
        };
    };
    ClientSideText.prototype.toHtml = function (index) {
        // set our order to the value passed in
        this.order = index;
        var html = [];
        html.push("<div data-sp-canvascontrol=\"\" data-sp-canvasdataversion=\"" + this.dataVersion + "\" data-sp-controldata=\"" + this.jsonData + "\">");
        html.push("<div data-sp-rte=\"\">");
        html.push("" + this.text);
        html.push("</div>");
        html.push("</div>");
        return html.join("");
    };
    ClientSideText.prototype.fromHtml = function (html) {
        var _this = this;
        _super.prototype.fromHtml.call(this, html);
        this.text = "";
        getBoundedDivMarkup(html, /<div[^>]*data-sp-rte[^>]*>/i, function (s) {
            // now we need to grab the inner text between the divs
            var match = /<div[^>]*data-sp-rte[^>]*>(.*?)<\/div>$/i.exec(s);
            _this.text = match.length > 1 ? match[1] : "";
        });
    };
    return ClientSideText;
}(ClientSidePart));
var ClientSideWebpart = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ClientSideWebpart, _super);
    function ClientSideWebpart(title, description, propertieJson, webPartId, htmlProperties, serverProcessedContent, canvasDataVersion) {
        if (description === void 0) { description = ""; }
        if (propertieJson === void 0) { propertieJson = {}; }
        if (webPartId === void 0) { webPartId = ""; }
        if (htmlProperties === void 0) { htmlProperties = ""; }
        if (serverProcessedContent === void 0) { serverProcessedContent = null; }
        if (canvasDataVersion === void 0) { canvasDataVersion = "1.0"; }
        var _this = _super.call(this, 3, "1.0") || this;
        _this.title = title;
        _this.description = description;
        _this.propertieJson = propertieJson;
        _this.webPartId = webPartId;
        _this.htmlProperties = htmlProperties;
        _this.serverProcessedContent = serverProcessedContent;
        _this.canvasDataVersion = canvasDataVersion;
        return _this;
    }
    ClientSideWebpart.fromComponentDef = function (definition) {
        var part = new ClientSideWebpart("");
        part.import(definition);
        return part;
    };
    ClientSideWebpart.prototype.import = function (component) {
        this.webPartId = component.Id.replace(/^\{|\}$/g, "").toLowerCase();
        var manifest = JSON.parse(component.Manifest);
        this.title = manifest.preconfiguredEntries[0].title.default;
        this.description = manifest.preconfiguredEntries[0].description.default;
        this.dataVersion = "1.0";
        this.propertieJson = this.parseJsonProperties(manifest.preconfiguredEntries[0].properties);
    };
    ClientSideWebpart.prototype.setProperties = function (properties) {
        this.propertieJson = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.propertieJson, properties);
        return this;
    };
    ClientSideWebpart.prototype.getProperties = function () {
        return this.propertieJson;
    };
    ClientSideWebpart.prototype.toHtml = function (index) {
        // set our order to the value passed in
        this.order = index;
        // will form the value of the data-sp-webpartdata attribute
        var data = {
            dataVersion: this.dataVersion,
            description: this.description,
            id: this.webPartId,
            instanceId: this.id,
            properties: this.propertieJson,
            serverProcessedContent: this.serverProcessedContent,
            title: this.title,
        };
        var html = [];
        html.push("<div data-sp-canvascontrol=\"\" data-sp-canvasdataversion=\"" + this.canvasDataVersion + "\" data-sp-controldata=\"" + this.jsonData + "\">");
        html.push("<div data-sp-webpart=\"\" data-sp-webpartdataversion=\"" + this.dataVersion + "\" data-sp-webpartdata=\"" + ClientSidePage.jsonToEscapedString(data) + "\">");
        html.push("<div data-sp-componentid>");
        html.push(this.webPartId);
        html.push("</div>");
        html.push("<div data-sp-htmlproperties=\"\">");
        html.push(this.renderHtmlProperties());
        html.push("</div>");
        html.push("</div>");
        html.push("</div>");
        return html.join("");
    };
    ClientSideWebpart.prototype.fromHtml = function (html) {
        _super.prototype.fromHtml.call(this, html);
        var webPartData = ClientSidePage.escapedStringToJson(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getAttrValueFromString"])(html, "data-sp-webpartdata"));
        this.title = webPartData.title;
        this.description = webPartData.description;
        this.webPartId = webPartData.id;
        this.canvasDataVersion = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getAttrValueFromString"])(html, "data-sp-canvasdataversion").replace(/\\\./, ".");
        this.dataVersion = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getAttrValueFromString"])(html, "data-sp-webpartdataversion").replace(/\\\./, ".");
        this.setProperties(webPartData.properties);
        if (webPartData.serverProcessedContent !== undefined) {
            this.serverProcessedContent = webPartData.serverProcessedContent;
        }
        // get our html properties
        var htmlProps = getBoundedDivMarkup(html, /<div\b[^>]*data-sp-htmlproperties[^>]*?>/i, function (markup) {
            return markup.replace(/^<div\b[^>]*data-sp-htmlproperties[^>]*?>/i, "").replace(/<\/div>$/i, "");
        });
        this.htmlProperties = htmlProps.length > 0 ? htmlProps[0] : "";
    };
    ClientSideWebpart.prototype.getControlData = function () {
        return {
            controlType: this.controlType,
            id: this.id,
            position: {
                controlIndex: this.order,
                sectionFactor: this.column.factor,
                sectionIndex: this.column.order,
                zoneIndex: this.column.section.order,
            },
            webPartId: this.webPartId,
        };
    };
    ClientSideWebpart.prototype.renderHtmlProperties = function () {
        var html = [];
        if (this.serverProcessedContent === undefined || this.serverProcessedContent === null) {
            html.push(this.htmlProperties);
        }
        else if (this.serverProcessedContent !== undefined) {
            if (this.serverProcessedContent.searchablePlainTexts !== undefined) {
                var keys = Object.keys(this.serverProcessedContent.searchablePlainTexts);
                for (var i = 0; i < keys.length; i++) {
                    html.push("<div data-sp-prop-name=\"" + keys[i] + "\" data-sp-searchableplaintext=\"true\">");
                    html.push(this.serverProcessedContent.searchablePlainTexts[keys[i]]);
                    html.push("</div>");
                }
            }
            if (this.serverProcessedContent.imageSources !== undefined) {
                var keys = Object.keys(this.serverProcessedContent.imageSources);
                for (var i = 0; i < keys.length; i++) {
                    html.push("<img data-sp-prop-name=\"" + keys[i] + "\" src=\"" + this.serverProcessedContent.imageSources[keys[i]] + "\" />");
                }
            }
            if (this.serverProcessedContent.links !== undefined) {
                var keys = Object.keys(this.serverProcessedContent.links);
                for (var i = 0; i < keys.length; i++) {
                    html.push("<a data-sp-prop-name=\"" + keys[i] + "\" href=\"" + this.serverProcessedContent.links[keys[i]] + "\"></a>");
                }
            }
        }
        return html.join("");
    };
    ClientSideWebpart.prototype.parseJsonProperties = function (props) {
        // If the web part has the serverProcessedContent property then keep this one as it might be needed as input to render the web part HTML later on
        if (props.webPartData !== undefined && props.webPartData.serverProcessedContent !== undefined) {
            this.serverProcessedContent = props.webPartData.serverProcessedContent;
        }
        else if (props.serverProcessedContent !== undefined) {
            this.serverProcessedContent = props.serverProcessedContent;
        }
        else {
            this.serverProcessedContent = null;
        }
        if (props.webPartData !== undefined && props.webPartData.properties !== undefined) {
            return props.webPartData.properties;
        }
        else if (props.properties !== undefined) {
            return props.properties;
        }
        else {
            return props;
        }
    };
    return ClientSideWebpart;
}(ClientSidePart));

/**
 * Represents a collection of navigation nodes
 *
 */
var NavigationNodes = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(NavigationNodes, _super);
    function NavigationNodes() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a navigation node by id
     *
     * @param id The id of the node
     */
    NavigationNodes.prototype.getById = function (id) {
        var node = new NavigationNode(this);
        node.concat("(" + id + ")");
        return node;
    };
    /**
     * Adds a new node to the collection
     *
     * @param title Display name of the node
     * @param url The url of the node
     * @param visible If true the node is visible, otherwise it is hidden (default: true)
     */
    NavigationNodes.prototype.add = function (title, url, visible) {
        var _this = this;
        if (visible === void 0) { visible = true; }
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.NavigationNode"), {
            IsVisible: visible,
            Title: title,
            Url: url,
        }));
        return this.clone(NavigationNodes, null).postCore({ body: postBody }).then(function (data) {
            return {
                data: data,
                node: _this.getById(data.Id),
            };
        });
    };
    /**
     * Moves a node to be after another node in the navigation
     *
     * @param nodeId Id of the node to move
     * @param previousNodeId Id of the node after which we move the node specified by nodeId
     */
    NavigationNodes.prototype.moveAfter = function (nodeId, previousNodeId) {
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            nodeId: nodeId,
            previousNodeId: previousNodeId,
        });
        return this.clone(NavigationNodes, "MoveAfter").postCore({ body: postBody });
    };
    return NavigationNodes;
}(SharePointQueryableCollection));
/**
 * Represents an instance of a navigation node
 *
 */
var NavigationNode = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(NavigationNode, _super);
    function NavigationNode() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(NavigationNode.prototype, "children", {
        /**
         * Represents the child nodes of this node
         */
        get: function () {
            return new NavigationNodes(this, "Children");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Deletes this node and any child nodes
     */
    NavigationNode.prototype.delete = function () {
        return _super.prototype.deleteCore.call(this);
    };
    return NavigationNode;
}(SharePointQueryableInstance));
/**
 * Exposes the navigation components
 *
 */
var Navigation = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Navigation, _super);
    function Navigation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Navigation.prototype, "quicklaunch", {
        /**
         * Gets the quicklaunch navigation nodes for the current context
         *
         */
        get: function () {
            return new NavigationNodes(this, "quicklaunch");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Navigation.prototype, "topNavigationBar", {
        /**
         * Gets the top bar navigation nodes for the current context
         *
         */
        get: function () {
            return new NavigationNodes(this, "topnavigationbar");
        },
        enumerable: true,
        configurable: true
    });
    Navigation = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("navigation")
    ], Navigation);
    return Navigation;
}(SharePointQueryable));
/**
 * Represents the top level navigation service
 */
var NavigationService = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(NavigationService, _super);
    function NavigationService(path) {
        if (path === void 0) { path = null; }
        return _super.call(this, "_api/navigation", path) || this;
    }
    /**
     * The MenuState service operation returns a Menu-State (dump) of a SiteMapProvider on a site.
     *
     * @param menuNodeKey MenuNode.Key of the start node within the SiteMapProvider If no key is provided the SiteMapProvider.RootNode will be the root of the menu state.
     * @param depth Depth of the dump. If no value is provided a dump with the depth of 10 is returned
     * @param mapProviderName The name identifying the SiteMapProvider to be used
     * @param customProperties comma seperated list of custom properties to be returned.
     */
    NavigationService.prototype.getMenuState = function (menuNodeKey, depth, mapProviderName, customProperties) {
        if (menuNodeKey === void 0) { menuNodeKey = null; }
        if (depth === void 0) { depth = 10; }
        if (mapProviderName === void 0) { mapProviderName = null; }
        if (customProperties === void 0) { customProperties = null; }
        return (new NavigationService("MenuState")).postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                customProperties: customProperties,
                depth: depth,
                mapProviderName: mapProviderName,
                menuNodeKey: menuNodeKey,
            }),
        });
    };
    /**
     * Tries to get a SiteMapNode.Key for a given URL within a site collection.
     *
     * @param currentUrl A url representing the SiteMapNode
     * @param mapProviderName The name identifying the SiteMapProvider to be used
     */
    NavigationService.prototype.getMenuNodeKey = function (currentUrl, mapProviderName) {
        if (mapProviderName === void 0) { mapProviderName = null; }
        return (new NavigationService("MenuNodeKey")).postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                currentUrl: currentUrl,
                mapProviderName: mapProviderName,
            }),
        });
    };
    return NavigationService;
}(SharePointQueryable));

/**
 * Describes regional settings ODada object
 */
var RegionalSettings = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(RegionalSettings, _super);
    function RegionalSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(RegionalSettings.prototype, "installedLanguages", {
        /**
         * Gets the collection of languages used in a server farm.
         */
        get: function () {
            return new InstalledLanguages(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RegionalSettings.prototype, "globalInstalledLanguages", {
        /**
         * Gets the collection of language packs that are installed on the server.
         */
        get: function () {
            return new InstalledLanguages(this, "globalinstalledlanguages");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RegionalSettings.prototype, "timeZone", {
        /**
         * Gets time zone
         */
        get: function () {
            return new TimeZone(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RegionalSettings.prototype, "timeZones", {
        /**
         * Gets time zones
         */
        get: function () {
            return new TimeZones(this);
        },
        enumerable: true,
        configurable: true
    });
    RegionalSettings = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("regionalsettings")
    ], RegionalSettings);
    return RegionalSettings;
}(SharePointQueryableInstance));
/**
 * Describes installed languages ODada queriable collection
 */
var InstalledLanguages = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(InstalledLanguages, _super);
    function InstalledLanguages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InstalledLanguages = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("installedlanguages")
    ], InstalledLanguages);
    return InstalledLanguages;
}(SharePointQueryableCollection));
/**
 * Describes TimeZone ODada object
 */
var TimeZone = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(TimeZone, _super);
    function TimeZone() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeZone_1 = TimeZone;
    /**
     * Gets an Local Time by UTC Time
     *
     * @param utcTime UTC Time as Date or ISO String
     */
    TimeZone.prototype.utcToLocalTime = function (utcTime) {
        var dateIsoString;
        if (typeof utcTime === "string") {
            dateIsoString = utcTime;
        }
        else {
            dateIsoString = utcTime.toISOString();
        }
        return this.clone(TimeZone_1, "utctolocaltime('" + dateIsoString + "')")
            .postCore()
            .then(function (res) { return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(res, "UTCToLocalTime") ? res.UTCToLocalTime : res; });
    };
    /**
     * Gets an UTC Time by Local Time
     *
     * @param localTime Local Time as Date or ISO String
     */
    TimeZone.prototype.localTimeToUTC = function (localTime) {
        var dateIsoString;
        if (typeof localTime === "string") {
            dateIsoString = localTime;
        }
        else {
            dateIsoString = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["dateAdd"])(localTime, "minute", localTime.getTimezoneOffset() * -1).toISOString();
        }
        return this.clone(TimeZone_1, "localtimetoutc('" + dateIsoString + "')")
            .postCore()
            .then(function (res) { return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(res, "LocalTimeToUTC") ? res.LocalTimeToUTC : res; });
    };
    var TimeZone_1;
    TimeZone = TimeZone_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("timezone")
    ], TimeZone);
    return TimeZone;
}(SharePointQueryableInstance));
/**
 * Describes time zones queriable collection
 */
var TimeZones = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(TimeZones, _super);
    function TimeZones() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeZones_1 = TimeZones;
    // https://msdn.microsoft.com/en-us/library/office/jj247008.aspx - timezones ids
    /**
     * Gets an TimeZone by id
     *
     * @param id The integer id of the timezone to retrieve
     */
    TimeZones.prototype.getById = function (id) {
        // do the post and merge the result into a TimeZone instance so the data and methods are available
        return this.clone(TimeZones_1, "GetById(" + id + ")").postCore({}, spODataEntity(TimeZone));
    };
    var TimeZones_1;
    TimeZones = TimeZones_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("timezones")
    ], TimeZones);
    return TimeZones;
}(SharePointQueryableCollection));

var funcs = new Map([
    ["text", "Querytext"],
    ["template", "QueryTemplate"],
    ["sourceId", "SourceId"],
    ["trimDuplicatesIncludeId", ""],
    ["startRow", ""],
    ["rowLimit", ""],
    ["rankingModelId", ""],
    ["rowsPerPage", ""],
    ["selectProperties", ""],
    ["culture", ""],
    ["timeZoneId", ""],
    ["refinementFilters", ""],
    ["refiners", ""],
    ["hiddenConstraints", ""],
    ["sortList", ""],
    ["timeout", ""],
    ["hithighlightedProperties", ""],
    ["clientType", ""],
    ["personalizationData", ""],
    ["resultsURL", ""],
    ["queryTag", ""],
    ["properties", ""],
    ["queryTemplatePropertiesUrl", ""],
    ["reorderingRules", ""],
    ["hitHighlightedMultivaluePropertyLimit", ""],
    ["collapseSpecification", ""],
    ["uiLanguage", ""],
    ["desiredSnippetLength", ""],
    ["maxSnippetLength", ""],
    ["summaryLength", ""],
]);
var props = new Map([]);
function toPropCase(str) {
    return str.replace(/^(.)/, function ($1) { return $1.toUpperCase(); });
}
/**
 * Creates a new instance of the SearchQueryBuilder
 *
 * @param queryText Initial query text
 * @param _query Any initial query configuration
 */
function SearchQueryBuilder(queryText, _query) {
    if (queryText === void 0) { queryText = ""; }
    if (_query === void 0) { _query = {}; }
    return new Proxy({
        query: Object.assign({
            Querytext: queryText,
        }, _query),
    }, {
        get: function (self, propertyKey, proxy) {
            var pk = propertyKey.toString();
            if (pk === "toSearchQuery") {
                return function () { return self.query; };
            }
            if (funcs.has(pk)) {
                return function () {
                    var value = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        value[_i] = arguments[_i];
                    }
                    var mappedPk = funcs.get(pk);
                    self.query[mappedPk.length > 0 ? mappedPk : toPropCase(pk)] = value.length > 1 ? value : value[0];
                    return proxy;
                };
            }
            var propKey = props.has(pk) ? props.get(pk) : toPropCase(pk);
            self.query[propKey] = true;
            return proxy;
        },
    });
}
/**
 * Describes the search API
 *
 */
var Search = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Search, _super);
    function Search() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @returns Promise
     */
    Search.prototype.execute = function (queryInit) {
        var _this = this;
        var query = this.parseQuery(queryInit);
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            request: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("Microsoft.Office.Server.Search.REST.SearchRequest"), Object.assign({}, query, {
                HitHighlightedProperties: this.fixArrProp(query.HitHighlightedProperties),
                Properties: this.fixArrProp(query.Properties),
                RefinementFilters: this.fixArrProp(query.RefinementFilters),
                ReorderingRules: this.fixArrProp(query.ReorderingRules),
                SelectProperties: this.fixArrProp(query.SelectProperties),
                SortList: this.fixArrProp(query.SortList),
            })),
        });
        // if we are using caching with this search request, then we need to handle some work upfront to enable that
        if (this._useCaching) {
            // force use of the cache for this request if .usingCaching was called
            this._forceCaching = true;
            // because all the requests use the same url they would collide in the cache we use a special key
            var cacheKey = "PnPjs.SearchWithCaching(" + Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["getHashCode"])(postBody) + ")";
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["objectDefinedNotNull"])(this._cachingOptions)) {
                // if our key ends in the postquery url we overwrite it
                if (/\/_api\/search\/postquery$/i.test(this._cachingOptions.key)) {
                    this._cachingOptions.key = cacheKey;
                }
            }
            else {
                this._cachingOptions = new _pnp_odata__WEBPACK_IMPORTED_MODULE_3__["CachingOptions"](cacheKey);
            }
        }
        return this.postCore({ body: postBody }).then(function (data) { return new SearchResults(data, _this.toUrl(), query); });
    };
    /**
     * Fix array property
     *
     * @param prop property to fix for container struct
     */
    Search.prototype.fixArrProp = function (prop) {
        if (typeof prop === "undefined") {
            return ({ results: [] });
        }
        prop = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["isArray"])(prop) ? prop : [prop];
        return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(prop, "results") ? prop : { results: prop };
    };
    /**
     * Translates one of the query initializers into a SearchQuery instance
     *
     * @param query
     */
    Search.prototype.parseQuery = function (query) {
        var finalQuery;
        if (typeof query === "string") {
            finalQuery = { Querytext: query };
        }
        else if (query.toSearchQuery) {
            finalQuery = query.toSearchQuery();
        }
        else {
            finalQuery = query;
        }
        return finalQuery;
    };
    Search = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("_api/search/postquery")
    ], Search);
    return Search;
}(SharePointQueryableInstance));
/**
 * Describes the SearchResults class, which returns the formatted and raw version of the query response
 */
var SearchResults = /** @class */ (function () {
    /**
     * Creates a new instance of the SearchResult class
     *
     */
    function SearchResults(rawResponse, _url, _query, _raw, _primary) {
        if (_raw === void 0) { _raw = null; }
        if (_primary === void 0) { _primary = null; }
        this._url = _url;
        this._query = _query;
        this._raw = _raw;
        this._primary = _primary;
        this._raw = rawResponse.postquery ? rawResponse.postquery : rawResponse;
    }
    Object.defineProperty(SearchResults.prototype, "ElapsedTime", {
        get: function () {
            return this.RawSearchResults.ElapsedTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResults.prototype, "RowCount", {
        get: function () {
            return this.RawSearchResults.PrimaryQueryResult.RelevantResults.RowCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResults.prototype, "TotalRows", {
        get: function () {
            return this.RawSearchResults.PrimaryQueryResult.RelevantResults.TotalRows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResults.prototype, "TotalRowsIncludingDuplicates", {
        get: function () {
            return this.RawSearchResults.PrimaryQueryResult.RelevantResults.TotalRowsIncludingDuplicates;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResults.prototype, "RawSearchResults", {
        get: function () {
            return this._raw;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchResults.prototype, "PrimarySearchResults", {
        get: function () {
            if (this._primary === null) {
                this._primary = this.formatSearchResults(this._raw.PrimaryQueryResult.RelevantResults.Table.Rows);
            }
            return this._primary;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a page of results
     *
     * @param pageNumber Index of the page to return. Used to determine StartRow
     * @param pageSize Optional, items per page (default = 10)
     */
    SearchResults.prototype.getPage = function (pageNumber, pageSize) {
        // if we got all the available rows we don't have another page
        if (this.TotalRows < this.RowCount) {
            return Promise.resolve(null);
        }
        // if pageSize is supplied, then we use that regardless of any previous values
        // otherwise get the previous RowLimit or default to 10
        var rows = pageSize !== undefined ? pageSize : Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(this._query, "RowLimit") ? this._query.RowLimit : 10;
        var query = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(this._query, {
            RowLimit: rows,
            StartRow: rows * (pageNumber - 1),
        });
        // we have reached the end
        if (query.StartRow > this.TotalRows) {
            return Promise.resolve(null);
        }
        var search = new Search(this._url, null);
        return search.execute(query);
    };
    /**
     * Formats a search results array
     *
     * @param rawResults The array to process
     */
    SearchResults.prototype.formatSearchResults = function (rawResults) {
        var results = new Array();
        var tempResults = rawResults.results ? rawResults.results : rawResults;
        for (var _i = 0, tempResults_1 = tempResults; _i < tempResults_1.length; _i++) {
            var tempResult = tempResults_1[_i];
            var cells = tempResult.Cells.results ? tempResult.Cells.results : tempResult.Cells;
            results.push(cells.reduce(function (res, cell) {
                Object.defineProperty(res, cell.Key, {
                    configurable: false,
                    enumerable: true,
                    value: cell.Value,
                    writable: false,
                });
                return res;
            }, {}));
        }
        return results;
    };
    return SearchResults;
}());
/**
 * defines the SortDirection enum
 */
var SortDirection;
(function (SortDirection) {
    SortDirection[SortDirection["Ascending"] = 0] = "Ascending";
    SortDirection[SortDirection["Descending"] = 1] = "Descending";
    SortDirection[SortDirection["FQLFormula"] = 2] = "FQLFormula";
})(SortDirection || (SortDirection = {}));
/**
 * defines the ReorderingRuleMatchType  enum
 */
var ReorderingRuleMatchType;
(function (ReorderingRuleMatchType) {
    ReorderingRuleMatchType[ReorderingRuleMatchType["ResultContainsKeyword"] = 0] = "ResultContainsKeyword";
    ReorderingRuleMatchType[ReorderingRuleMatchType["TitleContainsKeyword"] = 1] = "TitleContainsKeyword";
    ReorderingRuleMatchType[ReorderingRuleMatchType["TitleMatchesKeyword"] = 2] = "TitleMatchesKeyword";
    ReorderingRuleMatchType[ReorderingRuleMatchType["UrlStartsWith"] = 3] = "UrlStartsWith";
    ReorderingRuleMatchType[ReorderingRuleMatchType["UrlExactlyMatches"] = 4] = "UrlExactlyMatches";
    ReorderingRuleMatchType[ReorderingRuleMatchType["ContentTypeIs"] = 5] = "ContentTypeIs";
    ReorderingRuleMatchType[ReorderingRuleMatchType["FileExtensionMatches"] = 6] = "FileExtensionMatches";
    ReorderingRuleMatchType[ReorderingRuleMatchType["ResultHasTag"] = 7] = "ResultHasTag";
    ReorderingRuleMatchType[ReorderingRuleMatchType["ManualCondition"] = 8] = "ManualCondition";
})(ReorderingRuleMatchType || (ReorderingRuleMatchType = {}));
/**
 * Specifies the type value for the property
 */
var QueryPropertyValueType;
(function (QueryPropertyValueType) {
    QueryPropertyValueType[QueryPropertyValueType["None"] = 0] = "None";
    QueryPropertyValueType[QueryPropertyValueType["StringType"] = 1] = "StringType";
    QueryPropertyValueType[QueryPropertyValueType["Int32Type"] = 2] = "Int32Type";
    QueryPropertyValueType[QueryPropertyValueType["BooleanType"] = 3] = "BooleanType";
    QueryPropertyValueType[QueryPropertyValueType["StringArrayType"] = 4] = "StringArrayType";
    QueryPropertyValueType[QueryPropertyValueType["UnSupportedType"] = 5] = "UnSupportedType";
})(QueryPropertyValueType || (QueryPropertyValueType = {}));
var SearchBuiltInSourceId = /** @class */ (function () {
    function SearchBuiltInSourceId() {
    }
    SearchBuiltInSourceId.Documents = "e7ec8cee-ded8-43c9-beb5-436b54b31e84";
    SearchBuiltInSourceId.ItemsMatchingContentType = "5dc9f503-801e-4ced-8a2c-5d1237132419";
    SearchBuiltInSourceId.ItemsMatchingTag = "e1327b9c-2b8c-4b23-99c9-3730cb29c3f7";
    SearchBuiltInSourceId.ItemsRelatedToCurrentUser = "48fec42e-4a92-48ce-8363-c2703a40e67d";
    SearchBuiltInSourceId.ItemsWithSameKeywordAsThisItem = "5c069288-1d17-454a-8ac6-9c642a065f48";
    SearchBuiltInSourceId.LocalPeopleResults = "b09a7990-05ea-4af9-81ef-edfab16c4e31";
    SearchBuiltInSourceId.LocalReportsAndDataResults = "203fba36-2763-4060-9931-911ac8c0583b";
    SearchBuiltInSourceId.LocalSharePointResults = "8413cd39-2156-4e00-b54d-11efd9abdb89";
    SearchBuiltInSourceId.LocalVideoResults = "78b793ce-7956-4669-aa3b-451fc5defebf";
    SearchBuiltInSourceId.Pages = "5e34578e-4d08-4edc-8bf3-002acf3cdbcc";
    SearchBuiltInSourceId.Pictures = "38403c8c-3975-41a8-826e-717f2d41568a";
    SearchBuiltInSourceId.Popular = "97c71db1-58ce-4891-8b64-585bc2326c12";
    SearchBuiltInSourceId.RecentlyChangedItems = "ba63bbae-fa9c-42c0-b027-9a878f16557c";
    SearchBuiltInSourceId.RecommendedItems = "ec675252-14fa-4fbe-84dd-8d098ed74181";
    SearchBuiltInSourceId.Wiki = "9479bf85-e257-4318-b5a8-81a180f5faa1";
    return SearchBuiltInSourceId;
}());

var SearchSuggest = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SearchSuggest, _super);
    function SearchSuggest() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SearchSuggest.prototype.execute = function (query) {
        this.mapQueryToQueryString(query);
        return this.get().then(function (response) {
            var mapper = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(response, "suggest") ? function (s) { return response.suggest[s].results; } : function (s) { return response[s]; };
            return {
                PeopleNames: mapper("PeopleNames"),
                PersonalResults: mapper("PersonalResults"),
                Queries: mapper("Queries"),
            };
        });
    };
    SearchSuggest.prototype.mapQueryToQueryString = function (query) {
        var _this = this;
        var setProp = function (q) { return function (checkProp) { return function (sp) {
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(q, checkProp)) {
                _this.query.set(sp, q[checkProp].toString());
            }
        }; }; };
        this.query.set("querytext", "'" + query.querytext + "'");
        var querySetter = setProp(query);
        querySetter("count")("inumberofquerysuggestions");
        querySetter("personalCount")("inumberofresultsuggestions");
        querySetter("preQuery")("fprequerysuggestions");
        querySetter("hitHighlighting")("fhithighlighting");
        querySetter("capitalize")("fcapitalizefirstletters");
        querySetter("culture")("culture");
        querySetter("stemming")("enablestemming");
        querySetter("includePeople")("showpeoplenamesuggestions");
        querySetter("queryRules")("enablequeryrules");
        querySetter("prefixMatch")("fprefixmatchallterms");
    };
    SearchSuggest = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("_api/search/suggest")
    ], SearchSuggest);
    return SearchSuggest;
}(SharePointQueryableInstance));

/**
 * Describes a collection of List objects
 *
 */
var Features = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Features, _super);
    function Features() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Features_1 = Features;
    /**
     * Adds a new list to the collection
     *
     * @param id The Id of the feature (GUID)
     * @param force If true the feature activation will be forced
     */
    Features.prototype.add = function (id, force) {
        var _this = this;
        if (force === void 0) { force = false; }
        return this.clone(Features_1, "add").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                featdefScope: 0,
                featureId: id,
                force: force,
            }),
        }).then(function (data) {
            return {
                data: data,
                feature: _this.getById(id),
            };
        });
    };
    /**
     * Gets a list from the collection by guid id
     *
     * @param id The Id of the feature (GUID)
     */
    Features.prototype.getById = function (id) {
        var feature = new Feature(this);
        feature.concat("('" + id + "')");
        return feature;
    };
    /**
     * Removes (deactivates) a feature from the collection
     *
     * @param id The Id of the feature (GUID)
     * @param force If true the feature deactivation will be forced
     */
    Features.prototype.remove = function (id, force) {
        if (force === void 0) { force = false; }
        return this.clone(Features_1, "remove").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                featureId: id,
                force: force,
            }),
        });
    };
    var Features_1;
    Features = Features_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("features")
    ], Features);
    return Features;
}(SharePointQueryableCollection));
var Feature = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Feature, _super);
    function Feature() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Removes (deactivates) a feature from the collection
     *
     * @param force If true the feature deactivation will be forced
     */
    Feature.prototype.deactivate = function (force) {
        var _this = this;
        if (force === void 0) { force = false; }
        var removeDependency = this.addBatchDependency();
        var idGet = new Feature(this).select("DefinitionId");
        return idGet.get().then(function (feature) {
            var promise = _this.getParent(Features, _this.parentUrl, "", _this.batch).remove(feature.DefinitionId, force);
            removeDependency();
            return promise;
        });
    };
    return Feature;
}(SharePointQueryableInstance));

var RelatedItemManagerImpl = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(RelatedItemManagerImpl, _super);
    function RelatedItemManagerImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RelatedItemManagerImpl_1 = RelatedItemManagerImpl;
    RelatedItemManagerImpl.FromUrl = function (url) {
        if (url === null) {
            return new RelatedItemManagerImpl_1("");
        }
        var index = url.indexOf("_api/");
        if (index > -1) {
            return new RelatedItemManagerImpl_1(url.substr(0, index));
        }
        return new RelatedItemManagerImpl_1(url);
    };
    RelatedItemManagerImpl.prototype.getRelatedItems = function (sourceListName, sourceItemId) {
        var query = this.clone(RelatedItemManagerImpl_1, null);
        query.concat(".GetRelatedItems");
        return query.postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                SourceItemID: sourceItemId,
                SourceListName: sourceListName,
            }),
        });
    };
    RelatedItemManagerImpl.prototype.getPageOneRelatedItems = function (sourceListName, sourceItemId) {
        var query = this.clone(RelatedItemManagerImpl_1, null);
        query.concat(".GetPageOneRelatedItems");
        return query.postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                SourceItemID: sourceItemId,
                SourceListName: sourceListName,
            }),
        });
    };
    RelatedItemManagerImpl.prototype.addSingleLink = function (sourceListName, sourceItemId, sourceWebUrl, targetListName, targetItemID, targetWebUrl, tryAddReverseLink) {
        if (tryAddReverseLink === void 0) { tryAddReverseLink = false; }
        var query = this.clone(RelatedItemManagerImpl_1, null);
        query.concat(".AddSingleLink");
        return query.postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                SourceItemID: sourceItemId,
                SourceListName: sourceListName,
                SourceWebUrl: sourceWebUrl,
                TargetItemID: targetItemID,
                TargetListName: targetListName,
                TargetWebUrl: targetWebUrl,
                TryAddReverseLink: tryAddReverseLink,
            }),
        });
    };
    /**
     * Adds a related item link from an item specified by list name and item id, to an item specified by url
     *
     * @param sourceListName The source list name or list id
     * @param sourceItemId The source item id
     * @param targetItemUrl The target item url
     * @param tryAddReverseLink If set to true try to add the reverse link (will not return error if it fails)
     */
    RelatedItemManagerImpl.prototype.addSingleLinkToUrl = function (sourceListName, sourceItemId, targetItemUrl, tryAddReverseLink) {
        if (tryAddReverseLink === void 0) { tryAddReverseLink = false; }
        var query = this.clone(RelatedItemManagerImpl_1, null);
        query.concat(".AddSingleLinkToUrl");
        return query.postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                SourceItemID: sourceItemId,
                SourceListName: sourceListName,
                TargetItemUrl: targetItemUrl,
                TryAddReverseLink: tryAddReverseLink,
            }),
        });
    };
    /**
     * Adds a related item link from an item specified by url, to an item specified by list name and item id
     *
     * @param sourceItemUrl The source item url
     * @param targetListName The target list name or list id
     * @param targetItemId The target item id
     * @param tryAddReverseLink If set to true try to add the reverse link (will not return error if it fails)
     */
    RelatedItemManagerImpl.prototype.addSingleLinkFromUrl = function (sourceItemUrl, targetListName, targetItemId, tryAddReverseLink) {
        if (tryAddReverseLink === void 0) { tryAddReverseLink = false; }
        var query = this.clone(RelatedItemManagerImpl_1, null);
        query.concat(".AddSingleLinkFromUrl");
        return query.postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                SourceItemUrl: sourceItemUrl,
                TargetItemID: targetItemId,
                TargetListName: targetListName,
                TryAddReverseLink: tryAddReverseLink,
            }),
        });
    };
    RelatedItemManagerImpl.prototype.deleteSingleLink = function (sourceListName, sourceItemId, sourceWebUrl, targetListName, targetItemId, targetWebUrl, tryDeleteReverseLink) {
        if (tryDeleteReverseLink === void 0) { tryDeleteReverseLink = false; }
        var query = this.clone(RelatedItemManagerImpl_1, null);
        query.concat(".DeleteSingleLink");
        return query.postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                SourceItemID: sourceItemId,
                SourceListName: sourceListName,
                SourceWebUrl: sourceWebUrl,
                TargetItemID: targetItemId,
                TargetListName: targetListName,
                TargetWebUrl: targetWebUrl,
                TryDeleteReverseLink: tryDeleteReverseLink,
            }),
        });
    };
    var RelatedItemManagerImpl_1;
    RelatedItemManagerImpl = RelatedItemManagerImpl_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("_api/SP.RelatedItemManager")
    ], RelatedItemManagerImpl);
    return RelatedItemManagerImpl;
}(SharePointQueryable));

/**
 * Describes a collection of webs
 *
 */
var Webs = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Webs, _super);
    function Webs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Webs_1 = Webs;
    /**
     * Adds a new web to the collection
     *
     * @param title The new web's title
     * @param url The new web's relative url
     * @param description The new web's description
     * @param template The new web's template internal name (default = STS)
     * @param language The locale id that specifies the new web's language (default = 1033 [English, US])
     * @param inheritPermissions When true, permissions will be inherited from the new web's parent (default = true)
     */
    Webs.prototype.add = function (title, url, description, template, language, inheritPermissions) {
        if (description === void 0) { description = ""; }
        if (template === void 0) { template = "STS"; }
        if (language === void 0) { language = 1033; }
        if (inheritPermissions === void 0) { inheritPermissions = true; }
        var props = {
            Description: description,
            Language: language,
            Title: title,
            Url: url,
            UseSamePermissionsAsParentSite: inheritPermissions,
            WebTemplate: template,
        };
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            "parameters": Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({
                "__metadata": { "type": "SP.WebCreationInformation" },
            }, props),
        });
        return this.clone(Webs_1, "add").postCore({ body: postBody }).then(function (data) {
            return {
                data: data,
                web: new Web(odataUrlFrom(data).replace(/_api\/web\/?/i, "")),
            };
        });
    };
    var Webs_1;
    Webs = Webs_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("webs")
    ], Webs);
    return Webs;
}(SharePointQueryableCollection));
/**
 * Describes a collection of web infos
 *
 */
var WebInfos = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(WebInfos, _super);
    function WebInfos() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebInfos = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("webinfos")
    ], WebInfos);
    return WebInfos;
}(SharePointQueryableCollection));
/**
 * Describes a web
 *
 */
var Web = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Web, _super);
    function Web() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Web_1 = Web;
    /**
     * Creates a new web instance from the given url by indexing the location of the /_api/
     * segment. If this is not found the method creates a new web with the entire string as
     * supplied.
     *
     * @param url
     */
    Web.fromUrl = function (url, path) {
        return new Web_1(extractWebUrl(url), path);
    };
    Object.defineProperty(Web.prototype, "webs", {
        /**
         * Gets this web's subwebs
         *
         */
        get: function () {
            return new Webs(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets this web's parent web and data
     *
     */
    Web.prototype.getParentWeb = function () {
        var _this = this;
        return this.select("ParentWeb/Id").expand("ParentWeb").get()
            .then(function (_a) {
            var ParentWeb = _a.ParentWeb;
            return new Site(_this.toUrlAndQuery().split("/_api")[0]).openWebById(ParentWeb.Id);
        });
    };
    /**
    * Returns a collection of objects that contain metadata about subsites of the current site in which the current user is a member.
    *
    * @param nWebTemplateFilter Specifies the site definition (default = -1)
    * @param nConfigurationFilter A 16-bit integer that specifies the identifier of a configuration (default = -1)
    */
    Web.prototype.getSubwebsFilteredForCurrentUser = function (nWebTemplateFilter, nConfigurationFilter) {
        if (nWebTemplateFilter === void 0) { nWebTemplateFilter = -1; }
        if (nConfigurationFilter === void 0) { nConfigurationFilter = -1; }
        return this.clone(Webs, "getSubwebsFilteredForCurrentUser(nWebTemplateFilter=" + nWebTemplateFilter + ",nConfigurationFilter=" + nConfigurationFilter + ")");
    };
    Object.defineProperty(Web.prototype, "allProperties", {
        /**
         * Allows access to the web's all properties collection
         */
        get: function () {
            return this.clone(SharePointQueryableCollection, "allproperties");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "webinfos", {
        /**
         * Gets a collection of WebInfos for this web's subwebs
         *
         */
        get: function () {
            return new WebInfos(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "contentTypes", {
        /**
         * Gets the content types available in this web
         *
         */
        get: function () {
            return new ContentTypes(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "lists", {
        /**
         * Gets the lists in this web
         *
         */
        get: function () {
            return new Lists(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "fields", {
        /**
         * Gets the fields in this web
         *
         */
        get: function () {
            return new Fields(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "features", {
        /**
         * Gets the active features for this web
         *
         */
        get: function () {
            return new Features(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "availablefields", {
        /**
         * Gets the available fields in this web
         *
         */
        get: function () {
            return new Fields(this, "availablefields");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "navigation", {
        /**
         * Gets the navigation options in this web
         *
         */
        get: function () {
            return new Navigation(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "siteUsers", {
        /**
         * Gets the site users
         *
         */
        get: function () {
            return new SiteUsers(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "siteGroups", {
        /**
         * Gets the site groups
         *
         */
        get: function () {
            return new SiteGroups(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "siteUserInfoList", {
        /**
         * Gets site user info list
         *
         */
        get: function () {
            return new List(this, "siteuserinfolist");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "regionalSettings", {
        /**
         * Gets regional settings
         *
         */
        get: function () {
            return new RegionalSettings(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "currentUser", {
        /**
         * Gets the current user
         */
        get: function () {
            return new CurrentUser(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "folders", {
        /**
         * Gets the top-level folders in this web
         *
         */
        get: function () {
            return new Folders(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "userCustomActions", {
        /**
         * Gets all user custom actions for this web
         *
         */
        get: function () {
            return new UserCustomActions(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "roleDefinitions", {
        /**
         * Gets the collection of RoleDefinition resources
         *
         */
        get: function () {
            return new RoleDefinitions(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "relatedItems", {
        /**
         * Provides an interface to manage related items
         *
         */
        get: function () {
            return RelatedItemManagerImpl.FromUrl(this.toUrl());
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new batch for requests within the context of this web
     *
     */
    Web.prototype.createBatch = function () {
        return new SPBatch(this.parentUrl);
    };
    Object.defineProperty(Web.prototype, "rootFolder", {
        /**
         * Gets the root folder of this web
         *
         */
        get: function () {
            return new Folder(this, "rootFolder");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "associatedOwnerGroup", {
        /**
         * Gets the associated owner group for this web
         *
         */
        get: function () {
            return new SiteGroup(this, "associatedownergroup");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "associatedMemberGroup", {
        /**
         * Gets the associated member group for this web
         *
         */
        get: function () {
            return new SiteGroup(this, "associatedmembergroup");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "associatedVisitorGroup", {
        /**
         * Gets the associated visitor group for this web
         *
         */
        get: function () {
            return new SiteGroup(this, "associatedvisitorgroup");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Web.prototype, "defaultDocumentLibrary", {
        /**
         * Gets the default document library for this web
         *
         */
        get: function () {
            return new List(this, "DefaultDocumentLibrary");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a folder by server relative url
     *
     * @param folderRelativeUrl The server relative path to the folder (including /sites/ if applicable)
     */
    Web.prototype.getFolderByServerRelativeUrl = function (folderRelativeUrl) {
        return new Folder(this, "getFolderByServerRelativeUrl('" + folderRelativeUrl + "')");
    };
    /**
     * Gets a folder by server relative relative path if your folder name contains # and % characters
     * you need to first encode the file name using encodeURIComponent() and then pass the url
     * let url = "/sites/test/Shared Documents/" + encodeURIComponent("%123");
     * This works only in SharePoint online.
     *
     * @param folderRelativeUrl The server relative path to the folder (including /sites/ if applicable)
     */
    Web.prototype.getFolderByServerRelativePath = function (folderRelativeUrl) {
        return new Folder(this, "getFolderByServerRelativePath(decodedUrl='" + folderRelativeUrl + "')");
    };
    /**
     * Gets a file by server relative url
     *
     * @param fileRelativeUrl The server relative path to the file (including /sites/ if applicable)
     */
    Web.prototype.getFileByServerRelativeUrl = function (fileRelativeUrl) {
        return new File(this, "getFileByServerRelativeUrl('" + fileRelativeUrl + "')");
    };
    /**
     * Gets a file by server relative url if your file name contains # and % characters
     * you need to first encode the file name using encodeURIComponent() and then pass the url
     * let url = "/sites/test/Shared Documents/" + encodeURIComponent("%123.docx");
     *
     * @param fileRelativeUrl The server relative path to the file (including /sites/ if applicable)
     */
    Web.prototype.getFileByServerRelativePath = function (fileRelativeUrl) {
        return new File(this, "getFileByServerRelativePath(decodedUrl='" + fileRelativeUrl + "')");
    };
    /**
     * Gets a list by server relative url (list's root folder)
     *
     * @param listRelativeUrl The server relative path to the list's root folder (including /sites/ if applicable)
     */
    Web.prototype.getList = function (listRelativeUrl) {
        return new List(this, "getList('" + listRelativeUrl + "')");
    };
    /**
     * Updates this web instance with the supplied properties
     *
     * @param properties A plain object hash of values to update for the web
     */
    Web.prototype.update = function (properties) {
        var _this = this;
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({
            "__metadata": { "type": "SP.Web" },
        }, properties));
        return this.postCore({
            body: postBody,
            headers: {
                "X-HTTP-Method": "MERGE",
            },
        }).then(function (data) {
            return {
                data: data,
                web: _this,
            };
        });
    };
    /**
     * Deletes this web
     *
     */
    Web.prototype.delete = function () {
        return _super.prototype.deleteCore.call(this);
    };
    /**
     * Applies the theme specified by the contents of each of the files specified in the arguments to the site
     *
     * @param colorPaletteUrl The server-relative URL of the color palette file
     * @param fontSchemeUrl The server-relative URL of the font scheme
     * @param backgroundImageUrl The server-relative URL of the background image
     * @param shareGenerated When true, the generated theme files are stored in the root site. When false, they are stored in this web
     */
    Web.prototype.applyTheme = function (colorPaletteUrl, fontSchemeUrl, backgroundImageUrl, shareGenerated) {
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            backgroundImageUrl: backgroundImageUrl,
            colorPaletteUrl: colorPaletteUrl,
            fontSchemeUrl: fontSchemeUrl,
            shareGenerated: shareGenerated,
        });
        return this.clone(Web_1, "applytheme").postCore({ body: postBody });
    };
    /**
     * Applies the specified site definition or site template to the Web site that has no template applied to it
     *
     * @param template Name of the site definition or the name of the site template
     */
    Web.prototype.applyWebTemplate = function (template) {
        var q = this.clone(Web_1, "applywebtemplate");
        q.concat("(@t)");
        q.query.set("@t", template);
        return q.postCore();
    };
    /**
     * Checks whether the specified login name belongs to a valid user in the web. If the user doesn't exist, adds the user to the web.
     *
     * @param loginName The login name of the user (ex: i:0#.f|membership|user@domain.onmicrosoft.com)
     */
    Web.prototype.ensureUser = function (loginName) {
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            logonName: loginName,
        });
        return this.clone(Web_1, "ensureuser").postCore({ body: postBody }).then(function (data) {
            return {
                data: data,
                user: new SiteUser(odataUrlFrom(data)),
            };
        });
    };
    /**
     * Returns a collection of site templates available for the site
     *
     * @param language The locale id of the site templates to retrieve (default = 1033 [English, US])
     * @param includeCrossLanguage When true, includes language-neutral site templates; otherwise false (default = true)
     */
    Web.prototype.availableWebTemplates = function (language, includeCrossLanugage) {
        if (language === void 0) { language = 1033; }
        if (includeCrossLanugage === void 0) { includeCrossLanugage = true; }
        return new SharePointQueryableCollection(this, "getavailablewebtemplates(lcid=" + language + ", doincludecrosslanguage=" + includeCrossLanugage + ")");
    };
    /**
     * Returns the list gallery on the site
     *
     * @param type The gallery type - WebTemplateCatalog = 111, WebPartCatalog = 113 ListTemplateCatalog = 114,
     * MasterPageCatalog = 116, SolutionCatalog = 121, ThemeCatalog = 123, DesignCatalog = 124, AppDataCatalog = 125
     */
    Web.prototype.getCatalog = function (type) {
        return this.clone(Web_1, "getcatalog(" + type + ")").select("Id").get().then(function (data) {
            return new List(odataUrlFrom(data));
        });
    };
    /**
     * Returns the collection of changes from the change log that have occurred within the list, based on the specified query
     *
     * @param query The change query
     */
    Web.prototype.getChanges = function (query) {
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ "query": Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])({ "__metadata": { "type": "SP.ChangeQuery" } }, query) });
        return this.clone(Web_1, "getchanges").postCore({ body: postBody });
    };
    Object.defineProperty(Web.prototype, "customListTemplate", {
        /**
         * Gets the custom list templates for the site
         *
         */
        get: function () {
            return new SharePointQueryableCollection(this, "getcustomlisttemplates");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the user corresponding to the specified member identifier for the current site
     *
     * @param id The id of the user
     */
    Web.prototype.getUserById = function (id) {
        return new SiteUser(this, "getUserById(" + id + ")");
    };
    /**
     * Returns the name of the image file for the icon that is used to represent the specified file
     *
     * @param filename The file name. If this parameter is empty, the server returns an empty string
     * @param size The size of the icon: 16x16 pixels = 0, 32x32 pixels = 1 (default = 0)
     * @param progId The ProgID of the application that was used to create the file, in the form OLEServerName.ObjectName
     */
    Web.prototype.mapToIcon = function (filename, size, progId) {
        if (size === void 0) { size = 0; }
        if (progId === void 0) { progId = ""; }
        return this.clone(Web_1, "maptoicon(filename='" + filename + "', progid='" + progId + "', size=" + size + ")").get();
    };
    /**
     * Returns the tenant property corresponding to the specified key in the app catalog site
     *
     * @param key Id of storage entity to be set
     */
    Web.prototype.getStorageEntity = function (key) {
        return this.clone(Web_1, "getStorageEntity('" + key + "')").get();
    };
    /**
     * This will set the storage entity identified by the given key (MUST be called in the context of the app catalog)
     *
     * @param key Id of storage entity to be set
     * @param value Value of storage entity to be set
     * @param description Description of storage entity to be set
     * @param comments Comments of storage entity to be set
     */
    Web.prototype.setStorageEntity = function (key, value, description, comments) {
        if (description === void 0) { description = ""; }
        if (comments === void 0) { comments = ""; }
        return this.clone(Web_1, "setStorageEntity").postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
                comments: comments,
                description: description,
                key: key,
                value: value,
            }),
        });
    };
    /**
     * This will remove the storage entity identified by the given key
     *
     * @param key Id of storage entity to be removed
     */
    Web.prototype.removeStorageEntity = function (key) {
        return this.clone(Web_1, "removeStorageEntity('" + key + "')").postCore();
    };
    /**
     * Gets the app catalog for this web
     *
     * @param url Optional url or web containing the app catalog (default: current web)
     */
    Web.prototype.getAppCatalog = function (url) {
        return new AppCatalog(url || this);
    };
    /**
     * Gets the collection of available client side web parts for this web instance
     */
    Web.prototype.getClientSideWebParts = function () {
        return this.clone(SharePointQueryableCollection, "GetClientSideWebParts").get();
    };
    /**
     * Creates a new client side page
     *
     * @param pageName Name of the new page
     * @param title Display title of the new page
     * @param libraryTitle Title of the library in which to create the new page. Default: "Site Pages"
     */
    Web.prototype.addClientSidePage = function (pageName, title, libraryTitle) {
        if (title === void 0) { title = pageName.replace(/\.[^/.]+$/, ""); }
        if (libraryTitle === void 0) { libraryTitle = "Site Pages"; }
        return ClientSidePage.create(this.lists.getByTitle(libraryTitle), pageName, title);
    };
    /**
     * Creates a new client side page using the library path
     *
     * @param pageName Name of the new page
     * @param listRelativePath The server relative path to the list's root folder (including /sites/ if applicable)
     * @param title Display title of the new page
     */
    Web.prototype.addClientSidePageByPath = function (pageName, listRelativePath, title) {
        if (title === void 0) { title = pageName.replace(/\.[^/.]+$/, ""); }
        return ClientSidePage.create(this.getList(listRelativePath), pageName, title);
    };
    var Web_1;
    Web = Web_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("_api/web")
    ], Web);
    return Web;
}(SharePointQueryableShareableWeb));

/**
 * Describes a site collection
 *
 */
var Site = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(Site, _super);
    function Site() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Site_1 = Site;
    Object.defineProperty(Site.prototype, "rootWeb", {
        /**
         * Gets the root web of the site collection
         *
         */
        get: function () {
            return new Web(this, "rootweb");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Site.prototype, "features", {
        /**
         * Gets the active features for this site collection
         *
         */
        get: function () {
            return new Features(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Site.prototype, "userCustomActions", {
        /**
         * Gets all custom actions for this site collection
         *
         */
        get: function () {
            return new UserCustomActions(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a Web instance representing the root web of the site collection
     * correctly setup for chaining within the library
     */
    Site.prototype.getRootWeb = function () {
        return this.rootWeb.select("Url").get().then(function (web) { return new Web(web.Url); });
    };
    /**
     * Gets the context information for this site collection
     */
    Site.prototype.getContextInfo = function () {
        var q = new Site_1(this.parentUrl, "_api/contextinfo");
        return q.postCore().then(function (data) {
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(data, "GetContextWebInformation")) {
                var info = data.GetContextWebInformation;
                info.SupportedSchemaVersions = info.SupportedSchemaVersions.results;
                return info;
            }
            else {
                return data;
            }
        });
    };
    /**
     * Gets the document libraries on a site. Static method. (SharePoint Online only)
     *
     * @param absoluteWebUrl The absolute url of the web whose document libraries should be returned
     */
    Site.prototype.getDocumentLibraries = function (absoluteWebUrl) {
        var q = new SharePointQueryable("", "_api/sp.web.getdocumentlibraries(@v)");
        q.query.set("@v", "'" + absoluteWebUrl + "'");
        return q.get().then(function (data) {
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(data, "GetDocumentLibraries")) {
                return data.GetDocumentLibraries;
            }
            else {
                return data;
            }
        });
    };
    /**
     * Gets the site url from a page url
     *
     * @param absolutePageUrl The absolute url of the page
     */
    Site.prototype.getWebUrlFromPageUrl = function (absolutePageUrl) {
        var q = new SharePointQueryable("", "_api/sp.web.getweburlfrompageurl(@v)");
        q.query.set("@v", "'" + absolutePageUrl + "'");
        return q.get().then(function (data) {
            if (Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(data, "GetWebUrlFromPageUrl")) {
                return data.GetWebUrlFromPageUrl;
            }
            else {
                return data;
            }
        });
    };
    /**
     * Creates a new batch for requests within the context of this site collection
     *
     */
    Site.prototype.createBatch = function () {
        return new SPBatch(this.parentUrl);
    };
    /**
     * Opens a web by id (using POST)
     *
     * @param webId The GUID id of the web to open
     */
    Site.prototype.openWebById = function (webId) {
        return this.clone(Site_1, "openWebById('" + webId + "')").postCore().then(function (d) { return ({
            data: d,
            web: Web.fromUrl(d["odata.id"] || d.__metadata.uri),
        }); });
    };
    var Site_1;
    Site = Site_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("_api/site")
    ], Site);
    return Site;
}(SharePointQueryableInstance));

var UserProfileQuery = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(UserProfileQuery, _super);
    /**
     * Creates a new instance of the UserProfileQuery class
     *
     * @param baseUrl The url or SharePointQueryable which forms the parent of this user profile query
     */
    function UserProfileQuery(baseUrl, path) {
        if (path === void 0) { path = "_api/sp.userprofiles.peoplemanager"; }
        var _this = _super.call(this, baseUrl, path) || this;
        _this.clientPeoplePickerQuery = (new ClientPeoplePickerQuery(baseUrl)).configureFrom(_this);
        _this.profileLoader = (new ProfileLoader(baseUrl)).configureFrom(_this);
        return _this;
    }
    Object.defineProperty(UserProfileQuery.prototype, "editProfileLink", {
        /**
         * The url of the edit profile page for the current user
         */
        get: function () {
            return this.clone(UserProfileQuery, "EditProfileLink").get();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserProfileQuery.prototype, "isMyPeopleListPublic", {
        /**
         * A boolean value that indicates whether the current user's "People I'm Following" list is public
         */
        get: function () {
            return this.clone(UserProfileQuery, "IsMyPeopleListPublic").get();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * A boolean value that indicates whether the current user is being followed by the specified user
     *
     * @param loginName The account name of the user
     */
    UserProfileQuery.prototype.amIFollowedBy = function (loginName) {
        var q = this.clone(UserProfileQuery, "amifollowedby(@v)");
        q.query.set("@v", "'" + encodeURIComponent(loginName) + "'");
        return q.get();
    };
    /**
     * A boolean value that indicates whether the current user is following the specified user
     *
     * @param loginName The account name of the user
     */
    UserProfileQuery.prototype.amIFollowing = function (loginName) {
        var q = this.clone(UserProfileQuery, "amifollowing(@v)");
        q.query.set("@v", "'" + encodeURIComponent(loginName) + "'");
        return q.get();
    };
    /**
     * Gets tags that the current user is following
     *
     * @param maxCount The maximum number of tags to retrieve (default is 20)
     */
    UserProfileQuery.prototype.getFollowedTags = function (maxCount) {
        if (maxCount === void 0) { maxCount = 20; }
        return this.clone(UserProfileQuery, "getfollowedtags(" + maxCount + ")").get();
    };
    /**
     * Gets the people who are following the specified user
     *
     * @param loginName The account name of the user
     */
    UserProfileQuery.prototype.getFollowersFor = function (loginName) {
        var q = this.clone(UserProfileQuery, "getfollowersfor(@v)");
        q.query.set("@v", "'" + encodeURIComponent(loginName) + "'");
        return q.get();
    };
    Object.defineProperty(UserProfileQuery.prototype, "myFollowers", {
        /**
         * Gets the people who are following the current user
         *
         */
        get: function () {
            return new SharePointQueryableCollection(this, "getmyfollowers");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserProfileQuery.prototype, "myProperties", {
        /**
         * Gets user properties for the current user
         *
         */
        get: function () {
            return new UserProfileQuery(this, "getmyproperties");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the people who the specified user is following
     *
     * @param loginName The account name of the user.
     */
    UserProfileQuery.prototype.getPeopleFollowedBy = function (loginName) {
        var q = this.clone(UserProfileQuery, "getpeoplefollowedby(@v)");
        q.query.set("@v", "'" + encodeURIComponent(loginName) + "'");
        return q.get();
    };
    /**
     * Gets user properties for the specified user.
     *
     * @param loginName The account name of the user.
     */
    UserProfileQuery.prototype.getPropertiesFor = function (loginName) {
        var q = this.clone(UserProfileQuery, "getpropertiesfor(@v)");
        q.query.set("@v", "'" + encodeURIComponent(loginName) + "'");
        return q.get();
    };
    Object.defineProperty(UserProfileQuery.prototype, "trendingTags", {
        /**
         * Gets the 20 most popular hash tags over the past week, sorted so that the most popular tag appears first
         *
         */
        get: function () {
            var q = this.clone(UserProfileQuery, null);
            q.concat(".gettrendingtags");
            return q.get();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the specified user profile property for the specified user
     *
     * @param loginName The account name of the user
     * @param propertyName The case-sensitive name of the property to get
     */
    UserProfileQuery.prototype.getUserProfilePropertyFor = function (loginName, propertyName) {
        var q = this.clone(UserProfileQuery, "getuserprofilepropertyfor(accountname=@v, propertyname='" + propertyName + "')");
        q.query.set("@v", "'" + encodeURIComponent(loginName) + "'");
        return q.get();
    };
    /**
     * Removes the specified user from the user's list of suggested people to follow
     *
     * @param loginName The account name of the user
     */
    UserProfileQuery.prototype.hideSuggestion = function (loginName) {
        var q = this.clone(UserProfileQuery, "hidesuggestion(@v)");
        q.query.set("@v", "'" + encodeURIComponent(loginName) + "'");
        return q.postCore();
    };
    /**
     * A boolean values that indicates whether the first user is following the second user
     *
     * @param follower The account name of the user who might be following the followee
     * @param followee The account name of the user who might be followed by the follower
     */
    UserProfileQuery.prototype.isFollowing = function (follower, followee) {
        var q = this.clone(UserProfileQuery, null);
        q.concat(".isfollowing(possiblefolloweraccountname=@v, possiblefolloweeaccountname=@y)");
        q.query.set("@v", "'" + encodeURIComponent(follower) + "'");
        q.query.set("@y", "'" + encodeURIComponent(followee) + "'");
        return q.get();
    };
    /**
     * Uploads and sets the user profile picture (Users can upload a picture to their own profile only). Not supported for batching.
     *
     * @param profilePicSource Blob data representing the user's picture in BMP, JPEG, or PNG format of up to 4.76MB
     */
    UserProfileQuery.prototype.setMyProfilePic = function (profilePicSource) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var buffer = null;
            var reader = new FileReader();
            reader.onload = function (e) { return buffer = e.target.result; };
            reader.readAsArrayBuffer(profilePicSource);
            var request = new UserProfileQuery(_this, "setmyprofilepicture");
            request.postCore({
                body: String.fromCharCode.apply(null, new Uint16Array(buffer)),
            }).then(function (_) { return resolve(); }).catch(function (e) { return reject(e); });
        });
    };
    /**
     * Sets single value User Profile property
     *
     * @param accountName The account name of the user
     * @param propertyName Property name
     * @param propertyValue Property value
     */
    UserProfileQuery.prototype.setSingleValueProfileProperty = function (accountName, propertyName, propertyValue) {
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            accountName: accountName,
            propertyName: propertyName,
            propertyValue: propertyValue,
        });
        return this.clone(UserProfileQuery, "SetSingleValueProfileProperty")
            .postCore({ body: postBody });
    };
    /**
     * Sets multi valued User Profile property
     *
     * @param accountName The account name of the user
     * @param propertyName Property name
     * @param propertyValues Property values
     */
    UserProfileQuery.prototype.setMultiValuedProfileProperty = function (accountName, propertyName, propertyValues) {
        var postBody = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            accountName: accountName,
            propertyName: propertyName,
            propertyValues: propertyValues,
        });
        return this.clone(UserProfileQuery, "SetMultiValuedProfileProperty")
            .postCore({ body: postBody });
    };
    /**
     * Provisions one or more users' personal sites. (My Site administrator on SharePoint Online only)
     *
     * @param emails The email addresses of the users to provision sites for
     */
    UserProfileQuery.prototype.createPersonalSiteEnqueueBulk = function () {
        var emails = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            emails[_i] = arguments[_i];
        }
        return this.profileLoader.createPersonalSiteEnqueueBulk(emails);
    };
    Object.defineProperty(UserProfileQuery.prototype, "ownerUserProfile", {
        /**
         * Gets the user profile of the site owner
         *
         */
        get: function () {
            return this.profileLoader.ownerUserProfile;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserProfileQuery.prototype, "userProfile", {
        /**
         * Gets the user profile for the current user
         */
        get: function () {
            return this.profileLoader.userProfile;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Enqueues creating a personal site for this user, which can be used to share documents, web pages, and other files
     *
     * @param interactiveRequest true if interactively (web) initiated request, or false (default) if non-interactively (client) initiated request
     */
    UserProfileQuery.prototype.createPersonalSite = function (interactiveRequest) {
        if (interactiveRequest === void 0) { interactiveRequest = false; }
        return this.profileLoader.createPersonalSite(interactiveRequest);
    };
    /**
     * Sets the privacy settings for this profile
     *
     * @param share true to make all social data public; false to make all social data private
     */
    UserProfileQuery.prototype.shareAllSocialData = function (share) {
        return this.profileLoader.shareAllSocialData(share);
    };
    /**
     * Resolves user or group using specified query parameters
     *
     * @param queryParams The query parameters used to perform resolve
     */
    UserProfileQuery.prototype.clientPeoplePickerResolveUser = function (queryParams) {
        return this.clientPeoplePickerQuery.clientPeoplePickerResolveUser(queryParams);
    };
    /**
     * Searches for users or groups using specified query parameters
     *
     * @param queryParams The query parameters used to perform search
     */
    UserProfileQuery.prototype.clientPeoplePickerSearchUser = function (queryParams) {
        return this.clientPeoplePickerQuery.clientPeoplePickerSearchUser(queryParams);
    };
    return UserProfileQuery;
}(SharePointQueryableInstance));
var ProfileLoader = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ProfileLoader, _super);
    function ProfileLoader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ProfileLoader_1 = ProfileLoader;
    /**
     * Provisions one or more users' personal sites. (My Site administrator on SharePoint Online only) Doesn't support batching
     *
     * @param emails The email addresses of the users to provision sites for
     */
    ProfileLoader.prototype.createPersonalSiteEnqueueBulk = function (emails) {
        return this.clone(ProfileLoader_1, "createpersonalsiteenqueuebulk", false).postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({ "emailIDs": emails }),
        });
    };
    Object.defineProperty(ProfileLoader.prototype, "ownerUserProfile", {
        /**
         * Gets the user profile of the site owner.
         *
         */
        get: function () {
            var q = this.getParent(ProfileLoader_1, this.parentUrl, "_api/sp.userprofiles.profileloader.getowneruserprofile");
            if (this.hasBatch) {
                q = q.inBatch(this.batch);
            }
            return q.postCore();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProfileLoader.prototype, "userProfile", {
        /**
         * Gets the user profile of the current user.
         *
         */
        get: function () {
            return this.clone(ProfileLoader_1, "getuserprofile").postCore();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Enqueues creating a personal site for this user, which can be used to share documents, web pages, and other files.
     *
     * @param interactiveRequest true if interactively (web) initiated request, or false (default) if non-interactively (client) initiated request
     */
    ProfileLoader.prototype.createPersonalSite = function (interactiveRequest) {
        if (interactiveRequest === void 0) { interactiveRequest = false; }
        return this.clone(ProfileLoader_1, "getuserprofile/createpersonalsiteenque(" + interactiveRequest + ")").postCore();
    };
    /**
     * Sets the privacy settings for this profile
     *
     * @param share true to make all social data public; false to make all social data private.
     */
    ProfileLoader.prototype.shareAllSocialData = function (share) {
        return this.clone(ProfileLoader_1, "getuserprofile/shareallsocialdata(" + share + ")").postCore();
    };
    var ProfileLoader_1;
    ProfileLoader = ProfileLoader_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("_api/sp.userprofiles.profileloader.getprofileloader")
    ], ProfileLoader);
    return ProfileLoader;
}(SharePointQueryable));
var ClientPeoplePickerQuery = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(ClientPeoplePickerQuery, _super);
    function ClientPeoplePickerQuery() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ClientPeoplePickerQuery_1 = ClientPeoplePickerQuery;
    /**
     * Resolves user or group using specified query parameters
     *
     * @param queryParams The query parameters used to perform resolve
     */
    ClientPeoplePickerQuery.prototype.clientPeoplePickerResolveUser = function (queryParams) {
        var q = this.clone(ClientPeoplePickerQuery_1, null);
        q.concat(".clientpeoplepickerresolveuser");
        return q.postCore({
            body: this.createClientPeoplePickerQueryParametersRequestBody(queryParams),
        })
            .then(function (res) {
            if (typeof res === "object") {
                return res.ClientPeoplePickerResolveUser;
            }
            return res;
        })
            .then(JSON.parse);
    };
    /**
     * Searches for users or groups using specified query parameters
     *
     * @param queryParams The query parameters used to perform search
     */
    ClientPeoplePickerQuery.prototype.clientPeoplePickerSearchUser = function (queryParams) {
        var q = this.clone(ClientPeoplePickerQuery_1, null);
        q.concat(".clientpeoplepickersearchuser");
        return q.postCore({
            body: this.createClientPeoplePickerQueryParametersRequestBody(queryParams),
        })
            .then(function (res) {
            if (typeof res === "object") {
                return res.ClientPeoplePickerSearchUser;
            }
            return res;
        })
            .then(JSON.parse);
    };
    /**
     * Creates ClientPeoplePickerQueryParameters request body
     *
     * @param queryParams The query parameters to create request body
     */
    ClientPeoplePickerQuery.prototype.createClientPeoplePickerQueryParametersRequestBody = function (queryParams) {
        return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            "queryParams": Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.UI.ApplicationPages.ClientPeoplePickerQueryParameters"), queryParams),
        });
    };
    var ClientPeoplePickerQuery_1;
    ClientPeoplePickerQuery = ClientPeoplePickerQuery_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("_api/sp.ui.applicationpages.clientpeoplepickerwebserviceinterface")
    ], ClientPeoplePickerQuery);
    return ClientPeoplePickerQuery;
}(SharePointQueryable));

/**
 * Exposes social following methods
 */
var SocialQuery = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(SocialQuery, _super);
    function SocialQuery() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SocialQuery_1 = SocialQuery;
    Object.defineProperty(SocialQuery.prototype, "my", {
        get: function () {
            return new MySocialQuery(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a URI to a site that lists the current user's followed sites.
     */
    SocialQuery.prototype.getFollowedSitesUri = function () {
        return this.clone(SocialQuery_1, "FollowedSitesUri").get().then(function (r) {
            return r.FollowedSitesUri || r;
        });
    };
    /**
     * Gets a URI to a site that lists the current user's followed documents.
     */
    SocialQuery.prototype.getFollowedDocumentsUri = function () {
        return this.clone(SocialQuery_1, "FollowedDocumentsUri").get().then(function (r) {
            return r.FollowedDocumentsUri || r;
        });
    };
    /**
     * Makes the current user start following a user, document, site, or tag
     *
     * @param actorInfo The actor to start following
     */
    SocialQuery.prototype.follow = function (actorInfo) {
        return this.clone(SocialQuery_1, "follow").postCore({ body: this.createSocialActorInfoRequestBody(actorInfo) });
    };
    /**
     * Indicates whether the current user is following a specified user, document, site, or tag
     *
     * @param actorInfo The actor to find the following status for
     */
    SocialQuery.prototype.isFollowed = function (actorInfo) {
        return this.clone(SocialQuery_1, "isfollowed").postCore({ body: this.createSocialActorInfoRequestBody(actorInfo) });
    };
    /**
     * Makes the current user stop following a user, document, site, or tag
     *
     * @param actorInfo The actor to stop following
     */
    SocialQuery.prototype.stopFollowing = function (actorInfo) {
        return this.clone(SocialQuery_1, "stopfollowing").postCore({ body: this.createSocialActorInfoRequestBody(actorInfo) });
    };
    /**
     * Creates SocialActorInfo request body
     *
     * @param actorInfo The actor to create request body
     */
    SocialQuery.prototype.createSocialActorInfoRequestBody = function (actorInfo) {
        return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])({
            "actor": Object.assign(metadata("SP.Social.SocialActorInfo"), {
                Id: null,
            }, actorInfo),
        });
    };
    var SocialQuery_1;
    SocialQuery = SocialQuery_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("_api/social.following")
    ], SocialQuery);
    return SocialQuery;
}(SharePointQueryableInstance));
var MySocialQuery = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(MySocialQuery, _super);
    function MySocialQuery() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MySocialQuery_1 = MySocialQuery;
    /**
     * Gets users, documents, sites, and tags that the current user is following.
     *
     * @param types Bitwise set of SocialActorTypes to retrieve
     */
    MySocialQuery.prototype.followed = function (types) {
        return this.clone(MySocialQuery_1, "followed(types=" + types + ")").get().then(function (r) {
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(r, "Followed") ? r.Followed.results : r;
        });
    };
    /**
     * Gets the count of users, documents, sites, and tags that the current user is following.
     *
     * @param types Bitwise set of SocialActorTypes to retrieve
     */
    MySocialQuery.prototype.followedCount = function (types) {
        return this.clone(MySocialQuery_1, "followedcount(types=" + types + ")").get().then(function (r) {
            return r.FollowedCount || r;
        });
    };
    /**
     * Gets the users who are following the current user.
     */
    MySocialQuery.prototype.followers = function () {
        return this.clone(MySocialQuery_1, "followers").get().then(function (r) {
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(r, "Followers") ? r.Followers.results : r;
        });
    };
    /**
     * Gets users who the current user might want to follow.
     */
    MySocialQuery.prototype.suggestions = function () {
        return this.clone(MySocialQuery_1, "suggestions").get().then(function (r) {
            return Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["hOP"])(r, "Suggestions") ? r.Suggestions.results : r;
        });
    };
    var MySocialQuery_1;
    MySocialQuery = MySocialQuery_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__decorate"])([
        defaultPath("my")
    ], MySocialQuery);
    return MySocialQuery;
}(SharePointQueryableInstance));
/**
 * Social actor type
 *
 */
var SocialActorType;
(function (SocialActorType) {
    SocialActorType[SocialActorType["User"] = 0] = "User";
    SocialActorType[SocialActorType["Document"] = 1] = "Document";
    SocialActorType[SocialActorType["Site"] = 2] = "Site";
    SocialActorType[SocialActorType["Tag"] = 3] = "Tag";
})(SocialActorType || (SocialActorType = {}));
/**
 * Social actor type
 *
 */
/* tslint:disable:no-bitwise */
var SocialActorTypes;
(function (SocialActorTypes) {
    SocialActorTypes[SocialActorTypes["None"] = 0] = "None";
    SocialActorTypes[SocialActorTypes["User"] = 1] = "User";
    SocialActorTypes[SocialActorTypes["Document"] = 2] = "Document";
    SocialActorTypes[SocialActorTypes["Site"] = 4] = "Site";
    SocialActorTypes[SocialActorTypes["Tag"] = 8] = "Tag";
    /**
     * The set excludes documents and sites that do not have feeds.
     */
    SocialActorTypes[SocialActorTypes["ExcludeContentWithoutFeeds"] = 268435456] = "ExcludeContentWithoutFeeds";
    /**
     * The set includes group sites
     */
    SocialActorTypes[SocialActorTypes["IncludeGroupsSites"] = 536870912] = "IncludeGroupsSites";
    /**
     * The set includes only items created within the last 24 hours
     */
    SocialActorTypes[SocialActorTypes["WithinLast24Hours"] = 1073741824] = "WithinLast24Hours";
})(SocialActorTypes || (SocialActorTypes = {}));
/* tslint:enable */
/**
 * Result from following
 *
 */
var SocialFollowResult;
(function (SocialFollowResult) {
    SocialFollowResult[SocialFollowResult["Ok"] = 0] = "Ok";
    SocialFollowResult[SocialFollowResult["AlreadyFollowing"] = 1] = "AlreadyFollowing";
    SocialFollowResult[SocialFollowResult["LimitReached"] = 2] = "LimitReached";
    SocialFollowResult[SocialFollowResult["InternalError"] = 3] = "InternalError";
})(SocialFollowResult || (SocialFollowResult = {}));
/**
 * Specifies an exception or status code.
 */
var SocialStatusCode;
(function (SocialStatusCode) {
    /**
     * The operation completed successfully
     */
    SocialStatusCode[SocialStatusCode["OK"] = 0] = "OK";
    /**
     * The request is invalid.
     */
    SocialStatusCode[SocialStatusCode["InvalidRequest"] = 1] = "InvalidRequest";
    /**
     *  The current user is not authorized to perform the operation.
     */
    SocialStatusCode[SocialStatusCode["AccessDenied"] = 2] = "AccessDenied";
    /**
     * The target of the operation was not found.
     */
    SocialStatusCode[SocialStatusCode["ItemNotFound"] = 3] = "ItemNotFound";
    /**
     * The operation is invalid for the target's current state.
     */
    SocialStatusCode[SocialStatusCode["InvalidOperation"] = 4] = "InvalidOperation";
    /**
     * The operation completed without modifying the target.
     */
    SocialStatusCode[SocialStatusCode["ItemNotModified"] = 5] = "ItemNotModified";
    /**
     * The operation failed because an internal error occurred.
     */
    SocialStatusCode[SocialStatusCode["InternalError"] = 6] = "InternalError";
    /**
     * The operation failed because the server could not access the distributed cache.
     */
    SocialStatusCode[SocialStatusCode["CacheReadError"] = 7] = "CacheReadError";
    /**
     * The operation succeeded but the server could not update the distributed cache.
     */
    SocialStatusCode[SocialStatusCode["CacheUpdateError"] = 8] = "CacheUpdateError";
    /**
     * No personal site exists for the current user, and no further information is available.
     */
    SocialStatusCode[SocialStatusCode["PersonalSiteNotFound"] = 9] = "PersonalSiteNotFound";
    /**
     * No personal site exists for the current user, and a previous attempt to create one failed.
     */
    SocialStatusCode[SocialStatusCode["FailedToCreatePersonalSite"] = 10] = "FailedToCreatePersonalSite";
    /**
     * No personal site exists for the current user, and a previous attempt to create one was not authorized.
     */
    SocialStatusCode[SocialStatusCode["NotAuthorizedToCreatePersonalSite"] = 11] = "NotAuthorizedToCreatePersonalSite";
    /**
     * No personal site exists for the current user, and no attempt should be made to create one.
     */
    SocialStatusCode[SocialStatusCode["CannotCreatePersonalSite"] = 12] = "CannotCreatePersonalSite";
    /**
     * The operation was rejected because an internal limit had been reached.
     */
    SocialStatusCode[SocialStatusCode["LimitReached"] = 13] = "LimitReached";
    /**
     * The operation failed because an error occurred during the processing of the specified attachment.
     */
    SocialStatusCode[SocialStatusCode["AttachmentError"] = 14] = "AttachmentError";
    /**
     * The operation succeeded with recoverable errors; the returned data is incomplete.
     */
    SocialStatusCode[SocialStatusCode["PartialData"] = 15] = "PartialData";
    /**
     * A required SharePoint feature is not enabled.
     */
    SocialStatusCode[SocialStatusCode["FeatureDisabled"] = 16] = "FeatureDisabled";
    /**
     * The site's storage quota has been exceeded.
     */
    SocialStatusCode[SocialStatusCode["StorageQuotaExceeded"] = 17] = "StorageQuotaExceeded";
    /**
     * The operation failed because the server could not access the database.
     */
    SocialStatusCode[SocialStatusCode["DatabaseError"] = 18] = "DatabaseError";
})(SocialStatusCode || (SocialStatusCode = {}));

/**
 * Allows for calling of the static SP.Utilities.Utility methods by supplying the method name
 */
var UtilityMethod = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_1__["__extends"])(UtilityMethod, _super);
    /**
     * Creates a new instance of the Utility method class
     *
     * @param baseUrl The parent url provider
     * @param methodName The static method name to call on the utility class
     */
    function UtilityMethod(baseUrl, methodName) {
        return _super.call(this, UtilityMethod.getBaseUrl(baseUrl), "_api/SP.Utilities.Utility." + methodName) || this;
    }
    UtilityMethod.getBaseUrl = function (candidate) {
        if (typeof candidate === "string") {
            return candidate;
        }
        var c = candidate;
        var url = c.toUrl();
        var index = url.indexOf("_api/");
        if (index < 0) {
            return url;
        }
        return url.substr(0, index);
    };
    UtilityMethod.prototype.excute = function (props) {
        return this.postCore({
            body: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["jsS"])(props),
        });
    };
    /**
     * Sends an email based on the supplied properties
     *
     * @param props The properties of the email to send
     */
    UtilityMethod.prototype.sendEmail = function (props) {
        var params = {
            properties: Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(metadata("SP.Utilities.EmailProperties"), {
                Body: props.Body,
                From: props.From,
                Subject: props.Subject,
            }),
        };
        if (props.To && props.To.length > 0) {
            params.properties = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(params.properties, {
                To: { results: props.To },
            });
        }
        if (props.CC && props.CC.length > 0) {
            params.properties = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(params.properties, {
                CC: { results: props.CC },
            });
        }
        if (props.BCC && props.BCC.length > 0) {
            params.properties = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(params.properties, {
                BCC: { results: props.BCC },
            });
        }
        if (props.AdditionalHeaders) {
            params.properties = Object(_pnp_common__WEBPACK_IMPORTED_MODULE_0__["extend"])(params.properties, {
                AdditionalHeaders: props.AdditionalHeaders,
            });
        }
        return this.clone(UtilityMethod, "SendEmail", true).excute(params);
    };
    UtilityMethod.prototype.getCurrentUserEmailAddresses = function () {
        return this.clone(UtilityMethod, "GetCurrentUserEmailAddresses", true).excute({});
    };
    UtilityMethod.prototype.resolvePrincipal = function (input, scopes, sources, inputIsEmailOnly, addToUserInfoList, matchUserInfoList) {
        if (matchUserInfoList === void 0) { matchUserInfoList = false; }
        var params = {
            addToUserInfoList: addToUserInfoList,
            input: input,
            inputIsEmailOnly: inputIsEmailOnly,
            matchUserInfoList: matchUserInfoList,
            scopes: scopes,
            sources: sources,
        };
        return this.clone(UtilityMethod, "ResolvePrincipalInCurrentContext", true).excute(params);
    };
    UtilityMethod.prototype.searchPrincipals = function (input, scopes, sources, groupName, maxCount) {
        var params = {
            groupName: groupName,
            input: input,
            maxCount: maxCount,
            scopes: scopes,
            sources: sources,
        };
        return this.clone(UtilityMethod, "SearchPrincipalsUsingContextWeb", true).excute(params);
    };
    UtilityMethod.prototype.createEmailBodyForInvitation = function (pageAddress) {
        var params = {
            pageAddress: pageAddress,
        };
        return this.clone(UtilityMethod, "CreateEmailBodyForInvitation", true).excute(params);
    };
    UtilityMethod.prototype.expandGroupsToPrincipals = function (inputs, maxCount) {
        if (maxCount === void 0) { maxCount = 30; }
        var params = {
            inputs: inputs,
            maxCount: maxCount,
        };
        return this.clone(UtilityMethod, "ExpandGroupsToPrincipals", true).excute(params);
    };
    UtilityMethod.prototype.createWikiPage = function (info) {
        return this.clone(UtilityMethod, "CreateWikiPageInContextWeb", true).excute({
            parameters: info,
        }).then(function (r) {
            return {
                data: r,
                file: new File(odataUrlFrom(r)),
            };
        });
    };
    return UtilityMethod;
}(SharePointQueryable));

/**
 * Root of the SharePoint REST module
 */
var SPRest = /** @class */ (function () {
    /**
     * Creates a new instance of the SPRest class
     *
     * @param options Additional options
     * @param baseUrl A string that should form the base part of the url
     */
    function SPRest(_options, _baseUrl) {
        if (_options === void 0) { _options = {}; }
        if (_baseUrl === void 0) { _baseUrl = ""; }
        this._options = _options;
        this._baseUrl = _baseUrl;
    }
    /**
     * Configures instance with additional options and baseUrl.
     * Provided configuration used by other objects in a chain
     *
     * @param options Additional options
     * @param baseUrl A string that should form the base part of the url
     */
    SPRest.prototype.configure = function (options, baseUrl) {
        if (baseUrl === void 0) { baseUrl = ""; }
        return new SPRest(options, baseUrl);
    };
    /**
     * Global SharePoint configuration options
     *
     * @param config The SharePoint configuration to apply
     */
    SPRest.prototype.setup = function (config) {
        setup(config);
    };
    /**
     * Executes a search against this web context
     *
     * @param query The SearchQuery definition
     */
    SPRest.prototype.searchSuggest = function (query) {
        var finalQuery;
        if (typeof query === "string") {
            finalQuery = { querytext: query };
        }
        else {
            finalQuery = query;
        }
        return this.create(SearchSuggest).execute(finalQuery);
    };
    /**
     * Executes a search against this web context
     *
     * @param query The SearchQuery definition
     */
    SPRest.prototype.search = function (query) {
        return this.create(Search).execute(query);
    };
    /**
     * Executes the provided search query, caching the results
     *
     * @param query The SearchQuery definition
     * @param options The set of caching options used to store the results
     */
    SPRest.prototype.searchWithCaching = function (query, options) {
        return this.create(Search).usingCaching(options).execute(query);
    };
    Object.defineProperty(SPRest.prototype, "site", {
        /**
         * Begins a site collection scoped REST request
         *
         */
        get: function () {
            return this.create(Site);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SPRest.prototype, "web", {
        /**
         * Begins a web scoped REST request
         *
         */
        get: function () {
            return this.create(Web);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SPRest.prototype, "profiles", {
        /**
         * Access to user profile methods
         *
         */
        get: function () {
            return this.create(UserProfileQuery);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SPRest.prototype, "social", {
        /**
         * Access to social methods
         */
        get: function () {
            return this.create(SocialQuery);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SPRest.prototype, "navigation", {
        /**
         * Access to the site collection level navigation service
         */
        get: function () {
            return new NavigationService();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new batch object for use with the SharePointQueryable.addToBatch method
     *
     */
    SPRest.prototype.createBatch = function () {
        return this.web.createBatch();
    };
    Object.defineProperty(SPRest.prototype, "utility", {
        /**
         * Static utilities methods from SP.Utilities.Utility
         */
        get: function () {
            return this.create(UtilityMethod, "");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles creating and configuring the objects returned from this class
     *
     * @param fm The factory method used to create the instance
     * @param path Optional additional path information to pass to the factory method
     */
    SPRest.prototype.create = function (fm, path) {
        return new fm(this._baseUrl, path).configure(this._options);
    };
    return SPRest;
}());
var sp = new SPRest();


//# sourceMappingURL=sp.es5.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/adal-angular/dist/adal.min.js":
/*!****************************************************!*\
  !*** ./node_modules/adal-angular/dist/adal.min.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! adal-angular v1.0.17 2018-02-27 */
var AuthenticationContext=function(){"use strict";return AuthenticationContext=function(a){if(this.REQUEST_TYPE={LOGIN:"LOGIN",RENEW_TOKEN:"RENEW_TOKEN",UNKNOWN:"UNKNOWN"},this.RESPONSE_TYPE={ID_TOKEN_TOKEN:"id_token token",TOKEN:"token"},this.CONSTANTS={ACCESS_TOKEN:"access_token",EXPIRES_IN:"expires_in",ID_TOKEN:"id_token",ERROR_DESCRIPTION:"error_description",SESSION_STATE:"session_state",ERROR:"error",STORAGE:{TOKEN_KEYS:"adal.token.keys",ACCESS_TOKEN_KEY:"adal.access.token.key",EXPIRATION_KEY:"adal.expiration.key",STATE_LOGIN:"adal.state.login",STATE_RENEW:"adal.state.renew",NONCE_IDTOKEN:"adal.nonce.idtoken",SESSION_STATE:"adal.session.state",USERNAME:"adal.username",IDTOKEN:"adal.idtoken",ERROR:"adal.error",ERROR_DESCRIPTION:"adal.error.description",LOGIN_REQUEST:"adal.login.request",LOGIN_ERROR:"adal.login.error",RENEW_STATUS:"adal.token.renew.status",ANGULAR_LOGIN_REQUEST:"adal.angular.login.request"},RESOURCE_DELIMETER:"|",CACHE_DELIMETER:"||",LOADFRAME_TIMEOUT:6e3,TOKEN_RENEW_STATUS_CANCELED:"Canceled",TOKEN_RENEW_STATUS_COMPLETED:"Completed",TOKEN_RENEW_STATUS_IN_PROGRESS:"In Progress",LOGGING_LEVEL:{ERROR:0,WARN:1,INFO:2,VERBOSE:3},LEVEL_STRING_MAP:{0:"ERROR:",1:"WARNING:",2:"INFO:",3:"VERBOSE:"},POPUP_WIDTH:483,POPUP_HEIGHT:600},AuthenticationContext.prototype._singletonInstance)return AuthenticationContext.prototype._singletonInstance;if(AuthenticationContext.prototype._singletonInstance=this,this.instance="https://login.microsoftonline.com/",this.config={},this.callback=null,this.popUp=!1,this.isAngular=!1,this._user=null,this._activeRenewals={},this._loginInProgress=!1,this._acquireTokenInProgress=!1,this._renewStates=[],this._callBackMappedToRenewStates={},this._callBacksMappedToRenewStates={},this._openedWindows=[],this._requestType=this.REQUEST_TYPE.LOGIN,window._adalInstance=this,a.displayCall&&"function"!=typeof a.displayCall)throw new Error("displayCall is not a function");if(!a.clientId)throw new Error("clientId is required");this.config=this._cloneConfig(a),void 0===this.config.navigateToLoginRequestUrl&&(this.config.navigateToLoginRequestUrl=!0),this.config.popUp&&(this.popUp=!0),this.config.callback&&"function"==typeof this.config.callback&&(this.callback=this.config.callback),this.config.instance&&(this.instance=this.config.instance),this.config.loginResource||(this.config.loginResource=this.config.clientId),this.config.redirectUri||(this.config.redirectUri=window.location.href.split("?")[0].split("#")[0]),this.config.postLogoutRedirectUri||(this.config.postLogoutRedirectUri=window.location.href.split("?")[0].split("#")[0]),this.config.anonymousEndpoints||(this.config.anonymousEndpoints=[]),this.config.isAngular&&(this.isAngular=this.config.isAngular),this.config.loadFrameTimeout&&(this.CONSTANTS.LOADFRAME_TIMEOUT=this.config.loadFrameTimeout)},"undefined"!=typeof window&&(window.Logging={piiLoggingEnabled:!1,level:0,log:function(a){}}),AuthenticationContext.prototype.login=function(){if(this._loginInProgress)return void this.info("Login in progress");this._loginInProgress=!0;var a=this._guid();this.config.state=a,this._idTokenNonce=this._guid();var b=this._getItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST);b&&""!==b?this._saveItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST,""):b=window.location.href,this.verbose("Expected state: "+a+" startPage:"+b),this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST,b),this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR,""),this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN,a,!0),this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN,this._idTokenNonce,!0),this._saveItem(this.CONSTANTS.STORAGE.ERROR,""),this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION,"");var c=this._getNavigateUrl("id_token",null)+"&nonce="+encodeURIComponent(this._idTokenNonce);this.config.displayCall?this.config.displayCall(c):this.popUp?(this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN,""),this._renewStates.push(a),this.registerCallback(a,this.config.clientId,this.callback),this._loginPopup(c)):this.promptUser(c)},AuthenticationContext.prototype._openPopup=function(a,b,c,d){try{var e=window.screenLeft?window.screenLeft:window.screenX,f=window.screenTop?window.screenTop:window.screenY,g=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,h=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight,i=g/2-c/2+e,j=h/2-d/2+f,k=window.open(a,b,"width="+c+", height="+d+", top="+j+", left="+i);return k.focus&&k.focus(),k}catch(a){return this.warn("Error opening popup, "+a.message),this._loginInProgress=!1,this._acquireTokenInProgress=!1,null}},AuthenticationContext.prototype._handlePopupError=function(a,b,c,d,e){this.warn(d),this._saveItem(this.CONSTANTS.STORAGE.ERROR,c),this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION,d),this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR,e),b&&this._activeRenewals[b]&&(this._activeRenewals[b]=null),this._loginInProgress=!1,this._acquireTokenInProgress=!1,a&&a(d,null,c)},AuthenticationContext.prototype._loginPopup=function(a,b,c){var d=this._openPopup(a,"login",this.CONSTANTS.POPUP_WIDTH,this.CONSTANTS.POPUP_HEIGHT),e=c||this.callback;if(null==d){var f="Popup Window is null. This can happen if you are using IE";return void this._handlePopupError(e,b,"Error opening popup",f,f)}if(this._openedWindows.push(d),-1!=this.config.redirectUri.indexOf("#"))var g=this.config.redirectUri.split("#")[0];else var g=this.config.redirectUri;var h=this,i=window.setInterval(function(){if(!d||d.closed||void 0===d.closed){var a="Popup Window closed",c="Popup Window closed by UI action/ Popup Window handle destroyed due to cross zone navigation in IE/Edge";return h.isAngular&&h._broadcast("adal:popUpClosed",c+h.CONSTANTS.RESOURCE_DELIMETER+a),h._handlePopupError(e,b,a,c,c),void window.clearInterval(i)}try{var f=d.location;if(-1!=encodeURI(f.href).indexOf(encodeURI(g)))return h.isAngular?h._broadcast("adal:popUpHashChanged",f.hash):h.handleWindowCallback(f.hash),window.clearInterval(i),h._loginInProgress=!1,h._acquireTokenInProgress=!1,h.info("Closing popup window"),h._openedWindows=[],void d.close()}catch(a){}},1)},AuthenticationContext.prototype._broadcast=function(a,b){!function(){function a(a,b){b=b||{bubbles:!1,cancelable:!1,detail:void 0};var c=document.createEvent("CustomEvent");return c.initCustomEvent(a,b.bubbles,b.cancelable,b.detail),c}if("function"==typeof window.CustomEvent)return!1;a.prototype=window.Event.prototype,window.CustomEvent=a}();var c=new CustomEvent(a,{detail:b});window.dispatchEvent(c)},AuthenticationContext.prototype.loginInProgress=function(){return this._loginInProgress},AuthenticationContext.prototype._hasResource=function(a){var b=this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);return b&&!this._isEmpty(b)&&b.indexOf(a+this.CONSTANTS.RESOURCE_DELIMETER)>-1},AuthenticationContext.prototype.getCachedToken=function(a){if(!this._hasResource(a))return null;var b=this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY+a),c=this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY+a),d=this.config.expireOffsetSeconds||300;return c&&c>this._now()+d?b:(this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY+a,""),this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY+a,0),null)},AuthenticationContext.prototype.getCachedUser=function(){if(this._user)return this._user;var a=this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);return this._user=this._createUser(a),this._user},AuthenticationContext.prototype.registerCallback=function(a,b,c){this._activeRenewals[b]=a,this._callBacksMappedToRenewStates[a]||(this._callBacksMappedToRenewStates[a]=[]);var d=this;this._callBacksMappedToRenewStates[a].push(c),this._callBackMappedToRenewStates[a]||(this._callBackMappedToRenewStates[a]=function(c,e,f,g){d._activeRenewals[b]=null;for(var h=0;h<d._callBacksMappedToRenewStates[a].length;++h)try{d._callBacksMappedToRenewStates[a][h](c,e,f,g)}catch(f){d.warn(f)}d._callBacksMappedToRenewStates[a]=null,d._callBackMappedToRenewStates[a]=null})},AuthenticationContext.prototype._renewToken=function(a,b,c){this.info("renewToken is called for resource:"+a);var d=this._addAdalFrame("adalRenewFrame"+a),e=this._guid()+"|"+a;this.config.state=e,this._renewStates.push(e),this.verbose("Renew token Expected state: "+e),c=c||"token";var f=this._urlRemoveQueryStringParameter(this._getNavigateUrl(c,a),"prompt");c===this.RESPONSE_TYPE.ID_TOKEN_TOKEN&&(this._idTokenNonce=this._guid(),this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN,this._idTokenNonce,!0),f+="&nonce="+encodeURIComponent(this._idTokenNonce)),f+="&prompt=none",f=this._addHintParameters(f),this.registerCallback(e,a,b),this.verbosePii("Navigate to:"+f),d.src="about:blank",this._loadFrameTimeout(f,"adalRenewFrame"+a,a)},AuthenticationContext.prototype._renewIdToken=function(a,b){this.info("renewIdToken is called");var c=this._addAdalFrame("adalIdTokenFrame"),d=this._guid()+"|"+this.config.clientId;this._idTokenNonce=this._guid(),this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN,this._idTokenNonce,!0),this.config.state=d,this._renewStates.push(d),this.verbose("Renew Idtoken Expected state: "+d);var e=null===b||void 0===b?null:this.config.clientId,b=b||"id_token",f=this._urlRemoveQueryStringParameter(this._getNavigateUrl(b,e),"prompt");f+="&prompt=none",f=this._addHintParameters(f),f+="&nonce="+encodeURIComponent(this._idTokenNonce),this.registerCallback(d,this.config.clientId,a),this.verbosePii("Navigate to:"+f),c.src="about:blank",this._loadFrameTimeout(f,"adalIdTokenFrame",this.config.clientId)},AuthenticationContext.prototype._urlContainsQueryStringParameter=function(a,b){return new RegExp("[\\?&]"+a+"=").test(b)},AuthenticationContext.prototype._urlRemoveQueryStringParameter=function(a,b){var c=new RegExp("(\\&"+b+"=)[^&]+");return a=a.replace(c,""),c=new RegExp("("+b+"=)[^&]+&"),a=a.replace(c,""),c=new RegExp("("+b+"=)[^&]+"),a=a.replace(c,"")},AuthenticationContext.prototype._loadFrameTimeout=function(a,b,c){this.verbose("Set loading state to pending for: "+c),this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS+c,this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS),this._loadFrame(a,b);var d=this;setTimeout(function(){if(d._getItem(d.CONSTANTS.STORAGE.RENEW_STATUS+c)===d.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS){d.verbose("Loading frame has timed out after: "+d.CONSTANTS.LOADFRAME_TIMEOUT/1e3+" seconds for resource "+c);var a=d._activeRenewals[c];a&&d._callBackMappedToRenewStates[a]&&d._callBackMappedToRenewStates[a]("Token renewal operation failed due to timeout",null,"Token Renewal Failed"),d._saveItem(d.CONSTANTS.STORAGE.RENEW_STATUS+c,d.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED)}},d.CONSTANTS.LOADFRAME_TIMEOUT)},AuthenticationContext.prototype._loadFrame=function(a,b){var c=this;c.info("LoadFrame: "+b);var d=b;setTimeout(function(){var b=c._addAdalFrame(d);""!==b.src&&"about:blank"!==b.src||(b.src=a,c._loadFrame(a,d))},500)},AuthenticationContext.prototype.acquireToken=function(a,b){if(this._isEmpty(a))return this.warn("resource is required"),void b("resource is required",null,"resource is required");var c=this.getCachedToken(a);return c?(this.info("Token is already in cache for resource:"+a),void b(null,c,null)):this._user||this.config.extraQueryParameter&&-1!==this.config.extraQueryParameter.indexOf("login_hint")?void(this._activeRenewals[a]?this.registerCallback(this._activeRenewals[a],a,b):(this._requestType=this.REQUEST_TYPE.RENEW_TOKEN,a===this.config.clientId?this._user?(this.verbose("renewing idtoken"),this._renewIdToken(b)):(this.verbose("renewing idtoken and access_token"),this._renewIdToken(b,this.RESPONSE_TYPE.ID_TOKEN_TOKEN)):this._user?(this.verbose("renewing access_token"),this._renewToken(a,b)):(this.verbose("renewing idtoken and access_token"),this._renewToken(a,b,this.RESPONSE_TYPE.ID_TOKEN_TOKEN)))):(this.warn("User login is required"),void b("User login is required",null,"login required"))},AuthenticationContext.prototype.acquireTokenPopup=function(a,b,c,d){if(this._isEmpty(a))return this.warn("resource is required"),void d("resource is required",null,"resource is required");if(!this._user)return this.warn("User login is required"),void d("User login is required",null,"login required");if(this._acquireTokenInProgress)return this.warn("Acquire token interactive is already in progress"),void d("Acquire token interactive is already in progress",null,"Acquire token interactive is already in progress");var e=this._guid()+"|"+a;this.config.state=e,this._renewStates.push(e),this._requestType=this.REQUEST_TYPE.RENEW_TOKEN,this.verbose("Renew token Expected state: "+e);var f=this._urlRemoveQueryStringParameter(this._getNavigateUrl("token",a),"prompt");if(f+="&prompt=select_account",b&&(f+=b),c&&-1===f.indexOf("&claims"))f+="&claims="+encodeURIComponent(c);else if(c&&-1!==f.indexOf("&claims"))throw new Error("Claims cannot be passed as an extraQueryParameter");f=this._addHintParameters(f),this._acquireTokenInProgress=!0,this.info("acquireToken interactive is called for the resource "+a),this.registerCallback(e,a,d),this._loginPopup(f,a,d)},AuthenticationContext.prototype.acquireTokenRedirect=function(a,b,c){if(this._isEmpty(a))return this.warn("resource is required"),void d("resource is required",null,"resource is required");var d=this.callback;if(!this._user)return this.warn("User login is required"),void d("User login is required",null,"login required");if(this._acquireTokenInProgress)return this.warn("Acquire token interactive is already in progress"),void d("Acquire token interactive is already in progress",null,"Acquire token interactive is already in progress");var e=this._guid()+"|"+a;this.config.state=e,this.verbose("Renew token Expected state: "+e);var f=this._urlRemoveQueryStringParameter(this._getNavigateUrl("token",a),"prompt");if(f+="&prompt=select_account",b&&(f+=b),c&&-1===f.indexOf("&claims"))f+="&claims="+encodeURIComponent(c);else if(c&&-1!==f.indexOf("&claims"))throw new Error("Claims cannot be passed as an extraQueryParameter");f=this._addHintParameters(f),this._acquireTokenInProgress=!0,this.info("acquireToken interactive is called for the resource "+a),this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST,window.location.href),this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW,e,!0),this.promptUser(f)},AuthenticationContext.prototype.promptUser=function(a){a?(this.infoPii("Navigate to:"+a),window.location.replace(a)):this.info("Navigate url is empty")},AuthenticationContext.prototype.clearCache=function(){this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST,""),this._saveItem(this.CONSTANTS.STORAGE.ANGULAR_LOGIN_REQUEST,""),this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE,""),this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN,""),this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW,""),this._renewStates=[],this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN,""),this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN,""),this._saveItem(this.CONSTANTS.STORAGE.ERROR,""),this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION,""),this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR,""),this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR,"");var a=this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);if(!this._isEmpty(a)){a=a.split(this.CONSTANTS.RESOURCE_DELIMETER);for(var b=0;b<a.length&&""!==a[b];b++)this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY+a[b],""),this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY+a[b],0)}this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS,"")},AuthenticationContext.prototype.clearCacheForResource=function(a){this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW,""),this._saveItem(this.CONSTANTS.STORAGE.ERROR,""),this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION,""),this._hasResource(a)&&(this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY+a,""),this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY+a,0))},AuthenticationContext.prototype.logOut=function(){this.clearCache(),this._user=null;var a;if(this.config.logOutUri)a=this.config.logOutUri;else{var b="common",c="";this.config.tenant&&(b=this.config.tenant),this.config.postLogoutRedirectUri&&(c="post_logout_redirect_uri="+encodeURIComponent(this.config.postLogoutRedirectUri)),a=this.instance+b+"/oauth2/logout?"+c}this.infoPii("Logout navigate to: "+a),this.promptUser(a)},AuthenticationContext.prototype._isEmpty=function(a){return void 0===a||!a||0===a.length},AuthenticationContext.prototype.getUser=function(a){if("function"!=typeof a)throw new Error("callback is not a function");if(this._user)return void a(null,this._user);var b=this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);this._isEmpty(b)?(this.warn("User information is not available"),a("User information is not available",null)):(this.info("User exists in cache: "),this._user=this._createUser(b),a(null,this._user))},AuthenticationContext.prototype._addHintParameters=function(a){if(this._user&&this._user.profile)if(this._user.profile.sid&&-1!==a.indexOf("&prompt=none"))this._urlContainsQueryStringParameter("sid",a)||(a+="&sid="+encodeURIComponent(this._user.profile.sid));else if(this._user.profile.upn&&(this._urlContainsQueryStringParameter("login_hint",a)||(a+="&login_hint="+encodeURIComponent(this._user.profile.upn)),!this._urlContainsQueryStringParameter("domain_hint",a)&&this._user.profile.upn.indexOf("@")>-1)){var b=this._user.profile.upn.split("@");a+="&domain_hint="+encodeURIComponent(b[b.length-1])}return a},AuthenticationContext.prototype._createUser=function(a){var b=null,c=this._extractIdToken(a);return c&&c.hasOwnProperty("aud")&&(c.aud.toLowerCase()===this.config.clientId.toLowerCase()?(b={userName:"",profile:c},c.hasOwnProperty("upn")?b.userName=c.upn:c.hasOwnProperty("email")&&(b.userName=c.email)):this.warn("IdToken has invalid aud field")),b},AuthenticationContext.prototype._getHash=function(a){return a.indexOf("#/")>-1?a=a.substring(a.indexOf("#/")+2):a.indexOf("#")>-1&&(a=a.substring(1)),a},AuthenticationContext.prototype.isCallback=function(a){a=this._getHash(a);var b=this._deserialize(a);return b.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)||b.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)||b.hasOwnProperty(this.CONSTANTS.ID_TOKEN)},AuthenticationContext.prototype.getLoginError=function(){return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR)},AuthenticationContext.prototype.getRequestInfo=function(a){a=this._getHash(a);var b=this._deserialize(a),c={valid:!1,parameters:{},stateMatch:!1,stateResponse:"",requestType:this.REQUEST_TYPE.UNKNOWN};if(b&&(c.parameters=b,b.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)||b.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)||b.hasOwnProperty(this.CONSTANTS.ID_TOKEN))){c.valid=!0;var d="";if(!b.hasOwnProperty("state"))return this.warn("No state returned"),c;if(this.verbose("State: "+b.state),d=b.state,c.stateResponse=d,this._matchState(c))return c;if(!c.stateMatch&&window.parent){c.requestType=this._requestType;for(var e=this._renewStates,f=0;f<e.length;f++)if(e[f]===c.stateResponse){c.stateMatch=!0;break}}}return c},AuthenticationContext.prototype._matchNonce=function(a){var b=this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN);if(b){b=b.split(this.CONSTANTS.CACHE_DELIMETER);for(var c=0;c<b.length;c++)if(b[c]===a.profile.nonce)return!0}return!1},AuthenticationContext.prototype._matchState=function(a){var b=this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN);if(b){b=b.split(this.CONSTANTS.CACHE_DELIMETER);for(var c=0;c<b.length;c++)if(b[c]===a.stateResponse)return a.requestType=this.REQUEST_TYPE.LOGIN,a.stateMatch=!0,!0}var d=this._getItem(this.CONSTANTS.STORAGE.STATE_RENEW);if(d){d=d.split(this.CONSTANTS.CACHE_DELIMETER);for(var c=0;c<d.length;c++)if(d[c]===a.stateResponse)return a.requestType=this.REQUEST_TYPE.RENEW_TOKEN,a.stateMatch=!0,!0}return!1},AuthenticationContext.prototype._getResourceFromState=function(a){if(a){var b=a.indexOf("|");if(b>-1&&b+1<a.length)return a.substring(b+1)}return""},AuthenticationContext.prototype.saveTokenFromHash=function(a){this.info("State status:"+a.stateMatch+"; Request type:"+a.requestType),this._saveItem(this.CONSTANTS.STORAGE.ERROR,""),this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION,"");var b=this._getResourceFromState(a.stateResponse);if(a.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION))this.infoPii("Error :"+a.parameters.error+"; Error description:"+a.parameters[this.CONSTANTS.ERROR_DESCRIPTION]),this._saveItem(this.CONSTANTS.STORAGE.ERROR,a.parameters.error),this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION,a.parameters[this.CONSTANTS.ERROR_DESCRIPTION]),a.requestType===this.REQUEST_TYPE.LOGIN&&(this._loginInProgress=!1,this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR,a.parameters.error_description));else if(a.stateMatch){this.info("State is right"),a.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)&&this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE,a.parameters[this.CONSTANTS.SESSION_STATE]);var c;a.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)&&(this.info("Fragment has access token"),this._hasResource(b)||(c=this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS)||"",this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS,c+b+this.CONSTANTS.RESOURCE_DELIMETER)),this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY+b,a.parameters[this.CONSTANTS.ACCESS_TOKEN]),this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY+b,this._expiresIn(a.parameters[this.CONSTANTS.EXPIRES_IN]))),a.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)&&(this.info("Fragment has id token"),this._loginInProgress=!1,this._user=this._createUser(a.parameters[this.CONSTANTS.ID_TOKEN]),this._user&&this._user.profile?this._matchNonce(this._user)?(this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN,a.parameters[this.CONSTANTS.ID_TOKEN]),b=this.config.loginResource?this.config.loginResource:this.config.clientId,this._hasResource(b)||(c=this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS)||"",this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS,c+b+this.CONSTANTS.RESOURCE_DELIMETER)),this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY+b,a.parameters[this.CONSTANTS.ID_TOKEN]),this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY+b,this._user.profile.exp)):(this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR,"Nonce received: "+this._user.profile.nonce+" is not same as requested: "+this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)),this._user=null):(a.parameters.error="invalid id_token",a.parameters.error_description="Invalid id_token. id_token: "+a.parameters[this.CONSTANTS.ID_TOKEN],this._saveItem(this.CONSTANTS.STORAGE.ERROR,"invalid id_token"),this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION,"Invalid id_token. id_token: "+a.parameters[this.CONSTANTS.ID_TOKEN])))}else a.parameters.error="Invalid_state",a.parameters.error_description="Invalid_state. state: "+a.stateResponse,this._saveItem(this.CONSTANTS.STORAGE.ERROR,"Invalid_state"),this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION,"Invalid_state. state: "+a.stateResponse);this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS+b,this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED)},AuthenticationContext.prototype.getResourceForEndpoint=function(a){if(this.config&&this.config.anonymousEndpoints)for(var b=0;b<this.config.anonymousEndpoints.length;b++)if(a.indexOf(this.config.anonymousEndpoints[b])>-1)return null;if(this.config&&this.config.endpoints)for(var c in this.config.endpoints)if(a.indexOf(c)>-1)return this.config.endpoints[c];return a.indexOf("http://")>-1||a.indexOf("https://")>-1?this._getHostFromUri(a)===this._getHostFromUri(this.config.redirectUri)?this.config.loginResource:null:this.config.loginResource},AuthenticationContext.prototype._getHostFromUri=function(a){var b=String(a).replace(/^(https?:)\/\//,"");return b=b.split("/")[0]},AuthenticationContext.prototype.handleWindowCallback=function(a){if(null==a&&(a=window.location.hash),this.isCallback(a)){var b=null,c=!1;this._openedWindows.length>0&&this._openedWindows[this._openedWindows.length-1].opener&&this._openedWindows[this._openedWindows.length-1].opener._adalInstance?(b=this._openedWindows[this._openedWindows.length-1].opener._adalInstance,c=!0):window.parent&&window.parent._adalInstance&&(b=window.parent._adalInstance);var d,e,f=b.getRequestInfo(a),g=null;e=c||window.parent!==window?b._callBackMappedToRenewStates[f.stateResponse]:b.callback,b.info("Returned from redirect url"),b.saveTokenFromHash(f),f.requestType===this.REQUEST_TYPE.RENEW_TOKEN&&window.parent?(window.parent!==window?b.verbose("Window is in iframe, acquiring token silently"):b.verbose("acquiring token interactive in progress"),d=f.parameters[b.CONSTANTS.ACCESS_TOKEN]||f.parameters[b.CONSTANTS.ID_TOKEN],g=b.CONSTANTS.ACCESS_TOKEN):f.requestType===this.REQUEST_TYPE.LOGIN&&(d=f.parameters[b.CONSTANTS.ID_TOKEN],g=b.CONSTANTS.ID_TOKEN);var h=f.parameters[b.CONSTANTS.ERROR_DESCRIPTION],i=f.parameters[b.CONSTANTS.ERROR];try{e&&e(h,d,i,g)}catch(a){b.error("Error occurred in user defined callback function: "+a)}window.parent!==window||c||(b.config.navigateToLoginRequestUrl?window.location.href=b._getItem(b.CONSTANTS.STORAGE.LOGIN_REQUEST):window.location.hash="")}},AuthenticationContext.prototype._getNavigateUrl=function(a,b){var c="common";this.config.tenant&&(c=this.config.tenant);var d=this.instance+c+"/oauth2/authorize"+this._serialize(a,this.config,b)+this._addLibMetadata();return this.info("Navigate url:"+d),d},AuthenticationContext.prototype._extractIdToken=function(a){var b=this._decodeJwt(a);if(!b)return null;try{var c=b.JWSPayload,d=this._base64DecodeStringUrlSafe(c);return d?JSON.parse(d):(this.info("The returned id_token could not be base64 url safe decoded."),null)}catch(a){this.error("The returned id_token could not be decoded",a)}return null},AuthenticationContext.prototype._base64DecodeStringUrlSafe=function(a){return a=a.replace(/-/g,"+").replace(/_/g,"/"),window.atob?decodeURIComponent(escape(window.atob(a))):decodeURIComponent(escape(this._decode(a)))},AuthenticationContext.prototype._decode=function(a){var b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";a=String(a).replace(/=+$/,"");var c=a.length;if(c%4==1)throw new Error("The token to be decoded is not correctly encoded.");for(var d,e,f,g,h,i,j,k,l="",m=0;m<c;m+=4){if(d=b.indexOf(a.charAt(m)),e=b.indexOf(a.charAt(m+1)),f=b.indexOf(a.charAt(m+2)),g=b.indexOf(a.charAt(m+3)),m+2===c-1){h=d<<18|e<<12|f<<6,i=h>>16&255,j=h>>8&255,l+=String.fromCharCode(i,j);break}if(m+1===c-1){h=d<<18|e<<12,i=h>>16&255,l+=String.fromCharCode(i);break}h=d<<18|e<<12|f<<6|g,i=h>>16&255,j=h>>8&255,k=255&h,l+=String.fromCharCode(i,j,k)}return l},AuthenticationContext.prototype._decodeJwt=function(a){if(this._isEmpty(a))return null;var b=/^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/,c=b.exec(a);return!c||c.length<4?(this.warn("The returned id_token is not parseable."),null):{header:c[1],JWSPayload:c[2],JWSSig:c[3]}},AuthenticationContext.prototype._convertUrlSafeToRegularBase64EncodedString=function(a){return a.replace("-","+").replace("_","/")},AuthenticationContext.prototype._serialize=function(a,b,c){var d=[];if(null!==b){d.push("?response_type="+a),d.push("client_id="+encodeURIComponent(b.clientId)),c&&d.push("resource="+encodeURIComponent(c)),d.push("redirect_uri="+encodeURIComponent(b.redirectUri)),d.push("state="+encodeURIComponent(b.state)),b.hasOwnProperty("slice")&&d.push("slice="+encodeURIComponent(b.slice)),b.hasOwnProperty("extraQueryParameter")&&d.push(b.extraQueryParameter);var e=b.correlationId?b.correlationId:this._guid();d.push("client-request-id="+encodeURIComponent(e))}return d.join("&")},AuthenticationContext.prototype._deserialize=function(a){var b,c=/\+/g,d=/([^&=]+)=([^&]*)/g,e=function(a){return decodeURIComponent(a.replace(c," "))},f={};for(b=d.exec(a);b;)f[e(b[1])]=e(b[2]),b=d.exec(a);return f},AuthenticationContext.prototype._decimalToHex=function(a){for(var b=a.toString(16);b.length<2;)b="0"+b;return b},AuthenticationContext.prototype._guid=function(){var a=window.crypto||window.msCrypto;if(a&&a.getRandomValues){var b=new Uint8Array(16);return a.getRandomValues(b),b[6]|=64,b[6]&=79,b[8]|=128,b[8]&=191,this._decimalToHex(b[0])+this._decimalToHex(b[1])+this._decimalToHex(b[2])+this._decimalToHex(b[3])+"-"+this._decimalToHex(b[4])+this._decimalToHex(b[5])+"-"+this._decimalToHex(b[6])+this._decimalToHex(b[7])+"-"+this._decimalToHex(b[8])+this._decimalToHex(b[9])+"-"+this._decimalToHex(b[10])+this._decimalToHex(b[11])+this._decimalToHex(b[12])+this._decimalToHex(b[13])+this._decimalToHex(b[14])+this._decimalToHex(b[15])}for(var c="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx",d="0123456789abcdef",e=0,f="",g=0;g<36;g++)"-"!==c[g]&&"4"!==c[g]&&(e=16*Math.random()|0),"x"===c[g]?f+=d[e]:"y"===c[g]?(e&=3,e|=8,f+=d[e]):f+=c[g];return f},AuthenticationContext.prototype._expiresIn=function(a){return a||(a=3599),this._now()+parseInt(a,10)},AuthenticationContext.prototype._now=function(){return Math.round((new Date).getTime()/1e3)},AuthenticationContext.prototype._addAdalFrame=function(a){if(void 0!==a){this.info("Add adal frame to document:"+a);var b=document.getElementById(a);if(!b){if(document.createElement&&document.documentElement&&(window.opera||-1===window.navigator.userAgent.indexOf("MSIE 5.0"))){var c=document.createElement("iframe");c.setAttribute("id",a),c.setAttribute("aria-hidden","true"),c.style.visibility="hidden",c.style.position="absolute",c.style.width=c.style.height=c.borderWidth="0px",b=document.getElementsByTagName("body")[0].appendChild(c)}else document.body&&document.body.insertAdjacentHTML&&document.body.insertAdjacentHTML("beforeEnd",'<iframe name="'+a+'" id="'+a+'" style="display:none"></iframe>');window.frames&&window.frames[a]&&(b=window.frames[a])}return b}},AuthenticationContext.prototype._saveItem=function(a,b,c){if(this.config&&this.config.cacheLocation&&"localStorage"===this.config.cacheLocation){if(!this._supportsLocalStorage())return this.info("Local storage is not supported"),!1;if(c){var d=this._getItem(a)||"";localStorage.setItem(a,d+b+this.CONSTANTS.CACHE_DELIMETER)}else localStorage.setItem(a,b);return!0}return this._supportsSessionStorage()?(sessionStorage.setItem(a,b),!0):(this.info("Session storage is not supported"),!1)},AuthenticationContext.prototype._getItem=function(a){return this.config&&this.config.cacheLocation&&"localStorage"===this.config.cacheLocation?this._supportsLocalStorage()?localStorage.getItem(a):(this.info("Local storage is not supported"),null):this._supportsSessionStorage()?sessionStorage.getItem(a):(this.info("Session storage is not supported"),null)},AuthenticationContext.prototype._supportsLocalStorage=function(){try{return!!window.localStorage&&(window.localStorage.setItem("storageTest","A"),"A"==window.localStorage.getItem("storageTest")&&(window.localStorage.removeItem("storageTest"),!window.localStorage.getItem("storageTest")))}catch(a){return!1}},AuthenticationContext.prototype._supportsSessionStorage=function(){try{return!!window.sessionStorage&&(window.sessionStorage.setItem("storageTest","A"),"A"==window.sessionStorage.getItem("storageTest")&&(window.sessionStorage.removeItem("storageTest"),!window.sessionStorage.getItem("storageTest")))}catch(a){return!1}},AuthenticationContext.prototype._cloneConfig=function(a){if(null===a||"object"!=typeof a)return a;var b={};for(var c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b},AuthenticationContext.prototype._addLibMetadata=function(){return"&x-client-SKU=Js&x-client-Ver="+this._libVersion()},AuthenticationContext.prototype.log=function(a,b,c,d){if(a<=Logging.level){if(!Logging.piiLoggingEnabled&&d)return;var e=(new Date).toUTCString(),f="";f=this.config.correlationId?e+":"+this.config.correlationId+"-"+this._libVersion()+"-"+this.CONSTANTS.LEVEL_STRING_MAP[a]+" "+b:e+":"+this._libVersion()+"-"+this.CONSTANTS.LEVEL_STRING_MAP[a]+" "+b,c&&(f+="\nstack:\n"+c.stack),Logging.log(f)}},AuthenticationContext.prototype.error=function(a,b){this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR,a,b)},AuthenticationContext.prototype.warn=function(a){this.log(this.CONSTANTS.LOGGING_LEVEL.WARN,a,null)},AuthenticationContext.prototype.info=function(a){
this.log(this.CONSTANTS.LOGGING_LEVEL.INFO,a,null)},AuthenticationContext.prototype.verbose=function(a){this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE,a,null)},AuthenticationContext.prototype.errorPii=function(a,b){this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR,a,b,!0)},AuthenticationContext.prototype.warnPii=function(a){this.log(this.CONSTANTS.LOGGING_LEVEL.WARN,a,null,!0)},AuthenticationContext.prototype.infoPii=function(a){this.log(this.CONSTANTS.LOGGING_LEVEL.INFO,a,null,!0)},AuthenticationContext.prototype.verbosePii=function(a){this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE,a,null,!0)},AuthenticationContext.prototype._libVersion=function(){return"1.0.17"},"undefined"!=typeof module&&module.exports&&(module.exports=AuthenticationContext,module.exports.inject=function(a){return new AuthenticationContext(a)}),AuthenticationContext}();

/***/ }),

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.4+314e4831
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    return promise.then(function (value) {
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      return constructor.resolve(callback()).then(function () {
        throw reason;
      });
    });
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/car.ts":
/*!********************!*\
  !*** ./src/car.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Car = /** @class */ (function () {
    function Car() {
    }
    Car.prototype.drive = function () {
        console.log("brrrrrm ....");
    };
    return Car;
}());
exports.Car = Car;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(/*! ./util */ "./src/util.ts");
var car_1 = __webpack_require__(/*! ./car */ "./src/car.ts");
var state_1 = __webpack_require__(/*! ./state */ "./src/state.ts");
var spUtil = new util_1.SPUtil();
spUtil.log();
spUtil
    .getWebTitleCSOM()
    .then(function (data) { return console.log("Web Title received by CSOM is: " + data); });
spUtil.getWebTitleREST();
spUtil.getNewsItems().then(function (entries) {
    var html = "";
    entries.forEach(function (entry) { return (html += "<div>" + entry.Title + "</div>"); });
    var divResult = document.querySelector("#result");
    divResult.innerHTML = html;
});
spUtil.getListItemsPnP();
function drivePorsche() {
    var porsche = new car_1.Car();
    porsche.drive();
}
//export method to global namespace - otherwise is is not available for function call
window.drive = drivePorsche;
//exporting an object
window.state = new state_1.State();


/***/ }),

/***/ "./src/state.ts":
/*!**********************!*\
  !*** ./src/state.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(/*! ./util */ "./src/util.ts");
var State = /** @class */ (function () {
    function State() {
        this.util = new util_1.SPUtil();
    }
    State.prototype.init = function () {
        console.log("Initializing State");
    };
    return State;
}());
exports.State = State;


/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var es6_promise_1 = __webpack_require__(/*! es6-promise */ "./node_modules/es6-promise/dist/es6-promise.js");
var $ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
var sp_1 = __webpack_require__(/*! @pnp/sp */ "./node_modules/@pnp/sp/dist/sp.es5.js");
var SPUtil = /** @class */ (function () {
    function SPUtil() {
        var context = SP.ClientContext.get_current();
        this.baseUrl = context.get_url();
    }
    SPUtil.prototype.log = function () {
        console.log("hello word logged from SPUtil");
    };
    SPUtil.prototype.getWebTitleCSOM = function () {
        var _this = this;
        console.log("Executing CSOM");
        //wrapping call in Promise - not necessary but nicer to use
        return new es6_promise_1.Promise(function (resolve, reject) {
            var context = new SP.ClientContext(_this.baseUrl);
            var web = context.get_web();
            context.load(web);
            context.executeQueryAsync(function () {
                resolve(web.get_title());
            }, function (sender, args) {
                console.log("Request failed. " + args.get_message());
                reject("Err happened - see console for details");
            });
        });
    };
    SPUtil.prototype.getWebTitleREST = function () {
        console.log("executing rest");
        var qry = this.baseUrl + "/_api/web/title";
        $.ajax({
            type: "GET",
            url: qry,
            dataType: "json",
            headers: {
                accept: "application/json;odata=verbose"
            }
        })
            .then(function (data) {
            console.log("Web Title is: " + data.d.Title);
        })
            .fail(function (err) {
            console.log(err);
        });
    };
    SPUtil.prototype.getNewsItems = function () {
        var qry = this.baseUrl + "/_api/web/lists/getbytitle('News')/items";
        return new es6_promise_1.Promise(function (resolve, reject) {
            $.ajax({
                type: "GET",
                url: qry,
                dataType: "json",
                headers: {
                    accept: "application/json;odata=verbose",
                    "content-type": "application/json;odata=verbose"
                }
            })
                .then(function (data) {
                resolve(data.d.results);
            })
                .fail(function (err) {
                reject(err);
            });
        });
    };
    SPUtil.prototype.getListItemsPnP = function () {
        var list = sp_1.sp.web.lists.getByTitle("News");
        list.items
            .get()
            .then(function (items) {
            console.log("Items received using PnP");
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var item = items_1[_i];
                for (var prop in item) {
                    console.log(prop + ": " + item[prop]);
                }
            }
        })
            .catch(function (error) {
            console.log(error);
        });
    };
    return SPUtil;
}());
exports.SPUtil = SPUtil;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BwbnAvY29tbW9uL2Rpc3QvY29tbW9uLmVzNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBucC9sb2dnaW5nL2Rpc3QvbG9nZ2luZy5lczUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BwbnAvb2RhdGEvZGlzdC9vZGF0YS5lczUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BwbnAvc3AvZGlzdC9zcC5lczUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FkYWwtYW5ndWxhci9kaXN0L2FkYWwubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Nhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0YXRlLnRzIiwid2VicGFjazovLy8uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvQjtBQUNIOztBQUVqQjtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1DQUFtQyxFQUFFO0FBQ3RFLDhCQUE4Qiw2REFBNkQsRUFBRTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RCw0QkFBNEIsdUJBQXVCLGFBQWEsR0FBRztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0IsRUFBRSxnQkFBZ0IsYUFBYTtBQUNoRztBQUNBLDBCQUEwQixzQ0FBc0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxHQUFHO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFtRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUseUNBQXlDLGtCQUFrQixFQUFFLEVBQUU7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDRCQUE0QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUE2RTtBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMEJBQTBCLEVBQUU7QUFDakY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0VBQTBCO0FBQzlEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkRBQTZELG1DQUFtQyxFQUFFO0FBQ2xHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwrQkFBK0IsOENBQThDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyx3RkFBb0MsZ0RBQWdEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsdUZBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyx3RkFBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DLHdGQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0Msd0ZBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyx3RkFBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkVBQTJFLDBCQUEwQixFQUFFO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DLHlGQUF5RixRQUFRO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJCQUEyQixFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVMscUJBQXFCLHlCQUF5QixFQUFFLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySkFBbUQsdUJBQXVCO0FBQzFFLFNBQVMsb0JBQW9CLHdDQUF3QyxFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVLDBCQUEwQixFQUFFLEVBQUU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXFDLGNBQWMsNkJBQTZCLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RCxTQUFTO0FBQ1QsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBdUMsY0FBYyxxQkFBcUIsRUFBRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0VBQWdFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9FQUFvRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3REFBd0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUUsd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBdUIsZ0JBQWdCO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQXVCLGtCQUFrQjtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFVBQVUsNEJBQTRCLEVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOEJBQThCLDJCQUEyQixxQ0FBcUMsRUFBRTtBQUNoRyxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFB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QUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRix5Q0FBeUM7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FB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QUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0JBQXdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrSEFBOEQsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrSEFBOEQsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJCQUEyQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywyQkFBMkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhDQUE4Qyw4QkFBOEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZELGtDQUFrQyxrQkFBa0I7QUFDcEQsa0NBQWtDLGlCQUFpQjtBQUNuRCw0Q0FBNEMsMkJBQTJCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNDQUFzQztBQUNyRSxhQUFhO0FBQ2IsU0FBUztBQUNULG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFLDhDQUE4QywyQkFBMkI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LDZDQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpQ0FBaUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQixrQkFBa0IsRUFBRSxzQkFBc0Isa0JBQWtCLEVBQUU7QUFDaEcsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw0QkFBNEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBdUIscUJBQXFCO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw0QkFBNEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5REFBeUQ7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUseURBQXlEO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHlEQUF5RDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7Ozs7Ozs7Ozs7Ozs7QUMxcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0Esb0ZBQW9GOztBQUVwRjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxRQUFRLEdBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQiwwQkFBMEIsd0JBQXdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNB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QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaURBQWlELDBCQUEwQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsV0FBVyxrQkFBa0I7QUFDN0IsY0FBYztBQUNkLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxtQkFBbUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUEsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQsZUFBZSw2REFBNkQ7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUNGOzs7OztBQUtBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUMzblVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RCxLQUFLLENBQUMsVUFBUyxLQUFLO1lBQ25CLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBQ0gsYUFBQztBQUFELENBQUM7QUF6Rlksd0JBQU0iLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCIvKipcbkBsaWNlbnNlXG4gKiBAcG5wL2NvbW1vbiB2MS4yLjMgLSBwbnAgLSBwcm92aWRlcyBzaGFyZWQgZnVuY3Rpb25hbGl0eSBhY3Jvc3MgYWxsIHBucCBsaWJyYXJpZXNcbiAqIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3BucC9wbnBqcy9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogQ29weXJpZ2h0IChjKSAyMDE4IE1pY3Jvc29mdFxuICogZG9jczogaHR0cHM6Ly9wbnAuZ2l0aHViLmlvL3BucGpzL1xuICogc291cmNlOiBodHRwczpnaXRodWIuY29tL3BucC9wbnBqc1xuICogYnVnczogaHR0cHM6Ly9naXRodWIuY29tL3BucC9wbnBqcy9pc3N1ZXNcbiAqL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgaW5qZWN0IH0gZnJvbSAnYWRhbC1hbmd1bGFyL2Rpc3QvYWRhbC5taW4uanMnO1xuXG52YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gICAgICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcblxuLyoqXHJcbiAqIEdldHMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCB3aWxsIG1haW50YWluIGNvbnRleHQgYWNyb3NzIGFzeW5jIGNhbGxzLlxyXG4gKiBBbGxvd3MgZm9yIHRoZSBjYWxsaW5nIHBhdHRlcm4gZ2V0Q3R4Q2FsbGJhY2sodGhpc29iaiwgbWV0aG9kLCBtZXRob2RhcmcxLCBtZXRob2RhcmcyLCAuLi4pXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250ZXh0IFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZSAndGhpcycgdmFsdWUgaW4gdGhlIGNhbGxiYWNrXHJcbiAqIEBwYXJhbSBtZXRob2QgVGhlIG1ldGhvZCB0byB3aGljaCB3ZSB3aWxsIGFwcGx5IHRoZSBjb250ZXh0IGFuZCBwYXJhbWV0ZXJzXHJcbiAqIEBwYXJhbSBwYXJhbXMgT3B0aW9uYWwsIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHN1cHBseSB0byB0aGUgd3JhcHBlZCBtZXRob2Qgd2hlbiBpdCBpcyBpbnZva2VkXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDdHhDYWxsYmFjayhjb250ZXh0LCBtZXRob2QpIHtcclxuICAgIHZhciBwYXJhbXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgcGFyYW1zW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBtZXRob2QuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgYSB2YWx1ZSB0byBhIGRhdGVcclxuICpcclxuICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gd2hpY2ggd2Ugd2lsbCBhZGQgdW5pdHMsIGRvbmUgaW4gbG9jYWwgdGltZVxyXG4gKiBAcGFyYW0gaW50ZXJ2YWwgVGhlIG5hbWUgb2YgdGhlIGludGVydmFsIHRvIGFkZCwgb25lIG9mOiBbJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnXVxyXG4gKiBAcGFyYW0gdW5pdHMgVGhlIGFtb3VudCB0byBhZGQgdG8gZGF0ZSBvZiB0aGUgZ2l2ZW4gaW50ZXJ2YWxcclxuICpcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTk3OTI4L2hvdy10by1hZGQtMzAtbWludXRlcy10by1hLWphdmFzY3JpcHQtZGF0ZS1vYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIGRhdGVBZGQoZGF0ZSwgaW50ZXJ2YWwsIHVuaXRzKSB7XHJcbiAgICB2YXIgcmV0ID0gbmV3IERhdGUoZGF0ZSk7IC8vIGRvbid0IGNoYW5nZSBvcmlnaW5hbCBkYXRlXHJcbiAgICBzd2l0Y2ggKGludGVydmFsLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlIFwieWVhclwiOlxyXG4gICAgICAgICAgICByZXQuc2V0RnVsbFllYXIocmV0LmdldEZ1bGxZZWFyKCkgKyB1bml0cyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJxdWFydGVyXCI6XHJcbiAgICAgICAgICAgIHJldC5zZXRNb250aChyZXQuZ2V0TW9udGgoKSArIDMgKiB1bml0cyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJtb250aFwiOlxyXG4gICAgICAgICAgICByZXQuc2V0TW9udGgocmV0LmdldE1vbnRoKCkgKyB1bml0cyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJ3ZWVrXCI6XHJcbiAgICAgICAgICAgIHJldC5zZXREYXRlKHJldC5nZXREYXRlKCkgKyA3ICogdW5pdHMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiZGF5XCI6XHJcbiAgICAgICAgICAgIHJldC5zZXREYXRlKHJldC5nZXREYXRlKCkgKyB1bml0cyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJob3VyXCI6XHJcbiAgICAgICAgICAgIHJldC5zZXRUaW1lKHJldC5nZXRUaW1lKCkgKyB1bml0cyAqIDM2MDAwMDApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibWludXRlXCI6XHJcbiAgICAgICAgICAgIHJldC5zZXRUaW1lKHJldC5nZXRUaW1lKCkgKyB1bml0cyAqIDYwMDAwKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInNlY29uZFwiOlxyXG4gICAgICAgICAgICByZXQuc2V0VGltZShyZXQuZ2V0VGltZSgpICsgdW5pdHMgKiAxMDAwKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuLyoqXHJcbiAqIENvbWJpbmVzIGFuIGFyYml0cmFyeSBzZXQgb2YgcGF0aHMgZW5zdXJpbmcgYW5kIG5vcm1hbGl6ZXMgdGhlIHNsYXNoZXNcclxuICpcclxuICogQHBhcmFtIHBhdGhzIDAgdG8gbiBwYXRoIHBhcnRzIHRvIGNvbWJpbmVcclxuICovXHJcbmZ1bmN0aW9uIGNvbWJpbmUoKSB7XHJcbiAgICB2YXIgcGF0aHMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgcGF0aHNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoc1xyXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuICFzdHJpbmdJc051bGxPckVtcHR5KHBhdGgpOyB9KVxyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGgucmVwbGFjZSgvXltcXFxcfFxcL10vLCBcIlwiKS5yZXBsYWNlKC9bXFxcXHxcXC9dJC8sIFwiXCIpOyB9KVxyXG4gICAgICAgIC5qb2luKFwiL1wiKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcclxufVxyXG4vKipcclxuICogR2V0cyBhIHJhbmRvbSBzdHJpbmcgb2YgY2hhcnMgbGVuZ3RoXHJcbiAqXHJcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNDk0MDQvZ2VuZXJhdGUtcmFuZG9tLXN0cmluZy1jaGFyYWN0ZXJzLWluLWphdmFzY3JpcHRcclxuICpcclxuICogQHBhcmFtIGNoYXJzIFRoZSBsZW5ndGggb2YgdGhlIHJhbmRvbSBzdHJpbmcgdG8gZ2VuZXJhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFJhbmRvbVN0cmluZyhjaGFycykge1xyXG4gICAgdmFyIHRleHQgPSBuZXcgQXJyYXkoY2hhcnMpO1xyXG4gICAgdmFyIHBvc3NpYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OVwiO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyczsgaSsrKSB7XHJcbiAgICAgICAgdGV4dFtpXSA9IHBvc3NpYmxlLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3NzaWJsZS5sZW5ndGgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XHJcbn1cclxuLyoqXHJcbiAqIEdldHMgYSByYW5kb20gR1VJRCB2YWx1ZVxyXG4gKlxyXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9jcmVhdGUtZ3VpZC11dWlkLWluLWphdmFzY3JpcHRcclxuICovXHJcbi8qIHRzbGludDpkaXNhYmxlIG5vLWJpdHdpc2UgKi9cclxuZnVuY3Rpb24gZ2V0R1VJRCgpIHtcclxuICAgIHZhciBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB2YXIgZ3VpZCA9IFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIHZhciByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xyXG4gICAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XHJcbiAgICAgICAgcmV0dXJuIChjID09PSBcInhcIiA/IHIgOiAociAmIDB4MyB8IDB4OCkpLnRvU3RyaW5nKDE2KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGd1aWQ7XHJcbn1cclxuLyogdHNsaW50OmVuYWJsZSAqL1xyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgZnVuY3Rpb25cclxuICpcclxuICogQHBhcmFtIGNmIFRoZSB0aGluZyB0byB0ZXN0IGZvciBmdW5jdGlvbm5lc3NcclxuICovXHJcbmZ1bmN0aW9uIGlzRnVuYyhjZikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBjZiA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIGFuIG9iamVjdCBpcyBib3RoIGRlZmluZWQgYW5kIG5vdCBudWxsXHJcbiAqIEBwYXJhbSBvYmogT2JqZWN0IHRvIHRlc3RcclxuICovXHJcbmZ1bmN0aW9uIG9iamVjdERlZmluZWROb3ROdWxsKG9iaikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqICE9PSBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IEFycmF5IG9yIG5vdC5cclxuKi9cclxuZnVuY3Rpb24gaXNBcnJheShhcnJheSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnJheSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXkgJiYgdHlwZW9mIGFycmF5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBhcnJheS5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gZXh0ZW5kIHRoZSBnaXZlbiBvYmplY3QgYnkgZG9pbmcgYSBzaGFsbG93IGNvcHlcclxuICpcclxuICogQHBhcmFtIHRhcmdldCBUaGUgb2JqZWN0IHRvIHdoaWNoIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWRcclxuICogQHBhcmFtIHNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBmcm9tIHdoaWNoIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWRcclxuICogQHBhcmFtIG5vT3ZlcndyaXRlIElmIHRydWUgZXhpc3RpbmcgcHJvcGVydGllcyBvbiB0aGUgdGFyZ2V0IGFyZSBub3Qgb3ZlcndyaXR0ZW4gZnJvbSB0aGUgc291cmNlXHJcbiAqIEBwYXJhbSBmaWx0ZXIgSWYgcHJvdmlkZWQgYWxsb3dzIGFkZGl0aW9uYWwgZmlsdGVyaW5nIG9uIHdoYXQgcHJvcGVydGllcyBhcmUgY29waWVkIChwcm9wTmFtZTogc3RyaW5nKSA9PiBib29sZWFuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UsIG5vT3ZlcndyaXRlLCBmaWx0ZXIpIHtcclxuICAgIGlmIChub092ZXJ3cml0ZSA9PT0gdm9pZCAwKSB7IG5vT3ZlcndyaXRlID0gZmFsc2U7IH1cclxuICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9OyB9XHJcbiAgICBpZiAoIW9iamVjdERlZmluZWROb3ROdWxsKHNvdXJjZSkpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gZW5zdXJlIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGluZ3Mgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdHRlblxyXG4gICAgdmFyIGNoZWNrID0gbm9PdmVyd3JpdGUgPyBmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIShpIGluIG8pOyB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcclxuICAgIC8vIGZpbmFsIGZpbHRlciB3ZSB3aWxsIHVzZVxyXG4gICAgdmFyIGYgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gY2hlY2sodGFyZ2V0LCB2KSAmJiBmaWx0ZXIodik7IH07XHJcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKVxyXG4gICAgICAgIC5maWx0ZXIoZilcclxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uICh0LCB2KSB7XHJcbiAgICAgICAgdFt2XSA9IHNvdXJjZVt2XTtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH0sIHRhcmdldCk7XHJcbn1cclxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB1cmwgaXMgYWJzb2x1dGVcclxuICpcclxuICogQHBhcmFtIHVybCBUaGUgdXJsIHRvIGNoZWNrIHRvIHNlZSBpZiBpdCBpcyBhYnNvbHV0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNVcmxBYnNvbHV0ZSh1cmwpIHtcclxuICAgIHJldHVybiAvXmh0dHBzPzpcXC9cXC98XlxcL1xcLy9pLnRlc3QodXJsKTtcclxufVxyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiBhIHN0cmluZyBpcyBudWxsIG9yIGVtcHR5IG9yIHVuZGVmaW5lZFxyXG4gKlxyXG4gKiBAcGFyYW0gcyBUaGUgc3RyaW5nIHRvIHRlc3RcclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ0lzTnVsbE9yRW1wdHkocykge1xyXG4gICAgcmV0dXJuIHMgPT09IHVuZGVmaW5lZCB8fCBzID09PSBudWxsIHx8IHMubGVuZ3RoIDwgMTtcclxufVxyXG4vKipcclxuICogR2V0cyBhbiBhdHRyaWJ1dGUgdmFsdWUgZnJvbSBhbiBodG1sL3htbCBzdHJpbmcgYmxvY2suIE5PVEU6IGlmIHRoZSBpbnB1dCBhdHRyaWJ1dGUgdmFsdWUgaGFzXHJcbiAqIFJlZ0V4IHNwZWNpYWwgY2hhcmFjdGVycyB0aGV5IHdpbGwgYmUgZXNjYXBlZCBpbiB0aGUgcmV0dXJuZWQgc3RyaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSBodG1sIEhUTUwgdG8gc2VhcmNoXHJcbiAqIEBwYXJhbSBhdHRyTmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGZpbmRcclxuICovXHJcbmZ1bmN0aW9uIGdldEF0dHJWYWx1ZUZyb21TdHJpbmcoaHRtbCwgYXR0ck5hbWUpIHtcclxuICAgIC8vIG1ha2UgdGhlIGlucHV0IHNhZmUgZm9yIHJlZ2V4XHJcbiAgICBodG1sID0gaHRtbC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XHJcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChhdHRyTmFtZSArIFwiXFxcXHMqPz1cXFxccyo/KFxcXCJ8JykoW15cXFxcMV0qPylcXFxcMVwiLCBcImlcIik7XHJcbiAgICB2YXIgbWF0Y2ggPSByZWcuZXhlYyhodG1sKTtcclxuICAgIHJldHVybiBtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwID8gbWF0Y2hbMl0gOiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmVzIGd1aWQgdmFsdWVzIGFyZSByZXByZXNlbnRlZCBjb25zaXN0ZW50bHkgYXMgXCJlYTEyMzQ2My0xMzdkLTRhZTMtODliOC1jZjNmYzU3OGNhMDVcIlxyXG4gKlxyXG4gKiBAcGFyYW0gZ3VpZCBUaGUgY2FuZGlkYXRlIGd1aWRcclxuICovXHJcbmZ1bmN0aW9uIHNhbml0aXplR3VpZChndWlkKSB7XHJcbiAgICBpZiAoc3RyaW5nSXNOdWxsT3JFbXB0eShndWlkKSkge1xyXG4gICAgICAgIHJldHVybiBndWlkO1xyXG4gICAgfVxyXG4gICAgdmFyIG1hdGNoZXMgPSAvKFswLTlBLUZdezh9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSkvaS5leGVjKGd1aWQpO1xyXG4gICAgcmV0dXJuIG1hdGNoZXMgPT09IG51bGwgPyBndWlkIDogbWF0Y2hlc1sxXTtcclxufVxyXG4vKipcclxuICogU2hvcnRoYW5kIGZvciBvVG9TXHJcbiAqXHJcbiAqIEBwYXJhbSBvIEFueSB0eXBlIG9mIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24ganNTKG8pIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvKTtcclxufVxyXG4vKipcclxuICogU2hvcnRoYW5kIGZvciBPYmplY3QuaGFzT3duUHJvcGVydHlcclxuICpcclxuICogQHBhcmFtIG8gT2JqZWN0IHRvIGNoZWNrIGZvclxyXG4gKiBAcGFyYW0gcCBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxyXG4gKi9cclxuZnVuY3Rpb24gaE9QKG8sIHApIHtcclxuICAgIHJldHVybiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgfnVuaXF1ZSBoYXNoIGNvZGUgZm9yIHRoaXMgT2JqZWN0UGF0aFF1ZXVlXHJcbiAqXHJcbiAqIEZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYxMjI1NzEvc2ltcGxlLW5vbi1zZWN1cmUtaGFzaC1mdW5jdGlvbi1mb3ItamF2YXNjcmlwdFxyXG4gKi9cclxuLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxyXG5mdW5jdGlvbiBnZXRIYXNoQ29kZShzKSB7XHJcbiAgICB2YXIgaGFzaCA9IDA7XHJcbiAgICBpZiAocy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjaHIgPSBzLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hyO1xyXG4gICAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzaDtcclxufVxyXG4vLyB0c2xpbnQ6ZW5hYmxlOm5vLWJpdHdpc2VcblxuZnVuY3Rpb24gbWVyZ2VIZWFkZXJzKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIHRlbXAgPSBuZXcgUmVxdWVzdChcIlwiLCB7IGhlYWRlcnM6IHNvdXJjZSB9KTtcclxuICAgICAgICB0ZW1wLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBpZiAob2JqZWN0RGVmaW5lZE5vdE51bGwoc291cmNlKSkge1xyXG4gICAgICAgIHZhciBoZWFkZXJzID0gZXh0ZW5kKHRhcmdldC5oZWFkZXJzIHx8IHt9LCBzb3VyY2UuaGVhZGVycyk7XHJcbiAgICAgICAgdGFyZ2V0ID0gZXh0ZW5kKHRhcmdldCwgc291cmNlKTtcclxuICAgICAgICB0YXJnZXQuaGVhZGVycyA9IGhlYWRlcnM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1ha2VzIHJlcXVlc3RzIHVzaW5nIHRoZSBnbG9iYWwvd2luZG93IGZldGNoIEFQSVxyXG4gKi9cclxudmFyIEZldGNoQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmV0Y2hDbGllbnQoKSB7XHJcbiAgICB9XHJcbiAgICBGZXRjaENsaWVudC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbCQxLmZldGNoKHVybCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZldGNoQ2xpZW50O1xyXG59KCkpO1xyXG4vKipcclxuICogTWFrZXMgcmVxdWVzdHMgdXNpbmcgdGhlIGZldGNoIEFQSSBhZGRpbmcgdGhlIHN1cHBsaWVkIHRva2VuIHRvIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlclxyXG4gKi9cclxudmFyIEJlYXJlclRva2VuRmV0Y2hDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmVhcmVyVG9rZW5GZXRjaENsaWVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJlYXJlclRva2VuRmV0Y2hDbGllbnQoX3Rva2VuKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fdG9rZW4gPSBfdG9rZW47XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJlYXJlclRva2VuRmV0Y2hDbGllbnQucHJvdG90eXBlLCBcInRva2VuXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuIHx8IFwiXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IHRva2VuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQmVhcmVyVG9rZW5GZXRjaENsaWVudC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcbiAgICAgICAgbWVyZ2VIZWFkZXJzKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XHJcbiAgICAgICAgaGVhZGVycy5zZXQoXCJBdXRob3JpemF0aW9uXCIsIFwiQmVhcmVyIFwiICsgdGhpcy5fdG9rZW4pO1xyXG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZmV0Y2guY2FsbCh0aGlzLCB1cmwsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCZWFyZXJUb2tlbkZldGNoQ2xpZW50O1xyXG59KEZldGNoQ2xpZW50KSk7XG5cbi8qKlxyXG4gKiBBenVyZSBBRCBDbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3NlclxyXG4gKi9cclxudmFyIEFkYWxDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWRhbENsaWVudCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBBZGFsQ2xpZW50XHJcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgQXp1cmUgQXBwIElkXHJcbiAgICAgKiBAcGFyYW0gdGVuYW50IE9mZmljZSAzNjUgdGVuYW50IChFeDoge3RlbmFudH0ub25taWNyb3NvZnQuY29tKVxyXG4gICAgICogQHBhcmFtIHJlZGlyZWN0VXJpIFRoZSByZWRpcmVjdCB1cmwgdXNlZCB0byBhdXRoZW50aWNhdGUgdGhlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEFkYWxDbGllbnQoY2xpZW50SWQsIHRlbmFudCwgcmVkaXJlY3RVcmkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XHJcbiAgICAgICAgX3RoaXMudGVuYW50ID0gdGVuYW50O1xyXG4gICAgICAgIF90aGlzLnJlZGlyZWN0VXJpID0gcmVkaXJlY3RVcmk7XHJcbiAgICAgICAgX3RoaXMuX2Rpc3BsYXlDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuX2xvZ2luUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEFkYWxDbGllbnQgdXNpbmcgdGhlIHZhbHVlcyBvZiB0aGUgc3VwcGxpZWQgU1BGeCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNwZnhDb250ZXh0IEN1cnJlbnQgU1BGeCBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gY2xpZW50SWQgT3B0aW9uYWwgY2xpZW50IGlkIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSBidWlsdC1pbiBTUEZ4IGlkXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVXNpbmcgdGhpcyBtZXRob2QgYW5kIHRoZSBkZWZhdWx0IGNsaWVudElkIHJlcXVpcmVzIHRoYXQgdGhlIGZlYXR1cmVzIGRlc2NyaWJlZCBpblxyXG4gICAgICogdGhpcyBhcnRpY2xlIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3NoYXJlcG9pbnQvZGV2L3NwZngvdXNlLWFhZGh0dHBjbGllbnQgYXJlIGFjdGl2YXRlZCBpbiB0aGUgdGVuYW50LiBJZiBub3QgeW91IGNhblxyXG4gICAgICogY3JlYXQgeW91ciBvd24gYXBwLCBncmFudCBwZXJtaXNzaW9ucyBhbmQgdXNlIHRoYXQgY2xpZW50SWQgaGVyZSBhbG9uZyB3aXRoIHRoZSBTUEZ4IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgQWRhbENsaWVudC5mcm9tU1BGeENvbnRleHQgPSBmdW5jdGlvbiAoc3BmeENvbnRleHQsIGNsaWVuZElkKSB7XHJcbiAgICAgICAgaWYgKGNsaWVuZElkID09PSB2b2lkIDApIHsgY2xpZW5kSWQgPSBcImM1ODYzN2JiLWUyZTEtNDMxMi04YTAwLTA0YjVmZmNkMzQwM1wiOyB9XHJcbiAgICAgICAgLy8gdGhpcyBcIm1hZ2ljXCIgY2xpZW50IGlkIGlzIHRoZSBvbmUgdG8gd2hpY2ggcGVybWlzc2lvbnMgYXJlIGdyYW50ZWQgYmVoaW5kIHRoZSBzY2VuZXNcclxuICAgICAgICAvLyB0aGlzIHJlZGlyZWN0VXJsIGlzIHRoZSBwYWdlIGFzIHVzZWQgYnkgc3BmeFxyXG4gICAgICAgIHJldHVybiBuZXcgQWRhbENsaWVudChjbGllbmRJZCwgc3BmeENvbnRleHQucGFnZUNvbnRleHQuYWFkSW5mby50ZW5hbnRJZC50b1N0cmluZygpLCBjb21iaW5lKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sIFwiL19mb3Jtcy9zcGZ4c2luZ2xlc2lnbm9uLmFzcHhcIikpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29uZHVjdHMgdGhlIGZldGNoIG9wZXJ0YXRpb24gYWdhaW5zdCB0aGUgQUFEIHNlY3VyZWQgcmVzb3VyY2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIEFic29sdXRlIFVSTCBmb3IgdGhlIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFueSBmZXRjaCBvcHRpb25zIHBhc3NlZCB0byB0aGUgdW5kZXJseWluZyBmZXRjaCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBBZGFsQ2xpZW50LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghaXNVcmxBYnNvbHV0ZSh1cmwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGFic29sdXRlIHVybHMgdG8gQWRhbENsaWVudC5mZXRjaC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoZSB1cmwgd2UgYXJlIGNhbGxpbmcgaXMgdGhlIHJlc291cmNlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4odGhpcy5nZXRSZXNvdXJjZSh1cmwpKS50aGVuKGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICBfdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5mZXRjaC5jYWxsKF90aGlzLCB1cmwsIG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHRva2VuIGJhc2VkIG9uIHRoZSBjdXJyZW50IHVzZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVzb3VyY2UgVGhlIHJlc291cmNlIGZvciB3aGljaCB3ZSBhcmUgcmVxdWVzdGluZyBhIHRva2VuXHJcbiAgICAgKi9cclxuICAgIEFkYWxDbGllbnQucHJvdG90eXBlLmdldFRva2VuID0gZnVuY3Rpb24gKHJlc291cmNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5lbnN1cmVBdXRoQ29udGV4dCgpLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLmxvZ2luKCk7IH0pLnRoZW4oZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgICAgIEFkYWxDbGllbnQuX2F1dGhDb250ZXh0LmFjcXVpcmVUb2tlbihyZXNvdXJjZSwgZnVuY3Rpb24gKG1lc3NhZ2UsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChFcnJvcihtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHdlIGhhdmUgY3JlYXRlZCBhbmQgc2V0dXAgdGhlIGFkYWwgQXV0aGVudGljYXRpb25Db250ZXh0IGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIEFkYWxDbGllbnQucHJvdG90eXBlLmVuc3VyZUF1dGhDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIGlmIChBZGFsQ2xpZW50Ll9hdXRoQ29udGV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgQWRhbENsaWVudC5fYXV0aENvbnRleHQgPSBpbmplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiBfdGhpcy5jbGllbnRJZCxcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Q2FsbDogZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2Rpc3BsYXlDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rpc3BsYXlDYWxsYmFjayh1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTG9naW5SZXF1ZXN0VXJsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVyaTogX3RoaXMucmVkaXJlY3RVcmksXHJcbiAgICAgICAgICAgICAgICAgICAgdGVuYW50OiBfdGhpcy50ZW5hbnQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBjdXJyZW50IHVzZXIgaXMgbG9nZ2VkIGluXHJcbiAgICAgKi9cclxuICAgIEFkYWxDbGllbnQucHJvdG90eXBlLmxvZ2luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvZ2luUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9naW5Qcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dpblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChBZGFsQ2xpZW50Ll9hdXRoQ29udGV4dC5nZXRDYWNoZWRVc2VyKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2Rpc3BsYXlDYWxsYmFjayA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3B1cFdpbmRvdyA9IHdpbmRvdy5vcGVuKHVybCwgXCJsb2dpblwiLCBcIndpZHRoPTQ4MywgaGVpZ2h0PTYwMFwiKTtcclxuICAgICAgICAgICAgICAgIGlmICghcG9wdXBXaW5kb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KEVycm9yKFwiQ291bGQgbm90IG9wZW4gcG9wLXVwIHdpbmRvdyBmb3IgYXV0aC4gTGlrZWx5IHBvcC11cHMgYXJlIGJsb2NrZWQgYnkgdGhlIGJyb3dzZXIuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3B1cFdpbmRvdyAmJiBwb3B1cFdpbmRvdy5mb2N1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcHVwV2luZG93LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9sbFRpbWVyID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBvcHVwV2luZG93IHx8IHBvcHVwV2luZG93LmNsb3NlZCB8fCBwb3B1cFdpbmRvdy5jbG9zZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChwb2xsVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9wdXBXaW5kb3cuZG9jdW1lbnQuVVJMLmluZGV4T2YoX3RoaXMucmVkaXJlY3RVcmkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwocG9sbFRpbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFkYWxDbGllbnQuX2F1dGhDb250ZXh0LmhhbmRsZVdpbmRvd0NhbGxiYWNrKHBvcHVwV2luZG93LmxvY2F0aW9uLmhhc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXBXaW5kb3cuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMzApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyB0aGlzIHRyaWdnZXJzIHRoZSBsb2dpbiBwcm9jZXNzXHJcbiAgICAgICAgICAgIF90aGlzLmVuc3VyZUF1dGhDb250ZXh0KCkudGhlbihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICAgICAgQWRhbENsaWVudC5fYXV0aENvbnRleHQuX2xvZ2luSW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgQWRhbENsaWVudC5fYXV0aENvbnRleHQubG9naW4oKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwbGF5Q2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9naW5Qcm9taXNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIG91dCB0aGUgcm9vdCBvZiB0aGUgcmVxdWVzdCB1cmwgdG8gdXNlIGFzIHRoZSByZXNvdXJjZSB3aGVuIGdldHRpbmcgdGhlIHRva2VuXHJcbiAgICAgKlxyXG4gICAgICogQWZ0ZXI6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2psb25nLzI0Mjg1NjFcclxuICAgICAqIEBwYXJhbSB1cmwgVGhlIHVybCB0byBwYXJzZVxyXG4gICAgICovXHJcbiAgICBBZGFsQ2xpZW50LnByb3RvdHlwZS5nZXRSZXNvdXJjZSA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICB2YXIgcGFyc2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgcGFyc2VyLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wcm90b2NvbCArIFwiLy9cIiArIHBhcnNlci5ob3N0bmFtZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE91ciBhdXRoIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgQWRhbENsaWVudC5fYXV0aENvbnRleHQgPSBudWxsO1xyXG4gICAgcmV0dXJuIEFkYWxDbGllbnQ7XHJcbn0oQmVhcmVyVG9rZW5GZXRjaENsaWVudCkpO1xuXG4vKipcclxuICogVXNlZCB0byBjYWxjdWxhdGUgdGhlIG9iamVjdCBwcm9wZXJ0aWVzLCB3aXRoIHBvbHlmaWxsIGlmIG5lZWRlZFxyXG4gKi9cclxudmFyIG9iamVjdEVudHJpZXMgPSBpc0Z1bmMoT2JqZWN0LmVudHJpZXMpID8gT2JqZWN0LmVudHJpZXMgOiBmdW5jdGlvbiAobykgeyByZXR1cm4gT2JqZWN0LmtleXMobykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBbaywgb1trXV07IH0pOyB9O1xyXG4vKipcclxuICogQ29udmVydHMgdGhlIHN1cHBsaWVkIG9iamVjdCB0byBhIG1hcFxyXG4gKlxyXG4gKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHRvIG1hcFxyXG4gKi9cclxuZnVuY3Rpb24gb2JqZWN0VG9NYXAobykge1xyXG4gICAgaWYgKG8gIT09IHVuZGVmaW5lZCAmJiBvICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAob2JqZWN0RW50cmllcyhvKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IE1hcCgpO1xyXG59XHJcbi8qKlxyXG4gKiBNZXJnZXMgdG8gTWFwIGluc3RhbmNlcyB0b2dldGhlciwgb3ZlcndyaXRpbmcgdmFsdWVzIGluIHRhcmdldCB3aXRoIG1hdGNoaW5nIGtleXMsIGxhc3QgaW4gd2luc1xyXG4gKlxyXG4gKiBAcGFyYW0gdGFyZ2V0IG1hcCBpbnRvIHdoaWNoIHRoZSBvdGhlciBtYXBzIGFyZSBtZXJnZWRcclxuICogQHBhcmFtIG1hcHMgT25lIG9yIG1vcmUgbWFwcyB0byBtZXJnZSBpbnRvIHRoZSB0YXJnZXRcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlTWFwcyh0YXJnZXQpIHtcclxuICAgIHZhciBtYXBzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIG1hcHNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBtYXBzW2ldLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcclxuICAgICAgICAgICAgdGFyZ2V0LnNldChrLCB2KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cblxuZnVuY3Rpb24gc2V0dXAoY29uZmlnKSB7XHJcbiAgICBSdW50aW1lQ29uZmlnLmV4dGVuZChjb25maWcpO1xyXG59XHJcbi8vIGxhYmxlIG1hcHBpbmcgZm9yIGtub3duIGNvbmZpZyB2YWx1ZXNcclxudmFyIHMgPSBbXHJcbiAgICBcImRlZmF1bHRDYWNoaW5nU3RvcmVcIixcclxuICAgIFwiZGVmYXVsdENhY2hpbmdUaW1lb3V0U2Vjb25kc1wiLFxyXG4gICAgXCJnbG9iYWxDYWNoZURpc2FibGVcIixcclxuICAgIFwiZW5hYmxlQ2FjaGVFeHBpcmF0aW9uXCIsXHJcbiAgICBcImNhY2hlRXhwaXJhdGlvbkludGVydmFsTWlsbGlzZWNvbmRzXCIsXHJcbiAgICBcInNwZnhDb250ZXh0XCIsXHJcbl07XHJcbnZhciBSdW50aW1lQ29uZmlnSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJ1bnRpbWVDb25maWdJbXBsKF92KSB7XHJcbiAgICAgICAgaWYgKF92ID09PSB2b2lkIDApIHsgX3YgPSBuZXcgTWFwKCk7IH1cclxuICAgICAgICB0aGlzLl92ID0gX3Y7XHJcbiAgICAgICAgLy8gc2V0dXAgZGVmYXVsdHNcclxuICAgICAgICB0aGlzLl92LnNldChzWzBdLCBcInNlc3Npb25cIik7XHJcbiAgICAgICAgdGhpcy5fdi5zZXQoc1sxXSwgNjApO1xyXG4gICAgICAgIHRoaXMuX3Yuc2V0KHNbMl0sIGZhbHNlKTtcclxuICAgICAgICB0aGlzLl92LnNldChzWzNdLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5fdi5zZXQoc1s0XSwgNzUwKTtcclxuICAgICAgICB0aGlzLl92LnNldChzWzVdLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGFkZCB0byB0aGUgZ2xvYmEgY29uZmlndXJhdGlvbiBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBSdW50aW1lQ29uZmlnSW1wbC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX3YgPSBtZXJnZU1hcHModGhpcy5fdiwgb2JqZWN0VG9NYXAoY29uZmlnKSk7XHJcbiAgICB9O1xyXG4gICAgUnVudGltZUNvbmZpZ0ltcGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdi5nZXQoa2V5KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVudGltZUNvbmZpZ0ltcGwucHJvdG90eXBlLCBcImRlZmF1bHRDYWNoaW5nU3RvcmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoc1swXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVudGltZUNvbmZpZ0ltcGwucHJvdG90eXBlLCBcImRlZmF1bHRDYWNoaW5nVGltZW91dFNlY29uZHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoc1sxXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVudGltZUNvbmZpZ0ltcGwucHJvdG90eXBlLCBcImdsb2JhbENhY2hlRGlzYWJsZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChzWzJdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW50aW1lQ29uZmlnSW1wbC5wcm90b3R5cGUsIFwiZW5hYmxlQ2FjaGVFeHBpcmF0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHNbM10pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bnRpbWVDb25maWdJbXBsLnByb3RvdHlwZSwgXCJjYWNoZUV4cGlyYXRpb25JbnRlcnZhbE1pbGxpc2Vjb25kc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChzWzRdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW50aW1lQ29uZmlnSW1wbC5wcm90b3R5cGUsIFwic3BmeENvbnRleHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoc1s1XSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gUnVudGltZUNvbmZpZ0ltcGw7XHJcbn0oKSk7XHJcbnZhciBfcnVudGltZUNvbmZpZyA9IG5ldyBSdW50aW1lQ29uZmlnSW1wbCgpO1xyXG52YXIgUnVudGltZUNvbmZpZyA9IF9ydW50aW1lQ29uZmlnO1xuXG4vKipcclxuICogQSB3cmFwcGVyIGNsYXNzIHRvIHByb3ZpZGUgYSBjb25zaXN0ZW50IGludGVyZmFjZSB0byBicm93c2VyIGJhc2VkIHN0b3JhZ2VcclxuICpcclxuICovXHJcbnZhciBQblBDbGllbnRTdG9yYWdlV3JhcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUG5QQ2xpZW50U3RvcmFnZVdyYXBwZXIgY2xhc3NcclxuICAgICAqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUG5QQ2xpZW50U3RvcmFnZVdyYXBwZXIoc3RvcmUsIGRlZmF1bHRUaW1lb3V0TWludXRlcykge1xyXG4gICAgICAgIGlmIChkZWZhdWx0VGltZW91dE1pbnV0ZXMgPT09IHZvaWQgMCkgeyBkZWZhdWx0VGltZW91dE1pbnV0ZXMgPSAtMTsgfVxyXG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRUaW1lb3V0TWludXRlcyA9IGRlZmF1bHRUaW1lb3V0TWludXRlcztcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLnRlc3QoKTtcclxuICAgICAgICAvLyBpZiB0aGUgY2FjaGUgdGltZW91dCBpcyBlbmFibGVkIGNhbGwgdGhlIGhhbmRsZXJcclxuICAgICAgICAvLyB0aGlzIHdpbGwgY2xlYXIgYW55IGV4cGlyZWQgaXRlbXMgYW5kIHNldCB0aGUgdGltZW91dCBmdW5jdGlvblxyXG4gICAgICAgIGlmIChSdW50aW1lQ29uZmlnLmVuYWJsZUNhY2hlRXhwaXJhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlRXhwaXJhdGlvbkhhbmRsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHZhbHVlIGZyb20gc3RvcmFnZSwgb3IgbnVsbCBpZiB0aGF0IHZhbHVlIGRvZXMgbm90IGV4aXN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlIHdlIHdhbnQgdG8gcmV0cmlldmVcclxuICAgICAqL1xyXG4gICAgUG5QQ2xpZW50U3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG8gPSB0aGlzLnN0b3JlLmdldEl0ZW0oa2V5KTtcclxuICAgICAgICBpZiAoIW9iamVjdERlZmluZWROb3ROdWxsKG8pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGVyc2lzdGFibGUgPSBKU09OLnBhcnNlKG8pO1xyXG4gICAgICAgIGlmIChuZXcgRGF0ZShwZXJzaXN0YWJsZS5leHBpcmF0aW9uKSA8PSBuZXcgRGF0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBlcnNpc3RhYmxlLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgdW5kZXJseWluZyBzdG9yYWdlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHVzZSB3aGVuIHN0b3JpbmcgdGhlIHByb3ZpZGVkIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gbyBUaGUgdmFsdWUgdG8gc3RvcmVcclxuICAgICAqIEBwYXJhbSBleHBpcmUgT3B0aW9uYWwsIGlmIHByb3ZpZGVkIHRoZSBleHBpcmF0aW9uIG9mIHRoZSBpdGVtLCBvdGhlcndpc2UgdGhlIGRlZmF1bHQgaXMgdXNlZFxyXG4gICAgICovXHJcbiAgICBQblBDbGllbnRTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgbywgZXhwaXJlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JlLnNldEl0ZW0oa2V5LCB0aGlzLmNyZWF0ZVBlcnNpc3RhYmxlKG8sIGV4cGlyZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgYSB2YWx1ZSBmcm9tIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHBhaXIgd2Ugd2FudCB0byByZW1vdmUgZnJvbSBzdG9yYWdlXHJcbiAgICAgKi9cclxuICAgIFBuUENsaWVudFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3JlLnJlbW92ZUl0ZW0oa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFuIGl0ZW0gZnJvbSB0aGUgdW5kZXJseWluZyBzdG9yYWdlLCBvciBhZGRzIGl0IGlmIGl0IGRvZXMgbm90IGV4aXN0IHVzaW5nIHRoZSBzdXBwbGllZCBnZXR0ZXIgZnVuY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdXNlIHdoZW4gc3RvcmluZyB0aGUgcHJvdmlkZWQgdmFsdWVcclxuICAgICAqIEBwYXJhbSBnZXR0ZXIgQSBmdW5jdGlvbiB3aGljaCB3aWxsIHVwb24gZXhlY3V0aW9uIHByb3ZpZGUgdGhlIGRlc2lyZWQgdmFsdWVcclxuICAgICAqIEBwYXJhbSBleHBpcmUgT3B0aW9uYWwsIGlmIHByb3ZpZGVkIHRoZSBleHBpcmF0aW9uIG9mIHRoZSBpdGVtLCBvdGhlcndpc2UgdGhlIGRlZmF1bHQgaXMgdXNlZFxyXG4gICAgICovXHJcbiAgICBQblBDbGllbnRTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0T3JQdXQgPSBmdW5jdGlvbiAoa2V5LCBnZXR0ZXIsIGV4cGlyZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldHRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSBfdGhpcy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZ2V0dGVyKCkudGhlbihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnB1dChrZXksIGQsIGV4cGlyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhbnkgZXhwaXJlZCBpdGVtcyBwbGFjZWQgaW4gdGhlIHN0b3JlIGJ5IHRoZSBwbnAgbGlicmFyeSwgbGVhdmVzIG90aGVyIGl0ZW1zIHVudG91Y2hlZFxyXG4gICAgICovXHJcbiAgICBQblBDbGllbnRTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZGVsZXRlRXhwaXJlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICghX3RoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnN0b3JlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF90aGlzLnN0b3JlLmtleShpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgdGhlIHN0b3JlZCBpdGVtIHRvIHNlZSBpZiB3ZSBzdG9yZWQgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9bXCJ8J10/cG5wW1wifCddPyA/OiA/MS9pLnRlc3QoX3RoaXMuc3RvcmUuZ2V0SXRlbShrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRob3NlIGl0ZW1zIGFzIGdldCB3aWxsIGRlbGV0ZSBmcm9tIGNhY2hlIGlmIHRoZXkgYXJlIGV4cGlyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSB3cmFwcGVkIHN0b3JhZ2UgaXMgYXZhaWxhYmxlIGN1cnJlbnRseVxyXG4gICAgICovXHJcbiAgICBQblBDbGllbnRTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RyID0gXCJ0XCI7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5zdG9yZS5zZXRJdGVtKHN0ciwgc3RyKTtcclxuICAgICAgICAgICAgdGhpcy5zdG9yZS5yZW1vdmVJdGVtKHN0cik7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgcGVyc2lzdGFibGUgdG8gc3RvcmVcclxuICAgICAqL1xyXG4gICAgUG5QQ2xpZW50U3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZVBlcnNpc3RhYmxlID0gZnVuY3Rpb24gKG8sIGV4cGlyZSkge1xyXG4gICAgICAgIGlmIChleHBpcmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgd2UgYXJlIGJ5IGRlZmF1bHQgaW5saW5lIHdpdGggdGhlIGdsb2JhbCBsaWJyYXJ5IHNldHRpbmdcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRUaW1lb3V0ID0gUnVudGltZUNvbmZpZy5kZWZhdWx0Q2FjaGluZ1RpbWVvdXRTZWNvbmRzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0VGltZW91dE1pbnV0ZXMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGltZW91dCA9IHRoaXMuZGVmYXVsdFRpbWVvdXRNaW51dGVzICogNjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhwaXJlID0gZGF0ZUFkZChuZXcgRGF0ZSgpLCBcInNlY29uZFwiLCBkZWZhdWx0VGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBqc1MoeyBwbnA6IDEsIGV4cGlyYXRpb246IGV4cGlyZSwgdmFsdWU6IG8gfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGV4cGlyZWQgaXRlbXMgYWRkZWQgYnkgdGhpcyBsaWJyYXJ5IGluIHRoaXMuc3RvcmUgYW5kIHNldHMgYSB0aW1lb3V0IHRvIGNhbGwgaXRzZWxmXHJcbiAgICAgKi9cclxuICAgIFBuUENsaWVudFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5jYWNoZUV4cGlyYXRpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5kZWxldGVFeHBpcmVkKCkudGhlbihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICAvLyBjYWxsIG91cnNlbGYgaW4gdGhlIGZ1dHVyZVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGdldEN0eENhbGxiYWNrKF90aGlzLCBfdGhpcy5jYWNoZUV4cGlyYXRpb25IYW5kbGVyKSwgUnVudGltZUNvbmZpZy5jYWNoZUV4cGlyYXRpb25JbnRlcnZhbE1pbGxpc2Vjb25kcyk7XHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG5QQ2xpZW50U3RvcmFnZVdyYXBwZXI7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBBIHRoaW4gaW1wbGVtZW50YXRpb24gb2YgaW4tbWVtb3J5IHN0b3JhZ2UgZm9yIHVzZSBpbiBub2RlanNcclxuICovXHJcbnZhciBNZW1vcnlTdG9yYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWVtb3J5U3RvcmFnZShfc3RvcmUpIHtcclxuICAgICAgICBpZiAoX3N0b3JlID09PSB2b2lkIDApIHsgX3N0b3JlID0gbmV3IE1hcCgpOyB9XHJcbiAgICAgICAgdGhpcy5fc3RvcmUgPSBfc3RvcmU7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVtb3J5U3RvcmFnZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLnNpemU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNZW1vcnlTdG9yYWdlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9zdG9yZS5jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIE1lbW9yeVN0b3JhZ2UucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldChrZXkpO1xyXG4gICAgfTtcclxuICAgIE1lbW9yeVN0b3JhZ2UucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3N0b3JlKVtpbmRleF1bMF07XHJcbiAgICB9O1xyXG4gICAgTWVtb3J5U3RvcmFnZS5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB0aGlzLl9zdG9yZS5kZWxldGUoa2V5KTtcclxuICAgIH07XHJcbiAgICBNZW1vcnlTdG9yYWdlLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX3N0b3JlLnNldChrZXksIGRhdGEpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNZW1vcnlTdG9yYWdlO1xyXG59KCkpO1xyXG4vKipcclxuICogQSBjbGFzcyB0aGF0IHdpbGwgZXN0YWJsaXNoIHdyYXBwZXJzIGZvciBib3RoIGxvY2FsIGFuZCBzZXNzaW9uIHN0b3JhZ2VcclxuICovXHJcbnZhciBQblBDbGllbnRTdG9yYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBQblBDbGllbnRTdG9yYWdlIGNsYXNzXHJcbiAgICAgKlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFBuUENsaWVudFN0b3JhZ2UoX2xvY2FsLCBfc2Vzc2lvbikge1xyXG4gICAgICAgIGlmIChfbG9jYWwgPT09IHZvaWQgMCkgeyBfbG9jYWwgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKF9zZXNzaW9uID09PSB2b2lkIDApIHsgX3Nlc3Npb24gPSBudWxsOyB9XHJcbiAgICAgICAgdGhpcy5fbG9jYWwgPSBfbG9jYWw7XHJcbiAgICAgICAgdGhpcy5fc2Vzc2lvbiA9IF9zZXNzaW9uO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBuUENsaWVudFN0b3JhZ2UucHJvdG90eXBlLCBcImxvY2FsXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGxvY2FsIHN0b3JhZ2Ugb2YgdGhlIGJyb3dzZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvY2FsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbCA9IHRoaXMuZ2V0U3RvcmUoXCJsb2NhbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG5QQ2xpZW50U3RvcmFnZS5wcm90b3R5cGUsIFwic2Vzc2lvblwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBzZXNzaW9uIHN0b3JhZ2Ugb2YgdGhlIGJyb3dzZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Nlc3Npb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nlc3Npb24gPSB0aGlzLmdldFN0b3JlKFwic2Vzc2lvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFBuUENsaWVudFN0b3JhZ2UucHJvdG90eXBlLmdldFN0b3JlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PT0gXCJsb2NhbFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG5QQ2xpZW50U3RvcmFnZVdyYXBwZXIodHlwZW9mIChsb2NhbFN0b3JhZ2UpID09PSBcInVuZGVmaW5lZFwiID8gbmV3IE1lbW9yeVN0b3JhZ2UoKSA6IGxvY2FsU3RvcmFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUG5QQ2xpZW50U3RvcmFnZVdyYXBwZXIodHlwZW9mIChzZXNzaW9uU3RvcmFnZSkgPT09IFwidW5kZWZpbmVkXCIgPyBuZXcgTWVtb3J5U3RvcmFnZSgpIDogc2Vzc2lvblN0b3JhZ2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQblBDbGllbnRTdG9yYWdlO1xyXG59KCkpO1xuXG5leHBvcnQgeyBBZGFsQ2xpZW50LCBvYmplY3RUb01hcCwgbWVyZ2VNYXBzLCBzZXR1cCwgUnVudGltZUNvbmZpZ0ltcGwsIFJ1bnRpbWVDb25maWcsIG1lcmdlSGVhZGVycywgbWVyZ2VPcHRpb25zLCBGZXRjaENsaWVudCwgQmVhcmVyVG9rZW5GZXRjaENsaWVudCwgUG5QQ2xpZW50U3RvcmFnZVdyYXBwZXIsIFBuUENsaWVudFN0b3JhZ2UsIGdldEN0eENhbGxiYWNrLCBkYXRlQWRkLCBjb21iaW5lLCBnZXRSYW5kb21TdHJpbmcsIGdldEdVSUQsIGlzRnVuYywgb2JqZWN0RGVmaW5lZE5vdE51bGwsIGlzQXJyYXksIGV4dGVuZCwgaXNVcmxBYnNvbHV0ZSwgc3RyaW5nSXNOdWxsT3JFbXB0eSwgZ2V0QXR0clZhbHVlRnJvbVN0cmluZywgc2FuaXRpemVHdWlkLCBqc1MsIGhPUCwgZ2V0SGFzaENvZGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5lczUuanMubWFwXG4iLCIvKipcbkBsaWNlbnNlXG4gKiBAcG5wL2xvZ2dpbmcgdjEuMi4zIC0gcG5wIC0gbGlnaHQtd2VpZ2h0LCBzdWJzY3JpYmFibGUgbG9nZ2luZyBmcmFtZXdvcmtcbiAqIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3BucC9wbnBqcy9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogQ29weXJpZ2h0IChjKSAyMDE4IE1pY3Jvc29mdFxuICogZG9jczogaHR0cHM6Ly9wbnAuZ2l0aHViLmlvL3BucGpzL1xuICogc291cmNlOiBodHRwczpnaXRodWIuY29tL3BucC9wbnBqc1xuICogYnVnczogaHR0cHM6Ly9naXRodWIuY29tL3BucC9wbnBqcy9pc3N1ZXNcbiAqL1xuLyoqXHJcbiAqIENsYXNzIHVzZWQgdG8gc3Vic2NyaWJlIElMb2dMaXN0ZW5lciBhbmQgbG9nIG1lc3NhZ2VzIHRocm91Z2hvdXQgYW4gYXBwbGljYXRpb25cclxuICpcclxuICovXHJcbnZhciBMb2dnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb2dnZXIoKSB7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyLCBcImFjdGl2ZUxvZ0xldmVsXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGFjdGl2ZSBsb2cgbGV2ZWwgdG8gYXBwbHkgZm9yIGxvZyBmaWx0ZXJpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExvZ2dlci5pbnN0YW5jZS5hY3RpdmVMb2dMZXZlbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5pbnN0YW5jZS5hY3RpdmVMb2dMZXZlbCA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ2dlciwgXCJpbnN0YW5jZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuX2luc3RhbmNlID09PSB1bmRlZmluZWQgfHwgTG9nZ2VyLl9pbnN0YW5jZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZSA9IG5ldyBMb2dnZXJJbXBsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIExvZ2dlci5faW5zdGFuY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgSUxvZ0xpc3RlbmVyIGluc3RhbmNlcyB0byB0aGUgc2V0IG9mIHN1YnNjcmliZWQgbGlzdGVuZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVycyBPbmUgb3IgbW9yZSBsaXN0ZW5lcnMgdG8gc3Vic2NyaWJlIHRvIHRoaXMgbG9nXHJcbiAgICAgKi9cclxuICAgIExvZ2dlci5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaXN0ZW5lcnMubWFwKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gTG9nZ2VyLmluc3RhbmNlLnN1YnNjcmliZShsaXN0ZW5lcik7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBzdWJzY3JpYmVycyBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGNvbGxlY3Rpb24gYmVmb3JlIG1vZGlmaWN0aW9uXHJcbiAgICAgKi9cclxuICAgIExvZ2dlci5jbGVhclN1YnNjcmliZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBMb2dnZXIuaW5zdGFuY2UuY2xlYXJTdWJzY3JpYmVycygpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dnZXIsIFwiY291bnRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3Vic2NyaWJlciBjb3VudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9nZ2VyLmluc3RhbmNlLmNvdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgdGhlIHN1cHBsaWVkIHN0cmluZyB0byB0aGUgc3Vic2NyaWJlZCBsaXN0ZW5lcnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIGxldmVsIFtPcHRpb25hbF0gaWYgc3VwcGxpZWQgd2lsbCBiZSB1c2VkIGFzIHRoZSBsZXZlbCBvZiB0aGUgZW50cnkgKERlZmF1bHQ6IExvZ0xldmVsLkluZm8pXHJcbiAgICAgKi9cclxuICAgIExvZ2dlci53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBsZXZlbCkge1xyXG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gMSAvKiBJbmZvICovOyB9XHJcbiAgICAgICAgTG9nZ2VyLmluc3RhbmNlLmxvZyh7IGxldmVsOiBsZXZlbCwgbWVzc2FnZTogbWVzc2FnZSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyB0aGUgc3VwcGxpZWQgc3RyaW5nIHRvIHRoZSBzdWJzY3JpYmVkIGxpc3RlbmVyc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBqc29uIG9iamVjdCB0byBzdHJpbmdpZnkgYW5kIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0gbGV2ZWwgW09wdGlvbmFsXSBpZiBzdXBwbGllZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGxldmVsIG9mIHRoZSBlbnRyeSAoRGVmYXVsdDogTG9nTGV2ZWwuSW5mbylcclxuICAgICAqL1xyXG4gICAgTG9nZ2VyLndyaXRlSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBsZXZlbCkge1xyXG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gMSAvKiBJbmZvICovOyB9XHJcbiAgICAgICAgdGhpcy53cml0ZShKU09OLnN0cmluZ2lmeShqc29uKSwgbGV2ZWwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTG9ncyB0aGUgc3VwcGxpZWQgZW50cnkgdG8gdGhlIHN1YnNjcmliZWQgbGlzdGVuZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudHJ5IFRoZSBtZXNzYWdlIHRvIGxvZ1xyXG4gICAgICovXHJcbiAgICBMb2dnZXIubG9nID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgTG9nZ2VyLmluc3RhbmNlLmxvZyhlbnRyeSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGFuIGVycm9yIG9iamVjdCB0byB0aGUgc3Vic2NyaWJlZCBsaXN0ZW5lcnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXJyIFRoZSBlcnJvciBvYmplY3RcclxuICAgICAqL1xyXG4gICAgTG9nZ2VyLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIExvZ2dlci5pbnN0YW5jZS5sb2coeyBkYXRhOiBlcnIsIGxldmVsOiAzIC8qIEVycm9yICovLCBtZXNzYWdlOiBlcnIubWVzc2FnZSB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTG9nZ2VyO1xyXG59KCkpO1xyXG52YXIgTG9nZ2VySW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvZ2dlckltcGwoYWN0aXZlTG9nTGV2ZWwsIHN1YnNjcmliZXJzKSB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUxvZ0xldmVsID09PSB2b2lkIDApIHsgYWN0aXZlTG9nTGV2ZWwgPSAyIC8qIFdhcm5pbmcgKi87IH1cclxuICAgICAgICBpZiAoc3Vic2NyaWJlcnMgPT09IHZvaWQgMCkgeyBzdWJzY3JpYmVycyA9IFtdOyB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVMb2dMZXZlbCA9IGFjdGl2ZUxvZ0xldmVsO1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycztcclxuICAgIH1cclxuICAgIExvZ2dlckltcGwucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICB9O1xyXG4gICAgTG9nZ2VySW1wbC5wcm90b3R5cGUuY2xlYXJTdWJzY3JpYmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcyA9IHRoaXMuc3Vic2NyaWJlcnMuc2xpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dnZXJJbXBsLnByb3RvdHlwZSwgXCJjb3VudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZXJzLmxlbmd0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIExvZ2dlckltcGwucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGxldmVsKSB7XHJcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSAxIC8qIEluZm8gKi87IH1cclxuICAgICAgICB0aGlzLmxvZyh7IGxldmVsOiBsZXZlbCwgbWVzc2FnZTogbWVzc2FnZSB9KTtcclxuICAgIH07XHJcbiAgICBMb2dnZXJJbXBsLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoZW50cnkgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFjdGl2ZUxvZ0xldmVsIDw9IGVudHJ5LmxldmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnMubWFwKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7IHJldHVybiBzdWJzY3JpYmVyLmxvZyhlbnRyeSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTG9nZ2VySW1wbDtcclxufSgpKTtcblxuLyoqXHJcbiAqIEEgc2V0IG9mIGxvZ2dpbmcgbGV2ZWxzXHJcbiAqL1xyXG52YXIgTG9nTGV2ZWw7XHJcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVmVyYm9zZVwiXSA9IDBdID0gXCJWZXJib3NlXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAxXSA9IFwiSW5mb1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXYXJuaW5nXCJdID0gMl0gPSBcIldhcm5pbmdcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRXJyb3JcIl0gPSAzXSA9IFwiRXJyb3JcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiT2ZmXCJdID0gOTldID0gXCJPZmZcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcblxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIExvZ0xpc3RlbmVyIHdoaWNoIGxvZ3MgdG8gdGhlIGNvbnNvbGVcclxuICpcclxuICovXHJcbnZhciBDb25zb2xlTGlzdGVuZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb25zb2xlTGlzdGVuZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFueSBhc3NvY2lhdGVkIGRhdGEgdGhhdCBhIGdpdmVuIGxvZ2dpbmcgbGlzdGVuZXIgbWF5IGNob29zZSB0byBsb2cgb3IgaWdub3JlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudHJ5IFRoZSBpbmZvcm1hdGlvbiB0byBiZSBsb2dnZWRcclxuICAgICAqL1xyXG4gICAgQ29uc29sZUxpc3RlbmVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICB2YXIgbXNnID0gdGhpcy5mb3JtYXQoZW50cnkpO1xyXG4gICAgICAgIHN3aXRjaCAoZW50cnkubGV2ZWwpIHtcclxuICAgICAgICAgICAgY2FzZSAwIC8qIFZlcmJvc2UgKi86XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBJbmZvICovOlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogV2FybmluZyAqLzpcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBFcnJvciAqLzpcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdHMgdGhlIG1lc3NhZ2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50cnkgVGhlIGluZm9ybWF0aW9uIHRvIGZvcm1hdCBpbnRvIGEgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIENvbnNvbGVMaXN0ZW5lci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgdmFyIG1zZyA9IFtdO1xyXG4gICAgICAgIG1zZy5wdXNoKFwiTWVzc2FnZTogXCIgKyBlbnRyeS5tZXNzYWdlKTtcclxuICAgICAgICBpZiAoZW50cnkuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG1zZy5wdXNoKFwiIERhdGE6IFwiICsgSlNPTi5zdHJpbmdpZnkoZW50cnkuZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbXNnLmpvaW4oXCJcIik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnNvbGVMaXN0ZW5lcjtcclxufSgpKTtcclxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIExvZ0xpc3RlbmVyIHdoaWNoIGxvZ3MgdG8gdGhlIHN1cHBsaWVkIGZ1bmN0aW9uXHJcbiAqXHJcbiAqL1xyXG52YXIgRnVuY3Rpb25MaXN0ZW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgRnVuY3Rpb25MaXN0ZW5lciBjbGFzc1xyXG4gICAgICpcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtICBtZXRob2QgVGhlIG1ldGhvZCB0byB3aGljaCBhbnkgbG9nZ2luZyBkYXRhIHdpbGwgYmUgcGFzc2VkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uTGlzdGVuZXIobWV0aG9kKSB7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFueSBhc3NvY2lhdGVkIGRhdGEgdGhhdCBhIGdpdmVuIGxvZ2dpbmcgbGlzdGVuZXIgbWF5IGNob29zZSB0byBsb2cgb3IgaWdub3JlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudHJ5IFRoZSBpbmZvcm1hdGlvbiB0byBiZSBsb2dnZWRcclxuICAgICAqL1xyXG4gICAgRnVuY3Rpb25MaXN0ZW5lci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgdGhpcy5tZXRob2QoZW50cnkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGdW5jdGlvbkxpc3RlbmVyO1xyXG59KCkpO1xuXG5leHBvcnQgeyBMb2dnZXIsIExvZ0xldmVsLCBDb25zb2xlTGlzdGVuZXIsIEZ1bmN0aW9uTGlzdGVuZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuZXM1LmpzLm1hcFxuIiwiLyoqXG5AbGljZW5zZVxuICogQHBucC9vZGF0YSB2MS4yLjMgLSBwbnAgLSBwcm92aWRlcyBzaGFyZWQgb2RhdGEgZnVuY3Rpb25hbGl0eSBhbmQgYmFzZSBjbGFzc2VzXG4gKiBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9wbnAvcG5wanMvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIENvcHlyaWdodCAoYykgMjAxOCBNaWNyb3NvZnRcbiAqIGRvY3M6IGh0dHBzOi8vcG5wLmdpdGh1Yi5pby9wbnBqcy9cbiAqIHNvdXJjZTogaHR0cHM6Z2l0aHViLmNvbS9wbnAvcG5wanNcbiAqIGJ1Z3M6IGh0dHBzOi8vZ2l0aHViLmNvbS9wbnAvcG5wanMvaXNzdWVzXG4gKi9cbmltcG9ydCB7IFJ1bnRpbWVDb25maWcsIGRhdGVBZGQsIFBuUENsaWVudFN0b3JhZ2UsIGlzRnVuYywgaE9QLCBleHRlbmQsIGNvbWJpbmUsIG1lcmdlT3B0aW9ucywgb2JqZWN0RGVmaW5lZE5vdE51bGwsIGdldEdVSUQgfSBmcm9tICdAcG5wL2NvbW1vbic7XG5pbXBvcnQgeyBfX2RlY29yYXRlLCBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAcG5wL2xvZ2dpbmcnO1xuXG52YXIgQ2FjaGluZ09wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYWNoaW5nT3B0aW9ucyhrZXkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLmV4cGlyYXRpb24gPSBkYXRlQWRkKG5ldyBEYXRlKCksIFwic2Vjb25kXCIsIFJ1bnRpbWVDb25maWcuZGVmYXVsdENhY2hpbmdUaW1lb3V0U2Vjb25kcyk7XHJcbiAgICAgICAgdGhpcy5zdG9yZU5hbWUgPSBSdW50aW1lQ29uZmlnLmRlZmF1bHRDYWNoaW5nU3RvcmU7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FjaGluZ09wdGlvbnMucHJvdG90eXBlLCBcInN0b3JlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmVOYW1lID09PSBcImxvY2FsXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDYWNoaW5nT3B0aW9ucy5zdG9yYWdlLmxvY2FsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENhY2hpbmdPcHRpb25zLnN0b3JhZ2Uuc2Vzc2lvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ2FjaGluZ09wdGlvbnMuc3RvcmFnZSA9IG5ldyBQblBDbGllbnRTdG9yYWdlKCk7XHJcbiAgICByZXR1cm4gQ2FjaGluZ09wdGlvbnM7XHJcbn0oKSk7XHJcbnZhciBDYWNoaW5nUGFyc2VyV3JhcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhY2hpbmdQYXJzZXJXcmFwcGVyKHBhcnNlciwgY2FjaGVPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICAgICAgdGhpcy5jYWNoZU9wdGlvbnMgPSBjYWNoZU9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBDYWNoaW5nUGFyc2VyV3JhcHBlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5wYXJzZShyZXNwb25zZSkudGhlbihmdW5jdGlvbiAocikgeyByZXR1cm4gX3RoaXMuY2FjaGVEYXRhKHIpOyB9KTtcclxuICAgIH07XHJcbiAgICBDYWNoaW5nUGFyc2VyV3JhcHBlci5wcm90b3R5cGUuY2FjaGVEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWNoZU9wdGlvbnMuc3RvcmUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZU9wdGlvbnMuc3RvcmUucHV0KHRoaXMuY2FjaGVPcHRpb25zLmtleSwgZGF0YSwgdGhpcy5jYWNoZU9wdGlvbnMuZXhwaXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDYWNoaW5nUGFyc2VyV3JhcHBlcjtcclxufSgpKTtcblxudmFyIEh0dHBSZXF1ZXN0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSHR0cFJlcXVlc3RFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEh0dHBSZXF1ZXN0RXJyb3IobWVzc2FnZSwgcmVzcG9uc2UsIHN0YXR1cywgc3RhdHVzVGV4dCkge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09IHZvaWQgMCkgeyBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7IH1cclxuICAgICAgICBpZiAoc3RhdHVzVGV4dCA9PT0gdm9pZCAwKSB7IHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0dXNUZXh0OyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xyXG4gICAgICAgIF90aGlzLnN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICBfdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcclxuICAgICAgICBfdGhpcy5pc0h0dHBSZXF1ZXN0RXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBIdHRwUmVxdWVzdEVycm9yO1xyXG59KEVycm9yKSk7XHJcbnZhciBPRGF0YVBhcnNlckJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPRGF0YVBhcnNlckJhc2UoKSB7XHJcbiAgICB9XHJcbiAgICBPRGF0YVBhcnNlckJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5oYW5kbGVFcnJvcihyLCByZWplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZUltcGwociwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE9EYXRhUGFyc2VyQmFzZS5wcm90b3R5cGUucGFyc2VJbXBsID0gZnVuY3Rpb24gKHIsIHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKChyLmhlYWRlcnMuaGFzKFwiQ29udGVudC1MZW5ndGhcIikgJiYgcGFyc2VGbG9hdChyLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikpID09PSAwKSB8fCByLnN0YXR1cyA9PT0gMjA0KSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoe30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcGF0Y2ggdG8gaGFuZGxlIGNhc2VzIG9mIDIwMCByZXNwb25zZSB3aXRoIG5vIG9yIHdoaXRlc3BhY2Ugb25seSBib2RpZXMgKCM0ODcgJiAjNTQ1KVxyXG4gICAgICAgICAgICByLnRleHQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHR4dCkgeyByZXR1cm4gdHh0LnJlcGxhY2UoL1xccy9pZywgXCJcIikubGVuZ3RoID4gMCA/IEpTT04ucGFyc2UodHh0KSA6IHt9OyB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGpzb24pIHsgcmV0dXJuIHJlc29sdmUoX3RoaXMucGFyc2VPRGF0YUpTT04oanNvbikpOyB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiByZWplY3QoZSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgYSByZXNwb25zZSB3aXRoIG9rID09PSBmYWxzZSBieSBwYXJzaW5nIHRoZSBib2R5IGFuZCBjcmVhdGluZyBhIFByb2Nlc3NIdHRwQ2xpZW50UmVzcG9uc2VFeGNlcHRpb25cclxuICAgICAqIHdoaWNoIGlzIHBhc3NlZCB0byB0aGUgcmVqZWN0IGRlbGVnYXRlLiBUaGlzIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgbm8gZXJyb3IsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByIEN1cnJlbnQgcmVzcG9uc2Ugb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gcmVqZWN0IHJlamVjdCBkZWxlZ2F0ZSBmb3IgdGhlIHN1cnJvdW5kaW5nIHByb21pc2VcclxuICAgICAqL1xyXG4gICAgT0RhdGFQYXJzZXJCYXNlLnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChyLCByZWplY3QpIHtcclxuICAgICAgICBpZiAoIXIub2spIHtcclxuICAgICAgICAgICAgcmVqZWN0KG5ldyBIdHRwUmVxdWVzdEVycm9yKFwiRXJyb3IgbWFraW5nIEh0dHBDbGllbnQgcmVxdWVzdCBpbiBxdWVyeWFibGU6IFtcIiArIHIuc3RhdHVzICsgXCJdIFwiICsgci5zdGF0dXNUZXh0LCByLmNsb25lKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHIub2s7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIHRoZSBqc29uIHJlc3BvbnNlIGJ5IHJlbW92aW5nIHRoZSB2YXJpb3VzIG5lc3RlZCBsZXZlbHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ganNvbiBqc29uIG9iamVjdCB0byBwYXJzZVxyXG4gICAgICovXHJcbiAgICBPRGF0YVBhcnNlckJhc2UucHJvdG90eXBlLnBhcnNlT0RhdGFKU09OID0gZnVuY3Rpb24gKGpzb24pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ganNvbjtcclxuICAgICAgICBpZiAoaE9QKGpzb24sIFwiZFwiKSkge1xyXG4gICAgICAgICAgICBpZiAoaE9QKGpzb24uZCwgXCJyZXN1bHRzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqc29uLmQucmVzdWx0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpzb24uZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoT1AoanNvbiwgXCJ2YWx1ZVwiKSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBqc29uLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBPRGF0YVBhcnNlckJhc2U7XHJcbn0oKSk7XHJcbnZhciBPRGF0YURlZmF1bHRQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoT0RhdGFEZWZhdWx0UGFyc2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gT0RhdGFEZWZhdWx0UGFyc2VyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBPRGF0YURlZmF1bHRQYXJzZXI7XHJcbn0oT0RhdGFQYXJzZXJCYXNlKSk7XHJcbnZhciBUZXh0UGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRleHRQYXJzZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUZXh0UGFyc2VyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFRleHRQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wbCA9IGZ1bmN0aW9uIChyLCByZXNvbHZlKSB7XHJcbiAgICAgICAgci50ZXh0KCkudGhlbihyZXNvbHZlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGV4dFBhcnNlcjtcclxufShPRGF0YVBhcnNlckJhc2UpKTtcclxudmFyIEJsb2JQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmxvYlBhcnNlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJsb2JQYXJzZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQmxvYlBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBsID0gZnVuY3Rpb24gKHIsIHJlc29sdmUpIHtcclxuICAgICAgICByLmJsb2IoKS50aGVuKHJlc29sdmUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCbG9iUGFyc2VyO1xyXG59KE9EYXRhUGFyc2VyQmFzZSkpO1xyXG52YXIgSlNPTlBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhKU09OUGFyc2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSlNPTlBhcnNlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBKU09OUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcGwgPSBmdW5jdGlvbiAociwgcmVzb2x2ZSkge1xyXG4gICAgICAgIHIuanNvbigpLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEpTT05QYXJzZXI7XHJcbn0oT0RhdGFQYXJzZXJCYXNlKSk7XHJcbnZhciBCdWZmZXJQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQnVmZmVyUGFyc2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQnVmZmVyUGFyc2VyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEJ1ZmZlclBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBsID0gZnVuY3Rpb24gKHIsIHJlc29sdmUpIHtcclxuICAgICAgICBpZiAoaXNGdW5jKHIuYXJyYXlCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgIHIuYXJyYXlCdWZmZXIoKS50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgci5idWZmZXIoKS50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQnVmZmVyUGFyc2VyO1xyXG59KE9EYXRhUGFyc2VyQmFzZSkpO1xyXG52YXIgTGFtYmRhUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExhbWJkYVBhcnNlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExhbWJkYVBhcnNlcihwYXJzZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBMYW1iZGFQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wbCA9IGZ1bmN0aW9uIChyLCByZXNvbHZlKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZXIocikudGhlbihyZXNvbHZlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGFtYmRhUGFyc2VyO1xyXG59KE9EYXRhUGFyc2VyQmFzZSkpO1xuXG4vKipcclxuICogUmVzb2x2ZXMgdGhlIGNvbnRleHQncyByZXN1bHQgdmFsdWVcclxuICpcclxuICogQHBhcmFtIGNvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gcmV0dXJuUmVzdWx0KGNvbnRleHQpIHtcclxuICAgIExvZ2dlci5sb2coe1xyXG4gICAgICAgIGRhdGE6IExvZ2dlci5hY3RpdmVMb2dMZXZlbCA9PT0gMCAvKiBWZXJib3NlICovID8gY29udGV4dC5yZXN1bHQgOiB7fSxcclxuICAgICAgICBsZXZlbDogMSAvKiBJbmZvICovLFxyXG4gICAgICAgIG1lc3NhZ2U6IFwiW1wiICsgY29udGV4dC5yZXF1ZXN0SWQgKyBcIl0gKFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFwiKSBSZXR1cm5pbmcgcmVzdWx0IGZyb20gcGlwZWxpbmUuIFNldCBsb2dnaW5nIHRvIHZlcmJvc2UgdG8gc2VlIGRhdGEuXCIsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udGV4dC5yZXN1bHQpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSByZXN1bHQgb24gdGhlIGNvbnRleHRcclxuICovXHJcbmZ1bmN0aW9uIHNldFJlc3VsdChjb250ZXh0LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgY29udGV4dC5yZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICBjb250ZXh0Lmhhc1Jlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgcmVzb2x2ZShjb250ZXh0KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBJbnZva2VzIHRoZSBuZXh0IG1ldGhvZCBpbiB0aGUgcHJvdmlkZWQgY29udGV4dCdzIHBpcGVsaW5lXHJcbiAqXHJcbiAqIEBwYXJhbSBjIFRoZSBjdXJyZW50IHJlcXVlc3QgY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gbmV4dChjKSB7XHJcbiAgICBpZiAoYy5waXBlbGluZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGMucGlwZWxpbmUuc2hpZnQoKShjKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBjdXJyZW50IHJlcXVlc3QgY29udGV4dCdzIHBpcGVsaW5lXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250ZXh0IEN1cnJlbnQgY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gcGlwZShjb250ZXh0KSB7XHJcbiAgICBpZiAoY29udGV4dC5waXBlbGluZS5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgTG9nZ2VyLndyaXRlKFwiW1wiICsgY29udGV4dC5yZXF1ZXN0SWQgKyBcIl0gKFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFwiKSBSZXF1ZXN0IHBpcGVsaW5lIGNvbnRhaW5zIG5vIG1ldGhvZHMhXCIsIDIgLyogV2FybmluZyAqLyk7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJvbWlzZSA9IG5leHQoY29udGV4dCkudGhlbihmdW5jdGlvbiAoY3R4KSB7IHJldHVybiByZXR1cm5SZXN1bHQoY3R4KTsgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBMb2dnZXIuZXJyb3IoZSk7XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGNvbnRleHQuaXNCYXRjaGVkKSB7XHJcbiAgICAgICAgLy8gdGhpcyB3aWxsIGJsb2NrIHRoZSBiYXRjaCdzIGV4ZWN1dGUgbWV0aG9kIGZyb20gcmV0dXJuaW5nIHVudGlsIHRoZSBjaGlsZCByZXF1ZXRzIGhhdmUgYmVlbiByZXNvbHZlZFxyXG4gICAgICAgIGNvbnRleHQuYmF0Y2guYWRkUmVzb2x2ZUJhdGNoRGVwZW5kZW5jeShwcm9taXNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9taXNlO1xyXG59XHJcbi8qKlxyXG4gKiBkZWNvcmF0b3IgZmFjdG9yeSBhcHBsaWVkIHRvIG1ldGhvZHMgaW4gdGhlIHBpcGVsaW5lIHRvIGNvbnRyb2wgYmVoYXZpb3JcclxuICovXHJcbmZ1bmN0aW9uIHJlcXVlc3RQaXBlbGluZU1ldGhvZChhbHdheXNSdW4pIHtcclxuICAgIGlmIChhbHdheXNSdW4gPT09IHZvaWQgMCkgeyBhbHdheXNSdW4gPSBmYWxzZTsgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XHJcbiAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgcmVzdWx0IGFscmVhZHkgaW4gdGhlIHBpcGVsaW5lLCBwYXNzIGl0IGFsb25nIGFuZCBkb24ndCBjYWxsIHRoZSB0YWdnZWQgbWV0aG9kXHJcbiAgICAgICAgICAgIGlmICghYWx3YXlzUnVuICYmIGFyZ3MubGVuZ3RoID4gMCAmJiBoT1AoYXJnc1swXSwgXCJoYXNSZXN1bHRcIikgJiYgYXJnc1swXS5oYXNSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci53cml0ZShcIltcIiArIGFyZ3NbMF0ucmVxdWVzdElkICsgXCJdIChcIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKyBcIikgU2tpcHBpbmcgcmVxdWVzdCBwaXBlbGluZSBtZXRob2QgXCIgKyBwcm9wZXJ0eUtleSArIFwiLCBleGlzdGluZyByZXN1bHQgaW4gcGlwZWxpbmUuXCIsIDAgLyogVmVyYm9zZSAqLyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFyZ3NbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFwcGx5IHRoZSB0YWdnZWQgbWV0aG9kXHJcbiAgICAgICAgICAgIExvZ2dlci53cml0ZShcIltcIiArIGFyZ3NbMF0ucmVxdWVzdElkICsgXCJdIChcIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKyBcIikgQ2FsbGluZyByZXF1ZXN0IHBpcGVsaW5lIG1ldGhvZCBcIiArIHByb3BlcnR5S2V5ICsgXCIuXCIsIDAgLyogVmVyYm9zZSAqLyk7XHJcbiAgICAgICAgICAgIC8vIHRoZW4gY2hhaW4gdGhlIG5leHQgbWV0aG9kIGluIHRoZSBjb250ZXh0J3MgcGlwZWxpbmUgLSBhbGxvd3MgZm9yIGR5bmFtaWMgcGlwZWxpbmVcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0YXJnZXQsIGFyZ3MpLnRoZW4oZnVuY3Rpb24gKGN0eCkgeyByZXR1cm4gbmV4dChjdHgpOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ29udGFpbnMgdGhlIG1ldGhvZHMgdXNlZCB3aXRoaW4gdGhlIHJlcXVlc3QgcGlwZWxpbmVcclxuICovXHJcbnZhciBQaXBlbGluZU1ldGhvZHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQaXBlbGluZU1ldGhvZHMoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgdGhlIHN0YXJ0IG9mIHRoZSByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIFBpcGVsaW5lTWV0aG9kcy5sb2dTdGFydCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogTG9nZ2VyLmFjdGl2ZUxvZ0xldmVsID09PSAxIC8qIEluZm8gKi8gPyB7fSA6IGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICBsZXZlbDogMSAvKiBJbmZvICovLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJbXCIgKyBjb250ZXh0LnJlcXVlc3RJZCArIFwiXSAoXCIgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgXCIpIEJlZ2lubmluZyBcIiArIGNvbnRleHQudmVyYiArIFwiIHJlcXVlc3QgKFwiICsgY29udGV4dC5yZXF1ZXN0QWJzb2x1dGVVcmwgKyBcIilcIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlc29sdmUoY29udGV4dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGNhY2hpbmcgb2YgdGhlIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgUGlwZWxpbmVNZXRob2RzLmNhY2hpbmcgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgY2FjaGluZywgaWYgYXBwbGljYWJsZVxyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5pc0NhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLndyaXRlKFwiW1wiICsgY29udGV4dC5yZXF1ZXN0SWQgKyBcIl0gKFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFwiKSBDYWNoaW5nIGlzIGVuYWJsZWQgZm9yIHJlcXVlc3QsIGNoZWNraW5nIGNhY2hlLi4uXCIsIDEgLyogSW5mbyAqLyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVPcHRpb25zID0gbmV3IENhY2hpbmdPcHRpb25zKGNvbnRleHQucmVxdWVzdEFic29sdXRlVXJsLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2FjaGluZ09wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlT3B0aW9ucyA9IGV4dGVuZChjYWNoZU9wdGlvbnMsIGNvbnRleHQuY2FjaGluZ09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbWF5IG5vdCBoYXZlIGEgdmFsaWQgc3RvcmVcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZU9wdGlvbnMuc3RvcmUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHRoZSBkYXRhIGluIGNhY2hlIGFuZCBpZiBzbyByZXNvbHZlIHRoZSBwcm9taXNlIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGNhY2hlT3B0aW9ucy5zdG9yZS5nZXQoY2FjaGVPcHRpb25zLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHdlIGNsZWFyIGFueSBoZWxkIGJhdGNoIGRlcGVuZGVuY3kgd2UgYXJlIHJlc29sdmluZyBmcm9tIHRoZSBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IExvZ2dlci5hY3RpdmVMb2dMZXZlbCA9PT0gMSAvKiBJbmZvICovID8ge30gOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IDEgLyogSW5mbyAqLyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiW1wiICsgY29udGV4dC5yZXF1ZXN0SWQgKyBcIl0gKFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFwiKSBWYWx1ZSByZXR1cm5lZCBmcm9tIGNhY2hlLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuYyhjb250ZXh0LmJhdGNoRGVwZW5kZW5jeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmF0Y2hEZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGEgcGFyc2VyIG5lZWRzIHRvIHRha2Ugc3BlY2lhbCBhY3Rpb25zIHdpdGggYSBjYWNoZWQgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoT1AoY29udGV4dC5wYXJzZXIsIFwiaHlkcmF0ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGNvbnRleHQucGFyc2VyLmh5ZHJhdGUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFJlc3VsdChjb250ZXh0LCBkYXRhKS50aGVuKGZ1bmN0aW9uIChjdHgpIHsgcmV0dXJuIHJlc29sdmUoY3R4KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLndyaXRlKFwiW1wiICsgY29udGV4dC5yZXF1ZXN0SWQgKyBcIl0gKFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFwiKSBWYWx1ZSBub3QgZm91bmQgaW4gY2FjaGUuXCIsIDEgLyogSW5mbyAqLyk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCB0aGVuIHdyYXAgdGhlIHN1cHBsaWVkIHBhcnNlciBpbiB0aGUgY2FjaGluZyBwYXJzZXIgd3JhcHBlclxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHNlbmQgdGhpbmdzIG9uIHRoZWlyIHdheVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5wYXJzZXIgPSBuZXcgQ2FjaGluZ1BhcnNlcldyYXBwZXIoY29udGV4dC5wYXJzZXIsIGNhY2hlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY29udGV4dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyB0aGUgcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBQaXBlbGluZU1ldGhvZHMuc2VuZCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgLy8gc2VuZCBvciBiYXRjaCB0aGUgcmVxdWVzdFxyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5pc0JhdGNoZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBpbiBhIGJhdGNoLCBzbyBhZGQgdG8gYmF0Y2gsIHJlbW92ZSBkZXBlbmRlbmN5LCBhbmQgcmVzb2x2ZSB3aXRoIHRoZSBiYXRjaCdzIHByb21pc2VcclxuICAgICAgICAgICAgICAgIHZhciBwID0gY29udGV4dC5iYXRjaC5hZGQoY29udGV4dC5yZXF1ZXN0QWJzb2x1dGVVcmwsIGNvbnRleHQudmVyYiwgY29udGV4dC5vcHRpb25zLCBjb250ZXh0LnBhcnNlciwgY29udGV4dC5yZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgcmVsZWFzZSB0aGUgZGVwZW5kZW5jeSBoZXJlIHRvIGVuc3VyZSB0aGUgYmF0Y2ggZG9lcyBub3QgZXhlY3V0ZSB1bnRpbCB0aGUgcmVxdWVzdCBpcyBhZGRlZCB0byB0aGUgYmF0Y2hcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmMoY29udGV4dC5iYXRjaERlcGVuZGVuY3kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iYXRjaERlcGVuZGVuY3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIExvZ2dlci53cml0ZShcIltcIiArIGNvbnRleHQucmVxdWVzdElkICsgXCJdIChcIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKyBcIikgQmF0Y2hpbmcgcmVxdWVzdCBpbiBiYXRjaCBcIiArIGNvbnRleHQuYmF0Y2guYmF0Y2hJZCArIFwiLlwiLCAxIC8qIEluZm8gKi8pO1xyXG4gICAgICAgICAgICAgICAgLy8gd2Ugc2V0IHRoZSByZXN1bHQgYXMgdGhlIHByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBieSB0aGUgYmF0Y2gncyBleGVjdXRpb25cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoc2V0UmVzdWx0KGNvbnRleHQsIHApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci53cml0ZShcIltcIiArIGNvbnRleHQucmVxdWVzdElkICsgXCJdIChcIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKyBcIikgU2VuZGluZyByZXF1ZXN0LlwiLCAxIC8qIEluZm8gKi8pO1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCBwYXJ0IG9mIGEgYmF0Y2gsIHNvIHByb2NlZWQgYXMgbm9ybWFsXHJcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50ID0gY29udGV4dC5jbGllbnRGYWN0b3J5KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IGV4dGVuZChjb250ZXh0Lm9wdGlvbnMgfHwge30sIHsgbWV0aG9kOiBjb250ZXh0LnZlcmIgfSk7XHJcbiAgICAgICAgICAgICAgICBjbGllbnQuZmV0Y2goY29udGV4dC5yZXF1ZXN0QWJzb2x1dGVVcmwsIG9wdHMpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBjb250ZXh0LnBhcnNlci5wYXJzZShyZXNwb25zZSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gc2V0UmVzdWx0KGNvbnRleHQsIHJlc3VsdCk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGN0eCkgeyByZXR1cm4gcmVzb2x2ZShjdHgpOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcmVqZWN0KGUpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTG9ncyB0aGUgZW5kIG9mIHRoZSByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIFBpcGVsaW5lTWV0aG9kcy5sb2dFbmQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5pc0JhdGNoZWQpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IExvZ2dlci5hY3RpdmVMb2dMZXZlbCA9PT0gMSAvKiBJbmZvICovID8ge30gOiBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiAxIC8qIEluZm8gKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJbXCIgKyBjb250ZXh0LnJlcXVlc3RJZCArIFwiXSAoXCIgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgXCIpIFwiICsgY29udGV4dC52ZXJiICsgXCIgcmVxdWVzdCB3aWxsIGNvbXBsZXRlIGluIGJhdGNoIFwiICsgY29udGV4dC5iYXRjaC5iYXRjaElkICsgXCIuXCIsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IExvZ2dlci5hY3RpdmVMb2dMZXZlbCA9PT0gMSAvKiBJbmZvICovID8ge30gOiBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiAxIC8qIEluZm8gKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJbXCIgKyBjb250ZXh0LnJlcXVlc3RJZCArIFwiXSAoXCIgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgXCIpIENvbXBsZXRpbmcgXCIgKyBjb250ZXh0LnZlcmIgKyBcIiByZXF1ZXN0LlwiLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzb2x2ZShjb250ZXh0KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICByZXF1ZXN0UGlwZWxpbmVNZXRob2QodHJ1ZSlcclxuICAgIF0sIFBpcGVsaW5lTWV0aG9kcywgXCJsb2dTdGFydFwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIHJlcXVlc3RQaXBlbGluZU1ldGhvZCgpXHJcbiAgICBdLCBQaXBlbGluZU1ldGhvZHMsIFwiY2FjaGluZ1wiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIHJlcXVlc3RQaXBlbGluZU1ldGhvZCgpXHJcbiAgICBdLCBQaXBlbGluZU1ldGhvZHMsIFwic2VuZFwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIHJlcXVlc3RQaXBlbGluZU1ldGhvZCh0cnVlKVxyXG4gICAgXSwgUGlwZWxpbmVNZXRob2RzLCBcImxvZ0VuZFwiLCBudWxsKTtcclxuICAgIHJldHVybiBQaXBlbGluZU1ldGhvZHM7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRQaXBlbGluZSgpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgUGlwZWxpbmVNZXRob2RzLmxvZ1N0YXJ0LFxyXG4gICAgICAgIFBpcGVsaW5lTWV0aG9kcy5jYWNoaW5nLFxyXG4gICAgICAgIFBpcGVsaW5lTWV0aG9kcy5zZW5kLFxyXG4gICAgICAgIFBpcGVsaW5lTWV0aG9kcy5sb2dFbmQsXHJcbiAgICBdLnNsaWNlKDApO1xyXG59XG5cbnZhciBRdWVyeWFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBRdWVyeWFibGUoKSB7XHJcbiAgICAgICAgdGhpcy5fcXVlcnkgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3VybCA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50VXJsID0gXCJcIjtcclxuICAgICAgICB0aGlzLl91c2VDYWNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY2FjaGluZ09wdGlvbnMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgdGhlIGN1cnJlbnRsIHVybFxyXG4gICAgKlxyXG4gICAgKi9cclxuICAgIFF1ZXJ5YWJsZS5wcm90b3R5cGUudG9VcmwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERpcmVjdGx5IGNvbmNhdG9uYXRlcyB0aGUgc3VwcGxpZWQgc3RyaW5nIHRvIHRoZSBjdXJyZW50IHVybCwgbm90IG5vcm1hbGl6aW5nIFwiL1wiIGNoYXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGhQYXJ0IFRoZSBzdHJpbmcgdG8gY29uY2F0b25hdGUgdG8gdGhlIHVybFxyXG4gICAgICovXHJcbiAgICBRdWVyeWFibGUucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChwYXRoUGFydCkge1xyXG4gICAgICAgIHRoaXMuX3VybCArPSBwYXRoUGFydDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlhYmxlLnByb3RvdHlwZSwgXCJxdWVyeVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBxdWVyeSBidWlsZGVyIGZvciB0aGlzIHVybFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyeTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBjdXN0b20gb3B0aW9ucyBmb3IgY3VycmVudCBvYmplY3QgYW5kIGFsbCBkZXJpdmVkIG9iamVjdHMgYWNjZXNzaWJsZSB2aWEgY2hhaW5pbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjdXN0b20gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBRdWVyeWFibGUucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgbWVyZ2VPcHRpb25zKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJlcyB0aGlzIGluc3RhbmNlIGZyb20gdGhlIGNvbmZpZ3VyZSBvcHRpb25zIG9mIHRoZSBzdXBwbGllZCBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvIEluc3RhbmNlIGZyb20gd2hpY2ggb3B0aW9ucyBzaG91bGQgYmUgdGFrZW5cclxuICAgICAqL1xyXG4gICAgUXVlcnlhYmxlLnByb3RvdHlwZS5jb25maWd1cmVGcm9tID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBtZXJnZU9wdGlvbnModGhpcy5fb3B0aW9ucywgby5fb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIGNhY2hpbmcgZm9yIHRoaXMgcmVxdWVzdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIERlZmluZXMgdGhlIG9wdGlvbnMgdXNlZCB3aGVuIGNhY2hpbmcgdGhpcyByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIFF1ZXJ5YWJsZS5wcm90b3R5cGUudXNpbmdDYWNoaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIVJ1bnRpbWVDb25maWcuZ2xvYmFsQ2FjaGVEaXNhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VzZUNhY2hpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoaW5nT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgUXVlcnlhYmxlLnByb3RvdHlwZS5nZXRDb3JlID0gZnVuY3Rpb24gKHBhcnNlciwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChwYXJzZXIgPT09IHZvaWQgMCkgeyBwYXJzZXIgPSBuZXcgSlNPTlBhcnNlcigpOyB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICByZXR1cm4gdGhpcy50b1JlcXVlc3RDb250ZXh0KFwiR0VUXCIsIG9wdGlvbnMsIHBhcnNlciwgZ2V0RGVmYXVsdFBpcGVsaW5lKCkpLnRoZW4oZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIHBpcGUoY29udGV4dCk7IH0pO1xyXG4gICAgfTtcclxuICAgIFF1ZXJ5YWJsZS5wcm90b3R5cGUucG9zdENvcmUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyc2VyKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICBpZiAocGFyc2VyID09PSB2b2lkIDApIHsgcGFyc2VyID0gbmV3IEpTT05QYXJzZXIoKTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvUmVxdWVzdENvbnRleHQoXCJQT1NUXCIsIG9wdGlvbnMsIHBhcnNlciwgZ2V0RGVmYXVsdFBpcGVsaW5lKCkpLnRoZW4oZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIHBpcGUoY29udGV4dCk7IH0pO1xyXG4gICAgfTtcclxuICAgIFF1ZXJ5YWJsZS5wcm90b3R5cGUucGF0Y2hDb3JlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcnNlcikge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKHBhcnNlciA9PT0gdm9pZCAwKSB7IHBhcnNlciA9IG5ldyBKU09OUGFyc2VyKCk7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy50b1JlcXVlc3RDb250ZXh0KFwiUEFUQ0hcIiwgb3B0aW9ucywgcGFyc2VyLCBnZXREZWZhdWx0UGlwZWxpbmUoKSkudGhlbihmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gcGlwZShjb250ZXh0KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUXVlcnlhYmxlLnByb3RvdHlwZS5kZWxldGVDb3JlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcnNlcikge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKHBhcnNlciA9PT0gdm9pZCAwKSB7IHBhcnNlciA9IG5ldyBKU09OUGFyc2VyKCk7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy50b1JlcXVlc3RDb250ZXh0KFwiREVMRVRFXCIsIG9wdGlvbnMsIHBhcnNlciwgZ2V0RGVmYXVsdFBpcGVsaW5lKCkpLnRoZW4oZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIHBpcGUoY29udGV4dCk7IH0pO1xyXG4gICAgfTtcclxuICAgIFF1ZXJ5YWJsZS5wcm90b3R5cGUucHV0Q29yZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJzZXIpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIGlmIChwYXJzZXIgPT09IHZvaWQgMCkgeyBwYXJzZXIgPSBuZXcgSlNPTlBhcnNlcigpOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SZXF1ZXN0Q29udGV4dChcIlBVVFwiLCBvcHRpb25zLCBwYXJzZXIsIGdldERlZmF1bHRQaXBlbGluZSgpKS50aGVuKGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBwaXBlKGNvbnRleHQpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgdGhlIGdpdmVuIHN0cmluZyBhbmQgbm9ybWFsaXplcyBcIi9cIiBjaGFyc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoUGFydCBUaGUgc3RyaW5nIHRvIGFwcGVuZFxyXG4gICAgICovXHJcbiAgICBRdWVyeWFibGUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChwYXRoUGFydCkge1xyXG4gICAgICAgIHRoaXMuX3VybCA9IGNvbWJpbmUodGhpcy5fdXJsLCBwYXRoUGFydCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5YWJsZS5wcm90b3R5cGUsIFwicGFyZW50VXJsXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBwYXJlbnQgdXJsIHVzZWQgd2hlbiBjcmVhdGluZyB0aGlzIGluc3RhbmNlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFVybDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kcyB0aGlzIHF1ZXJ5YWJsZSBmcm9tIHRoZSBwcm92aWRlZCBwYXJlbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50IFBhcmVudCBxdWVyeWFibGUgZnJvbSB3aGljaCB3ZSB3aWxsIGRlcml2ZSBhIGJhc2UgdXJsXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBBZGRpdGlvbmFsIHBhdGhcclxuICAgICAqL1xyXG4gICAgUXVlcnlhYmxlLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAocGFyZW50LCBwYXRoKSB7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50VXJsID0gcGFyZW50Ll91cmw7XHJcbiAgICAgICAgdGhpcy5fdXJsID0gY29tYmluZSh0aGlzLl9wYXJlbnRVcmwsIHBhdGggfHwgXCJcIik7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmVGcm9tKHBhcmVudCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFF1ZXJ5YWJsZTtcclxufSgpKTtcclxudmFyIE9EYXRhUXVlcnlhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE9EYXRhUXVlcnlhYmxlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gT0RhdGFRdWVyeWFibGUoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fYmF0Y2ggPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGlzIHF1ZXJ5IHRvIHRoZSBzdXBwbGllZCBiYXRjaFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBsZXQgYiA9IHBucC5zcC5jcmVhdGVCYXRjaCgpO1xyXG4gICAgICogcG5wLnNwLndlYi5pbkJhdGNoKGIpLmdldCgpLnRoZW4oLi4uKTtcclxuICAgICAqIGIuZXhlY3V0ZSgpLnRoZW4oLi4uKVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIE9EYXRhUXVlcnlhYmxlLnByb3RvdHlwZS5pbkJhdGNoID0gZnVuY3Rpb24gKGJhdGNoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2ggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGlzIHF1ZXJ5IGlzIGFscmVhZHkgcGFydCBvZiBhIGJhdGNoLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYmF0Y2ggPSBiYXRjaDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnRsIHVybFxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgT0RhdGFRdWVyeWFibGUucHJvdG90eXBlLnRvVXJsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91cmw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyB0aGUgY3VycmVudGx5IGJ1aWx0IHJlcXVlc3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyc2VyIEFsbG93cyB5b3UgdG8gc3BlY2lmeSBhIHBhcnNlciB0byBoYW5kbGUgdGhlIHJlc3VsdFxyXG4gICAgICogQHBhcmFtIGdldE9wdGlvbnMgVGhlIG9wdGlvbnMgdXNlZCBmb3IgdGhpcyByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIE9EYXRhUXVlcnlhYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyc2VyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHBhcnNlciA9PT0gdm9pZCAwKSB7IHBhcnNlciA9IG5ldyBPRGF0YURlZmF1bHRQYXJzZXIoKTsgfVxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29yZShwYXJzZXIsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIE9EYXRhUXVlcnlhYmxlLnByb3RvdHlwZS5nZXRDb3JlID0gZnVuY3Rpb24gKHBhcnNlciwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChwYXJzZXIgPT09IHZvaWQgMCkgeyBwYXJzZXIgPSBuZXcgT0RhdGFEZWZhdWx0UGFyc2VyKCk7IH1cclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvUmVxdWVzdENvbnRleHQoXCJHRVRcIiwgb3B0aW9ucywgcGFyc2VyLCBnZXREZWZhdWx0UGlwZWxpbmUoKSkudGhlbihmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gcGlwZShjb250ZXh0KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgT0RhdGFRdWVyeWFibGUucHJvdG90eXBlLnBvc3RDb3JlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcnNlcikge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKHBhcnNlciA9PT0gdm9pZCAwKSB7IHBhcnNlciA9IG5ldyBPRGF0YURlZmF1bHRQYXJzZXIoKTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvUmVxdWVzdENvbnRleHQoXCJQT1NUXCIsIG9wdGlvbnMsIHBhcnNlciwgZ2V0RGVmYXVsdFBpcGVsaW5lKCkpLnRoZW4oZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIHBpcGUoY29udGV4dCk7IH0pO1xyXG4gICAgfTtcclxuICAgIE9EYXRhUXVlcnlhYmxlLnByb3RvdHlwZS5wYXRjaENvcmUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyc2VyKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICBpZiAocGFyc2VyID09PSB2b2lkIDApIHsgcGFyc2VyID0gbmV3IE9EYXRhRGVmYXVsdFBhcnNlcigpOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SZXF1ZXN0Q29udGV4dChcIlBBVENIXCIsIG9wdGlvbnMsIHBhcnNlciwgZ2V0RGVmYXVsdFBpcGVsaW5lKCkpLnRoZW4oZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIHBpcGUoY29udGV4dCk7IH0pO1xyXG4gICAgfTtcclxuICAgIE9EYXRhUXVlcnlhYmxlLnByb3RvdHlwZS5kZWxldGVDb3JlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcnNlcikge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKHBhcnNlciA9PT0gdm9pZCAwKSB7IHBhcnNlciA9IG5ldyBPRGF0YURlZmF1bHRQYXJzZXIoKTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvUmVxdWVzdENvbnRleHQoXCJERUxFVEVcIiwgb3B0aW9ucywgcGFyc2VyLCBnZXREZWZhdWx0UGlwZWxpbmUoKSkudGhlbihmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gcGlwZShjb250ZXh0KTsgfSk7XHJcbiAgICB9O1xyXG4gICAgT0RhdGFRdWVyeWFibGUucHJvdG90eXBlLnB1dENvcmUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyc2VyKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICBpZiAocGFyc2VyID09PSB2b2lkIDApIHsgcGFyc2VyID0gbmV3IE9EYXRhRGVmYXVsdFBhcnNlcigpOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SZXF1ZXN0Q29udGV4dChcIlBVVFwiLCBvcHRpb25zLCBwYXJzZXIsIGdldERlZmF1bHRQaXBlbGluZSgpKS50aGVuKGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBwaXBlKGNvbnRleHQpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEJsb2NrcyBhIGJhdGNoIGNhbGwgZnJvbSBvY2N1cmluZywgTVVTVCBiZSBjbGVhcmVkIGJ5IGNhbGxpbmcgdGhlIHJldHVybmVkIGZ1bmN0aW9uXHJcbiAgICAqL1xyXG4gICAgT0RhdGFRdWVyeWFibGUucHJvdG90eXBlLmFkZEJhdGNoRGVwZW5kZW5jeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fYmF0Y2ggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoLmFkZERlcGVuZGVuY3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9EYXRhUXVlcnlhYmxlLnByb3RvdHlwZSwgXCJoYXNCYXRjaFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIHRoZSBjdXJyZW50IHF1ZXJ5IGhhcyBhIGJhdGNoIGFzc29jaWF0ZWRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0RGVmaW5lZE5vdE51bGwodGhpcy5fYmF0Y2gpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9EYXRhUXVlcnlhYmxlLnByb3RvdHlwZSwgXCJiYXRjaFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJhdGNoIGN1cnJlbnRseSBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeSBvciBudWxsXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQmF0Y2ggPyB0aGlzLl9iYXRjaCA6IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gT0RhdGFRdWVyeWFibGU7XHJcbn0oUXVlcnlhYmxlKSk7XG5cbnZhciBPRGF0YUJhdGNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gT0RhdGFCYXRjaChfYmF0Y2hJZCkge1xyXG4gICAgICAgIGlmIChfYmF0Y2hJZCA9PT0gdm9pZCAwKSB7IF9iYXRjaElkID0gZ2V0R1VJRCgpOyB9XHJcbiAgICAgICAgdGhpcy5fYmF0Y2hJZCA9IF9iYXRjaElkO1xyXG4gICAgICAgIHRoaXMuX3JlcXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9kZXBzID0gW107XHJcbiAgICAgICAgdGhpcy5fckRlcHMgPSBbXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPRGF0YUJhdGNoLnByb3RvdHlwZSwgXCJiYXRjaElkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoSWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT0RhdGFCYXRjaC5wcm90b3R5cGUsIFwicmVxdWVzdHNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByZXF1ZXN0cyBjb250YWluZWQgaW4gdGhpcyBiYXRjaFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmwgUmVxdWVzdCB1cmxcclxuICAgICAqIEBwYXJhbSBtZXRob2QgUmVxdWVzdCBtZXRob2QgKEdFVCwgUE9TVCwgZXRjKVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW55IHJlcXVlc3Qgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHBhcnNlciBUaGUgcGFyc2VyIHVzZWQgdG8gaGFuZGxlIHRoZSBldmVudHVhbCByZXR1cm4gZnJvbSB0aGUgcXVlcnlcclxuICAgICAqIEBwYXJhbSBpZCBBbiBpZGVudGlmaWVyIHVzZWQgdG8gdHJhY2sgYSByZXF1ZXN0IHdpdGhpbiBhIGJhdGNoXHJcbiAgICAgKi9cclxuICAgIE9EYXRhQmF0Y2gucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh1cmwsIG1ldGhvZCwgb3B0aW9ucywgcGFyc2VyLCBpZCkge1xyXG4gICAgICAgIHZhciBpbmZvID0ge1xyXG4gICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICAgICAgICAgIHBhcnNlcjogcGFyc2VyLFxyXG4gICAgICAgICAgICByZWplY3Q6IG51bGwsXHJcbiAgICAgICAgICAgIHJlc29sdmU6IG51bGwsXHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGluZm8ucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIGluZm8ucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3JlcXMucHVzaChpbmZvKTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBkZXBlbmRlbmN5IGluc3VyaW5nIHRoYXQgc29tZSBzZXQgb2YgYWN0aW9ucyB3aWxsIG9jY3VyIGJlZm9yZSBhIGJhdGNoIGlzIHByb2Nlc3NlZC5cclxuICAgICAqIE1VU1QgYmUgY2xlYXJlZCB1c2luZyB0aGUgcmV0dXJuZWQgcmVzb2x2ZSBkZWxlZ2F0ZSB0byBhbGxvdyBiYXRjaGVzIHRvIHJ1blxyXG4gICAgICovXHJcbiAgICBPRGF0YUJhdGNoLnByb3RvdHlwZS5hZGREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXNvbHZlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZvaWQgKDApOyB9O1xyXG4gICAgICAgIHRoaXMuX2RlcHMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXRjaCdzIGV4ZWN1dGUgbWV0aG9kIHdpbGwgbm90IHJlc29sdmUgdXRpbCBhbnkgcHJvbWlzZXMgYWRkZWQgaGVyZSByZXNvbHZlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHAgVGhlIGRlcGVuZGVudCBwcm9taXNlXHJcbiAgICAgKi9cclxuICAgIE9EYXRhQmF0Y2gucHJvdG90eXBlLmFkZFJlc29sdmVCYXRjaERlcGVuZGVuY3kgPSBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIHRoaXMuX3JEZXBzLnB1c2gocCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlIHRoZSBjdXJyZW50IGJhdGNoIGFuZCByZXNvbHZlIHRoZSBhc3NvY2lhdGVkIHByb21pc2VzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgb25jZSBhbGwgb2YgdGhlIGJhdGNoJ3MgY2hpbGQgcHJvbWlzZXMgaGF2ZSByZXNvbHZlZFxyXG4gICAgICovXHJcbiAgICBPRGF0YUJhdGNoLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayB0aGUgZGVwZW5kZW5jaWVzIHR3aWNlIGR1ZSB0byBob3cgZGlmZmVyZW50IGVuZ2luZXMgaGFuZGxlIHRoaW5ncy5cclxuICAgICAgICAvLyBXZSBjYW4gZ2V0IGEgc2Vjb25kIHNldCBvZiBwcm9taXNlcyBhZGRlZCBkdXJpbmcgdGhlIGZpcnN0IHNldCByZXNvbHZpbmdcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5fZGVwcylcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5hbGwoX3RoaXMuX2RlcHMpOyB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5leGVjdXRlSW1wbCgpOyB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5fckRlcHMpOyB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB2b2lkICgwKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9EYXRhQmF0Y2g7XHJcbn0oKSk7XG5cbmV4cG9ydCB7IENhY2hpbmdPcHRpb25zLCBDYWNoaW5nUGFyc2VyV3JhcHBlciwgSHR0cFJlcXVlc3RFcnJvciwgT0RhdGFQYXJzZXJCYXNlLCBPRGF0YURlZmF1bHRQYXJzZXIsIFRleHRQYXJzZXIsIEJsb2JQYXJzZXIsIEpTT05QYXJzZXIsIEJ1ZmZlclBhcnNlciwgTGFtYmRhUGFyc2VyLCBzZXRSZXN1bHQsIHBpcGUsIHJlcXVlc3RQaXBlbGluZU1ldGhvZCwgUGlwZWxpbmVNZXRob2RzLCBnZXREZWZhdWx0UGlwZWxpbmUsIFF1ZXJ5YWJsZSwgT0RhdGFRdWVyeWFibGUsIE9EYXRhQmF0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9kYXRhLmVzNS5qcy5tYXBcbiIsIi8qKlxuQGxpY2Vuc2VcbiAqIEBwbnAvc3AgdjEuMi4zIC0gcG5wIC0gcHJvdmlkZXMgYSBmbHVlbnQgYXBpIGZvciB3b3JraW5nIHdpdGggU2hhcmVQb2ludCBSRVNUXG4gKiBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9wbnAvcG5wanMvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIENvcHlyaWdodCAoYykgMjAxOCBNaWNyb3NvZnRcbiAqIGRvY3M6IGh0dHBzOi8vcG5wLmdpdGh1Yi5pby9wbnBqcy9cbiAqIHNvdXJjZTogaHR0cHM6Z2l0aHViLmNvbS9wbnAvcG5wanNcbiAqIGJ1Z3M6IGh0dHBzOi8vZ2l0aHViLmNvbS9wbnAvcG5wanMvaXNzdWVzXG4gKi9cbmltcG9ydCB7IHN0cmluZ0lzTnVsbE9yRW1wdHksIGV4dGVuZCwgY29tYmluZSwgaE9QLCBSdW50aW1lQ29uZmlnLCBGZXRjaENsaWVudCwgbWVyZ2VIZWFkZXJzLCBnZXRDdHhDYWxsYmFjaywgaXNVcmxBYnNvbHV0ZSwgbWVyZ2VPcHRpb25zLCBnZXRHVUlELCBqc1MsIGdldEF0dHJWYWx1ZUZyb21TdHJpbmcsIGRhdGVBZGQsIGdldEhhc2hDb2RlLCBvYmplY3REZWZpbmVkTm90TnVsbCwgaXNBcnJheSB9IGZyb20gJ0BwbnAvY29tbW9uJztcbmltcG9ydCB7IF9fZXh0ZW5kcywgX19kZWNvcmF0ZSB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJ0BwbnAvbG9nZ2luZyc7XG5pbXBvcnQgeyBPRGF0YVBhcnNlckJhc2UsIE9EYXRhRGVmYXVsdFBhcnNlciwgT0RhdGFRdWVyeWFibGUsIFRleHRQYXJzZXIsIEJsb2JQYXJzZXIsIEpTT05QYXJzZXIsIEJ1ZmZlclBhcnNlciwgT0RhdGFCYXRjaCwgQ2FjaGluZ09wdGlvbnMgfSBmcm9tICdAcG5wL29kYXRhJztcblxuZnVuY3Rpb24gZXh0cmFjdFdlYlVybChjYW5kaWRhdGVVcmwpIHtcclxuICAgIGlmIChzdHJpbmdJc051bGxPckVtcHR5KGNhbmRpZGF0ZVVybCkpIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuICAgIHZhciBpbmRleCA9IGNhbmRpZGF0ZVVybC5pbmRleE9mKFwiX2FwaS9cIik7XHJcbiAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgaW5kZXggPSBjYW5kaWRhdGVVcmwuaW5kZXhPZihcIl92dGlfYmluL1wiKTtcclxuICAgIH1cclxuICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVVybC5zdWJzdHIoMCwgaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgYWxsIGVsc2UgZmFpbHMganVzdCBnaXZlIHRoZW0gd2hhdCB0aGV5IGdhdmUgdXMgYmFja1xyXG4gICAgcmV0dXJuIGNhbmRpZGF0ZVVybDtcclxufVxuXG5mdW5jdGlvbiBvZGF0YVVybEZyb20oY2FuZGlkYXRlKSB7XHJcbiAgICB2YXIgcGFydHMgPSBbXTtcclxuICAgIHZhciBzID0gW1wib2RhdGEudHlwZVwiLCBcIm9kYXRhLmVkaXRMaW5rXCIsIFwiX19tZXRhZGF0YVwiLCBcIm9kYXRhLm1ldGFkYXRhXCJdO1xyXG4gICAgaWYgKGhPUChjYW5kaWRhdGUsIHNbMF0pICYmIGNhbmRpZGF0ZVtzWzBdXSA9PT0gXCJTUC5XZWJcIikge1xyXG4gICAgICAgIC8vIHdlYnMgcmV0dXJuIGFuIGFic29sdXRlIHVybCBpbiB0aGUgZWRpdExpbmtcclxuICAgICAgICBpZiAoaE9QKGNhbmRpZGF0ZSwgc1sxXSkpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChjYW5kaWRhdGVbc1sxXV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoT1AoY2FuZGlkYXRlLCBzWzJdKSkge1xyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgZGVhbGluZyB3aXRoIHZlcmJvc2UsIHdoaWNoIGhhcyBhbiBhYnNvbHV0ZSB1cmlcclxuICAgICAgICAgICAgcGFydHMucHVzaChjYW5kaWRhdGUuX19tZXRhZGF0YS51cmkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChoT1AoY2FuZGlkYXRlLCBzWzNdKSAmJiBoT1AoY2FuZGlkYXRlLCBzWzFdKSkge1xyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgZGVhbGlnbiB3aXRoIG1pbmltYWwgbWV0YWRhdGEgKGRlZmF1bHQpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZXh0cmFjdFdlYlVybChjYW5kaWRhdGVbc1szXV0pLCBcIl9hcGlcIiwgY2FuZGlkYXRlW3NbMV1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaE9QKGNhbmRpZGF0ZSwgc1sxXSkpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChcIl9hcGlcIiwgY2FuZGlkYXRlW3NbMV1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaE9QKGNhbmRpZGF0ZSwgc1syXSkpIHtcclxuICAgICAgICAgICAgLy8gd2UgYXJlIGRlYWxpbmcgd2l0aCB2ZXJib3NlLCB3aGljaCBoYXMgYW4gYWJzb2x1dGUgdXJpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goY2FuZGlkYXRlLl9fbWV0YWRhdGEudXJpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgIExvZ2dlci53cml0ZShcIk5vIHVyaSBpbmZvcm1hdGlvbiBmb3VuZCBpbiBPRGF0YUVudGl0eSBwYXJzaW5nLCBjaGFpbmluZyB3aWxsIGZhaWwgZm9yIHRoaXMgb2JqZWN0LlwiLCAyIC8qIFdhcm5pbmcgKi8pO1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbWJpbmUuYXBwbHkodm9pZCAwLCBwYXJ0cyk7XHJcbn1cclxudmFyIFNQT0RhdGFFbnRpdHlQYXJzZXJJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNQT0RhdGFFbnRpdHlQYXJzZXJJbXBsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU1BPRGF0YUVudGl0eVBhcnNlckltcGwoZmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgICAgICAgX3RoaXMuaHlkcmF0ZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gbmV3IF90aGlzLmZhY3Rvcnkob2RhdGFVcmxGcm9tKGQpLCBudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZChvLCBkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFNQT0RhdGFFbnRpdHlQYXJzZXJJbXBsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHIpLnRoZW4oZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSBuZXcgX3RoaXMuZmFjdG9yeShvZGF0YVVybEZyb20oZCksIG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKG8sIGQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTUE9EYXRhRW50aXR5UGFyc2VySW1wbDtcclxufShPRGF0YVBhcnNlckJhc2UpKTtcclxudmFyIFNQT0RhdGFFbnRpdHlBcnJheVBhcnNlckltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU1BPRGF0YUVudGl0eUFycmF5UGFyc2VySW1wbCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNQT0RhdGFFbnRpdHlBcnJheVBhcnNlckltcGwoZmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgICAgICAgX3RoaXMuaHlkcmF0ZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm1hcChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG8gPSBuZXcgX3RoaXMuZmFjdG9yeShvZGF0YVVybEZyb20odiksIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZChvLCB2KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBTUE9EYXRhRW50aXR5QXJyYXlQYXJzZXJJbXBsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHIpLnRoZW4oZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubWFwKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbyA9IG5ldyBfdGhpcy5mYWN0b3J5KG9kYXRhVXJsRnJvbSh2KSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5kKG8sIHYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU1BPRGF0YUVudGl0eUFycmF5UGFyc2VySW1wbDtcclxufShPRGF0YVBhcnNlckJhc2UpKTtcclxuZnVuY3Rpb24gc3BPRGF0YUVudGl0eShmYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gbmV3IFNQT0RhdGFFbnRpdHlQYXJzZXJJbXBsKGZhY3RvcnkpO1xyXG59XHJcbmZ1bmN0aW9uIHNwT0RhdGFFbnRpdHlBcnJheShmYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gbmV3IFNQT0RhdGFFbnRpdHlBcnJheVBhcnNlckltcGwoZmFjdG9yeSk7XHJcbn1cblxuZnVuY3Rpb24gc2V0dXAoY29uZmlnKSB7XHJcbiAgICBSdW50aW1lQ29uZmlnLmV4dGVuZChjb25maWcpO1xyXG59XHJcbnZhciBTUFJ1bnRpbWVDb25maWdJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU1BSdW50aW1lQ29uZmlnSW1wbCgpIHtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTUFJ1bnRpbWVDb25maWdJbXBsLnByb3RvdHlwZSwgXCJoZWFkZXJzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNwUGFydCA9IFJ1bnRpbWVDb25maWcuZ2V0KFwic3BcIik7XHJcbiAgICAgICAgICAgIGlmIChzcFBhcnQgIT09IHVuZGVmaW5lZCAmJiBzcFBhcnQuaGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BQYXJ0LmhlYWRlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNQUnVudGltZUNvbmZpZ0ltcGwucHJvdG90eXBlLCBcImJhc2VVcmxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3BQYXJ0ID0gUnVudGltZUNvbmZpZy5nZXQoXCJzcFwiKTtcclxuICAgICAgICAgICAgaWYgKHNwUGFydCAhPT0gdW5kZWZpbmVkICYmIHNwUGFydC5iYXNlVXJsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzcFBhcnQuYmFzZVVybDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoUnVudGltZUNvbmZpZy5zcGZ4Q29udGV4dCAhPT0gdW5kZWZpbmVkICYmIFJ1bnRpbWVDb25maWcuc3BmeENvbnRleHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBSdW50aW1lQ29uZmlnLnNwZnhDb250ZXh0LnBhZ2VDb250ZXh0LndlYi5hYnNvbHV0ZVVybDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTUFJ1bnRpbWVDb25maWdJbXBsLnByb3RvdHlwZSwgXCJmZXRjaENsaWVudEZhY3RvcnlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3BQYXJ0ID0gUnVudGltZUNvbmZpZy5nZXQoXCJzcFwiKTtcclxuICAgICAgICAgICAgLy8gdXNlIGEgY29uZmlndXJlZCBmYWN0b3J5IGZpcnRcclxuICAgICAgICAgICAgaWYgKHNwUGFydCAhPT0gdW5kZWZpbmVkICYmIHNwUGFydC5mZXRjaENsaWVudEZhY3RvcnkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwUGFydC5mZXRjaENsaWVudEZhY3Rvcnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEZldGNoQ2xpZW50KCk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBTUFJ1bnRpbWVDb25maWdJbXBsO1xyXG59KCkpO1xyXG52YXIgU1BSdW50aW1lQ29uZmlnID0gbmV3IFNQUnVudGltZUNvbmZpZ0ltcGwoKTtcblxudmFyIENhY2hlZERpZ2VzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhY2hlZERpZ2VzdCgpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBDYWNoZWREaWdlc3Q7XHJcbn0oKSk7XHJcbi8vIGFsbG93cyBmb3IgdGhlIGNhY2hpbmcgb2YgZGlnZXN0cyBhY3Jvc3MgYWxsIEh0dHBDbGllbnQncyB3aGljaCBlYWNoIGhhdmUgdGhlaXIgb3duIERpZ2VzdENhY2hlIHdyYXBwZXIuXHJcbnZhciBkaWdlc3RzID0gbmV3IE1hcCgpO1xyXG52YXIgRGlnZXN0Q2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEaWdlc3RDYWNoZShfaHR0cENsaWVudCwgX2RpZ2VzdHMpIHtcclxuICAgICAgICBpZiAoX2RpZ2VzdHMgPT09IHZvaWQgMCkgeyBfZGlnZXN0cyA9IGRpZ2VzdHM7IH1cclxuICAgICAgICB0aGlzLl9odHRwQ2xpZW50ID0gX2h0dHBDbGllbnQ7XHJcbiAgICAgICAgdGhpcy5fZGlnZXN0cyA9IF9kaWdlc3RzO1xyXG4gICAgfVxyXG4gICAgRGlnZXN0Q2FjaGUucHJvdG90eXBlLmdldERpZ2VzdCA9IGZ1bmN0aW9uICh3ZWJVcmwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjYWNoZWREaWdlc3QgPSB0aGlzLl9kaWdlc3RzLmdldCh3ZWJVcmwpO1xyXG4gICAgICAgIGlmIChjYWNoZWREaWdlc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG5vdyA8IGNhY2hlZERpZ2VzdC5leHBpcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZERpZ2VzdC52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVybCA9IGNvbWJpbmUod2ViVXJsLCBcIi9fYXBpL2NvbnRleHRpbmZvXCIpO1xyXG4gICAgICAgIHZhciBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICBcIkFjY2VwdFwiOiBcImFwcGxpY2F0aW9uL2pzb247b2RhdGE9dmVyYm9zZVwiLFxyXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247b2RhdGE9dmVyYm9zZTtjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5faHR0cENsaWVudC5mZXRjaFJhdyh1cmwsIHtcclxuICAgICAgICAgICAgY2FjaGU6IFwibm8tY2FjaGVcIixcclxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcclxuICAgICAgICAgICAgaGVhZGVyczogZXh0ZW5kKGhlYWRlcnMsIFNQUnVudGltZUNvbmZpZy5oZWFkZXJzLCB0cnVlKSxcclxuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IE9EYXRhRGVmYXVsdFBhcnNlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlKHJlc3BvbnNlKS50aGVuKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLkdldENvbnRleHRXZWJJbmZvcm1hdGlvbjsgfSk7XHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgbmV3Q2FjaGVkRGlnZXN0ID0gbmV3IENhY2hlZERpZ2VzdCgpO1xyXG4gICAgICAgICAgICBuZXdDYWNoZWREaWdlc3QudmFsdWUgPSBkYXRhLkZvcm1EaWdlc3RWYWx1ZTtcclxuICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBkYXRhLkZvcm1EaWdlc3RUaW1lb3V0U2Vjb25kcztcclxuICAgICAgICAgICAgdmFyIGV4cGlyYXRpb24gPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBleHBpcmF0aW9uLnNldFRpbWUoZXhwaXJhdGlvbi5nZXRUaW1lKCkgKyAxMDAwICogc2Vjb25kcyk7XHJcbiAgICAgICAgICAgIG5ld0NhY2hlZERpZ2VzdC5leHBpcmF0aW9uID0gZXhwaXJhdGlvbjtcclxuICAgICAgICAgICAgX3RoaXMuX2RpZ2VzdHMuc2V0KHdlYlVybCwgbmV3Q2FjaGVkRGlnZXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0NhY2hlZERpZ2VzdC52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEaWdlc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlnZXN0cy5jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEaWdlc3RDYWNoZTtcclxufSgpKTtcblxudmFyIFNQSHR0cENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNQSHR0cENsaWVudChfaW1wbCkge1xyXG4gICAgICAgIGlmIChfaW1wbCA9PT0gdm9pZCAwKSB7IF9pbXBsID0gU1BSdW50aW1lQ29uZmlnLmZldGNoQ2xpZW50RmFjdG9yeSgpOyB9XHJcbiAgICAgICAgdGhpcy5faW1wbCA9IF9pbXBsO1xyXG4gICAgICAgIHRoaXMuX2RpZ2VzdENhY2hlID0gbmV3IERpZ2VzdENhY2hlKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgU1BIdHRwQ2xpZW50LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIG9wdHMgPSBleHRlbmQob3B0aW9ucywgeyBjYWNoZTogXCJuby1jYWNoZVwiLCBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiIH0sIHRydWUpO1xyXG4gICAgICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcclxuICAgICAgICAvLyBmaXJzdCB3ZSBhZGQgdGhlIGdsb2JhbCBoZWFkZXJzIHNvIHRoZXkgY2FuIGJlIG92ZXJ3cml0dGVuIGJ5IGFueSBwYXNzZWQgaW4gbG9jYWxseSB0byB0aGlzIGNhbGxcclxuICAgICAgICBtZXJnZUhlYWRlcnMoaGVhZGVycywgU1BSdW50aW1lQ29uZmlnLmhlYWRlcnMpO1xyXG4gICAgICAgIC8vIHNlY29uZCB3ZSBhZGQgdGhlIGxvY2FsIG9wdGlvbnMgc28gd2UgY2FuIG92ZXJ3cml0ZSB0aGUgZ2xvYmFsc1xyXG4gICAgICAgIG1lcmdlSGVhZGVycyhoZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xyXG4gICAgICAgIC8vIGxhc3RseSB3ZSBhcHBseSBhbnkgZGVmYXVsdCBoZWFkZXJzIHdlIG5lZWQgdGhhdCBtYXkgbm90IGV4aXN0XHJcbiAgICAgICAgaWYgKCFoZWFkZXJzLmhhcyhcIkFjY2VwdFwiKSkge1xyXG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcclxuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uO29kYXRhPXZlcmJvc2U7Y2hhcnNldD11dGYtOFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFoZWFkZXJzLmhhcyhcIlgtQ2xpZW50U2VydmljZS1DbGllbnRUYWdcIikpIHtcclxuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoXCJYLUNsaWVudFNlcnZpY2UtQ2xpZW50VGFnXCIsIFwiUG5QQ29yZUpTOkBwbnAtMS4yLjNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaGVhZGVycy5oYXMoXCJVc2VyLUFnZW50XCIpKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgbWFya3MgdGhlIHJlcXVlc3RzIGZvciB1bmRlcnN0YW5kaW5nIGJ5IHRoZSBzZXJ2aWNlXHJcbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKFwiVXNlci1BZ2VudFwiLCBcIk5PTklTVnxTaGFyZVBvaW50UG5QfFBuUENvcmVKUy8xLjIuM1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0cyA9IGV4dGVuZChvcHRzLCB7IGhlYWRlcnM6IGhlYWRlcnMgfSk7XHJcbiAgICAgICAgaWYgKG9wdHMubWV0aG9kICYmIG9wdHMubWV0aG9kLnRvVXBwZXJDYXNlKCkgIT09IFwiR0VUXCIpIHtcclxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBlaXRoZXIgYSByZXF1ZXN0IGRpZ2VzdCBvciBhbiBhdXRob3JpemF0aW9uIGhlYWRlciB3ZSBkb24ndCBuZWVkIGEgZGlnZXN0XHJcbiAgICAgICAgICAgIGlmICghaGVhZGVycy5oYXMoXCJYLVJlcXVlc3REaWdlc3RcIikgJiYgIWhlYWRlcnMuaGFzKFwiQXV0aG9yaXphdGlvblwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpZ2VzdENhY2hlLmdldERpZ2VzdChleHRyYWN0V2ViVXJsKHVybCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRpZ2VzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKFwiWC1SZXF1ZXN0RGlnZXN0XCIsIGRpZ2VzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZldGNoUmF3KHVybCwgb3B0cyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFJhdyh1cmwsIG9wdHMpO1xyXG4gICAgfTtcclxuICAgIFNQSHR0cENsaWVudC5wcm90b3R5cGUuZmV0Y2hSYXcgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIC8vIGhlcmUgd2UgbmVlZCB0byBub3JtYWxpemUgdGhlIGhlYWRlcnNcclxuICAgICAgICB2YXIgcmF3SGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcbiAgICAgICAgbWVyZ2VIZWFkZXJzKHJhd0hlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyk7XHJcbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZChvcHRpb25zLCB7IGhlYWRlcnM6IHJhd0hlYWRlcnMgfSk7XHJcbiAgICAgICAgdmFyIHJldHJ5ID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAvLyBoYW5kbGVzIHNldHRpbmcgdGhlIHByb3BlciB0aW1lb3V0IGZvciBhIHJldHJ5XHJcbiAgICAgICAgICAgIHZhciBzZXRSZXRyeSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbGF5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiUmV0cnktQWZ0ZXJcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGdvdHRlbiBhIGhlYWRlciwgdXNlIHRoYXQgdmFsdWUgYXMgdGhlIGRlbGF5IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzLmdldChcIlJldHJ5LUFmdGVyXCIpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBncmFiIG91ciBjdXJyZW50IGRlbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBjdHguZGVsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50IG91ciBjb3VudGVycy5cclxuICAgICAgICAgICAgICAgICAgICBjdHguZGVsYXkgKj0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN0eC5hdHRlbXB0cysrO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBleGNlZWRlZCB0aGUgcmV0cnkgY291bnQsIHJlamVjdC5cclxuICAgICAgICAgICAgICAgIGlmIChjdHgucmV0cnlDb3VudCA8PSBjdHguYXR0ZW1wdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHgucmVqZWN0KEVycm9yKFwiUmV0cnkgY291bnQgZXhjZWVkZWQgKFwiICsgY3R4LnJldHJ5Q291bnQgKyBcIikgZm9yIHJlcXVlc3QuIFJlc3BvbnNlIHN0YXR1czogW1wiICsgcmVzcG9uc2Uuc3RhdHVzICsgXCJdIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IG91ciByZXRyeSB0aW1lb3V0IGZvciB7ZGVsYXl9IG1pbGxpc2Vjb25kcy5cclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGdldEN0eENhbGxiYWNrKF90aGlzLCByZXRyeSwgY3R4KSwgZGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBzZW5kIHRoZSBhY3R1YWwgcmVxdWVzdFxyXG4gICAgICAgICAgICBfdGhpcy5faW1wbC5mZXRjaCh1cmwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGJlZW4gdGhyb3R0bGVkXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0UmV0cnkocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwMykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHAgc3RhdHVzIGNvZGUgNTAzLCB3ZSBjYW4gcmV0cnkgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFJldHJ5KHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWplY3QocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXRyeUNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBhdHRlbXB0czogMCxcclxuICAgICAgICAgICAgICAgIGRlbGF5OiAxMDAsXHJcbiAgICAgICAgICAgICAgICByZWplY3Q6IHJlamVjdCxcclxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXHJcbiAgICAgICAgICAgICAgICByZXRyeUNvdW50OiA3LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXRyeS5jYWxsKF90aGlzLCByZXRyeUNvbnRleHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFNQSHR0cENsaWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIG9wdHMgPSBleHRlbmQob3B0aW9ucywgeyBtZXRob2Q6IFwiR0VUXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2godXJsLCBvcHRzKTtcclxuICAgIH07XHJcbiAgICBTUEh0dHBDbGllbnQucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB2YXIgb3B0cyA9IGV4dGVuZChvcHRpb25zLCB7IG1ldGhvZDogXCJQT1NUXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2godXJsLCBvcHRzKTtcclxuICAgIH07XHJcbiAgICBTUEh0dHBDbGllbnQucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIG9wdHMgPSBleHRlbmQob3B0aW9ucywgeyBtZXRob2Q6IFwiUEFUQ0hcIiB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCh1cmwsIG9wdHMpO1xyXG4gICAgfTtcclxuICAgIFNQSHR0cENsaWVudC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIG9wdHMgPSBleHRlbmQob3B0aW9ucywgeyBtZXRob2Q6IFwiREVMRVRFXCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2godXJsLCBvcHRzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU1BIdHRwQ2xpZW50O1xyXG59KCkpO1xuXG52YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gICAgICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcblxuLyoqXHJcbiAqIEVuc3VyZXMgdGhhdCBhIGdpdmVuIHVybCBpcyBhYnNvbHV0ZSBmb3IgdGhlIGN1cnJlbnQgd2ViIGJhc2VkIG9uIGNvbnRleHRcclxuICpcclxuICogQHBhcmFtIGNhbmRpZGF0ZVVybCBUaGUgdXJsIHRvIG1ha2UgYWJzb2x1dGVcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHRvQWJzb2x1dGVVcmwoY2FuZGlkYXRlVXJsKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICBpZiAoaXNVcmxBYnNvbHV0ZShjYW5kaWRhdGVVcmwpKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBhbHJlYWR5IGFic29sdXRlLCB0aGVuIGp1c3QgcmV0dXJuIHRoZSB1cmxcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY2FuZGlkYXRlVXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFNQUnVudGltZUNvbmZpZy5iYXNlVXJsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIGJhc2UgdXJsIHNwZWNpZmllZCBlaXRoZXIgd2l0aCBiYXNlVXJsIG9mIHNwZnhDb250ZXh0IGNvbmZpZyBwcm9wZXJ0eVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjb21iaW5lKFNQUnVudGltZUNvbmZpZy5iYXNlVXJsLCBjYW5kaWRhdGVVcmwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdsb2JhbCQxLl9zcFBhZ2VDb250ZXh0SW5mbyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIG9wZXJhdGluZyBpbiBjbGFzc2ljIHBhZ2VzXHJcbiAgICAgICAgICAgIGlmIChoT1AoZ2xvYmFsJDEuX3NwUGFnZUNvbnRleHRJbmZvLCBcIndlYkFic29sdXRlVXJsXCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjb21iaW5lKGdsb2JhbCQxLl9zcFBhZ2VDb250ZXh0SW5mby53ZWJBYnNvbHV0ZVVybCwgY2FuZGlkYXRlVXJsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaE9QKGdsb2JhbCQxLl9zcFBhZ2VDb250ZXh0SW5mbywgXCJ3ZWJTZXJ2ZXJSZWxhdGl2ZVVybFwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY29tYmluZShnbG9iYWwkMS5fc3BQYWdlQ29udGV4dEluZm8ud2ViU2VydmVyUmVsYXRpdmVVcmwsIGNhbmRpZGF0ZVVybCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRvZXMgd2luZG93LmxvY2F0aW9uIGV4aXN0IGFuZCBoYXZlIGEgY2VydGFpbiBwYXRoIHBhcnQgaW4gaXQ/XHJcbiAgICAgICAgaWYgKGdsb2JhbCQxLmxvY2F0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxfMSA9IGdsb2JhbCQxLmxvY2F0aW9uLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgW1wiL19sYXlvdXRzL1wiLCBcIi9zaXRlYXNzZXRzL1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlVXJsXzEuaW5kZXhPZihzKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjb21iaW5lKGJhc2VVcmxfMS5zdWJzdHIoMCwgaW5kZXgpLCBjYW5kaWRhdGVVcmwpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNvbHZlKGNhbmRpZGF0ZVVybCk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBtZXRhZGF0YSh0eXBlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIFwiX19tZXRhZGF0YVwiOiB7IFwidHlwZVwiOiB0eXBlIH0sXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBTaGFyZVBvaW50UXVlcnlhYmxlIEJhc2UgQ2xhc3NcclxuICpcclxuICovXHJcbnZhciBTaGFyZVBvaW50UXVlcnlhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNoYXJlUG9pbnRRdWVyeWFibGUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFNoYXJlUG9pbnRRdWVyeWFibGUgY2xhc3NcclxuICAgICAqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSBiYXNlVXJsIEEgc3RyaW5nIG9yIFNoYXJlUG9pbnRRdWVyeWFibGUgdGhhdCBzaG91bGQgZm9ybSB0aGUgYmFzZSBwYXJ0IG9mIHRoZSB1cmxcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFNoYXJlUG9pbnRRdWVyeWFibGUoYmFzZVVybCwgcGF0aCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2ZvcmNlQ2FjaGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmFzZVVybCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRvIHNvbWUgZXh0cmEgcGFyc2luZyB0byBnZXQgdGhlIHBhcmVudCB1cmwgY29ycmVjdCBpZiB3ZSBhcmVcclxuICAgICAgICAgICAgLy8gYmVpbmcgY3JlYXRlZCBmcm9tIGp1c3QgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgIGlmIChpc1VybEFic29sdXRlKGJhc2VVcmwpIHx8IGJhc2VVcmwubGFzdEluZGV4T2YoXCIvXCIpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3BhcmVudFVybCA9IGJhc2VVcmw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdXJsID0gY29tYmluZShiYXNlVXJsLCBwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChiYXNlVXJsLmxhc3RJbmRleE9mKFwiL1wiKSA+IGJhc2VVcmwubGFzdEluZGV4T2YoXCIoXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAuLi4vaXRlbXMoMTkpL2ZpZWxkc1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYmFzZVVybC5sYXN0SW5kZXhPZihcIi9cIik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGFyZW50VXJsID0gYmFzZVVybC5zbGljZSgwLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gY29tYmluZShiYXNlVXJsLnNsaWNlKGluZGV4KSwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdXJsID0gY29tYmluZShfdGhpcy5fcGFyZW50VXJsLCBwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIC4uLi9pdGVtcygxOSlcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGJhc2VVcmwubGFzdEluZGV4T2YoXCIoXCIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3BhcmVudFVybCA9IGJhc2VVcmwuc2xpY2UoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3VybCA9IGNvbWJpbmUoYmFzZVVybCwgcGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4dGVuZChiYXNlVXJsLCBwYXRoKTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGJhc2VVcmwucXVlcnkuZ2V0KFwiQHRhcmdldFwiKTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5xdWVyeS5zZXQoXCJAdGFyZ2V0XCIsIHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBzdXBwbGllZCBmYWN0b3J5IGFuZCBleHRlbmRzIHRoaXMgaW50byB0aGF0IG5ldyBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmYWN0b3J5IGNvbnN0cnVjdG9yIGZvciB0aGUgbmV3IFNoYXJlUG9pbnRRdWVyeWFibGVcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZS5wcm90b3R5cGUuYXMgPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBvID0gbmV3IGZhY3RvcnkodGhpcy5fdXJsLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kKG8sIHRoaXMsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZnVsbCB1cmwgd2l0aCBxdWVyeSBpbmZvcm1hdGlvblxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZS5wcm90b3R5cGUudG9VcmxBbmRRdWVyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYWxpYXNlZFBhcmFtcyA9IG5ldyBNYXAodGhpcy5xdWVyeSk7XHJcbiAgICAgICAgdmFyIHVybCA9IHRoaXMudG9VcmwoKS5yZXBsYWNlKC8nIShALio/KTo6KC4qPyknL2lnLCBmdW5jdGlvbiAobWF0Y2gsIGxhYmVsTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLndyaXRlKFwiUmV3cml0aW5nIGFsaWFzZWQgcGFyYW1ldGVyIGZyb20gbWF0Y2ggXCIgKyBtYXRjaCArIFwiIHRvIGxhYmVsOiBcIiArIGxhYmVsTmFtZSArIFwiIHZhbHVlOiBcIiArIHZhbHVlLCAwIC8qIFZlcmJvc2UgKi8pO1xyXG4gICAgICAgICAgICBhbGlhc2VkUGFyYW1zLnNldChsYWJlbE5hbWUsIFwiJ1wiICsgdmFsdWUgKyBcIidcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbE5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGFsaWFzZWRQYXJhbXMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGNoYXIgPSB1cmwuaW5kZXhPZihcIj9cIikgPiAtMSA/IFwiJlwiIDogXCI/XCI7XHJcbiAgICAgICAgICAgIHVybCArPSBcIlwiICsgY2hhciArIEFycmF5LmZyb20oYWxpYXNlZFBhcmFtcykubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2WzBdICsgXCI9XCIgKyB2WzFdOyB9KS5qb2luKFwiJlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENob29zZSB3aGljaCBmaWVsZHMgdG8gcmV0dXJuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlbGVjdHMgT25lIG9yIG1vcmUgZmllbGRzIHRvIHJldHVyblxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGVjdHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBzZWxlY3RzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxlY3RzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeS5zZXQoXCIkc2VsZWN0XCIsIHNlbGVjdHMuam9pbihcIixcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4cGFuZHMgZmllbGRzIHN1Y2ggYXMgbG9va3VwcyB0byBnZXQgYWRkaXRpb25hbCBkYXRhXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV4cGFuZHMgVGhlIEZpZWxkcyBmb3Igd2hpY2ggdG8gZXhwYW5kIHRoZSB2YWx1ZXNcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZS5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBleHBhbmRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgZXhwYW5kc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhwYW5kcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkuc2V0KFwiJGV4cGFuZFwiLCBleHBhbmRzLmpvaW4oXCIsXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgcGFyZW50IGZvciB0aGlzIGluc3RhbmNlIGFzIHNwZWNpZmllZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmYWN0b3J5IFRoZSBjb250cnVjdG9yIGZvciB0aGUgY2xhc3MgdG8gY3JlYXRlXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIChmYWN0b3J5LCBiYXNlVXJsLCBwYXRoLCBiYXRjaCkge1xyXG4gICAgICAgIGlmIChiYXNlVXJsID09PSB2b2lkIDApIHsgYmFzZVVybCA9IHRoaXMucGFyZW50VXJsOyB9XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IG5ldyBmYWN0b3J5KGJhc2VVcmwsIHBhdGgpLmNvbmZpZ3VyZUZyb20odGhpcyk7XHJcbiAgICAgICAgdmFyIHQgPSBcIkB0YXJnZXRcIjtcclxuICAgICAgICBpZiAodGhpcy5xdWVyeS5oYXModCkpIHtcclxuICAgICAgICAgICAgcGFyZW50LnF1ZXJ5LnNldCh0LCB0aGlzLnF1ZXJ5LmdldCh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiYXRjaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5pbkJhdGNoKGJhdGNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsb25lcyB0aGlzIFNoYXJlUG9pbnRRdWVyeWFibGUgaW50byBhIG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlIGluc3RhbmNlIG9mIFRcclxuICAgICAqIEBwYXJhbSBmYWN0b3J5IENvbnN0cnVjdG9yIHVzZWQgdG8gY3JlYXRlIHRoZSBuZXcgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsUGF0aCBBbnkgYWRkaXRpb25hbCBwYXRoIHRvIGluY2x1ZGUgaW4gdGhlIGNsb25lXHJcbiAgICAgKiBAcGFyYW0gaW5jbHVkZUJhdGNoIElmIHRydWUgdGhpcyBpbnN0YW5jZSdzIGJhdGNoIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNsb25lZCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBhZGRpdGlvbmFsUGF0aCwgaW5jbHVkZUJhdGNoKSB7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVCYXRjaCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVCYXRjaCA9IHRydWU7IH1cclxuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgZmFjdG9yeSh0aGlzLCBhZGRpdGlvbmFsUGF0aCkuY29uZmlndXJlRnJvbSh0aGlzKTtcclxuICAgICAgICB2YXIgdCA9IFwiQHRhcmdldFwiO1xyXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmhhcyh0KSkge1xyXG4gICAgICAgICAgICBjbG9uZS5xdWVyeS5zZXQodCwgdGhpcy5xdWVyeS5nZXQodCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5jbHVkZUJhdGNoICYmIHRoaXMuaGFzQmF0Y2gpIHtcclxuICAgICAgICAgICAgY2xvbmUgPSBjbG9uZS5pbkJhdGNoKHRoaXMuYmF0Y2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCBpbnN0YW5jZSB0byBhIHJlcXVlc3QgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2ZXJiIFRoZSByZXF1ZXN0IHZlcmJcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBzZXQgb2Ygc3VwcGxpZWQgcmVxdWVzdCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gcGFyc2VyIFRoZSBzdXBwbGllZCBPRGF0YVBhcnNlciBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHBpcGVsaW5lIE9wdGlvbmFsIHJlcXVlc3QgcHJvY2Vzc2luZyBwaXBlbGluZVxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlLnByb3RvdHlwZS50b1JlcXVlc3RDb250ZXh0ID0gZnVuY3Rpb24gKHZlcmIsIG9wdGlvbnMsIHBhcnNlciwgcGlwZWxpbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIGRlcGVuZGVuY3lEaXNwb3NlID0gdGhpcy5oYXNCYXRjaCA/IHRoaXMuYWRkQmF0Y2hEZXBlbmRlbmN5KCkgOiBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICByZXR1cm4gdG9BYnNvbHV0ZVVybCh0aGlzLnRvVXJsQW5kUXVlcnkoKSkudGhlbihmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgIG1lcmdlT3B0aW9ucyhvcHRpb25zLCBfdGhpcy5fb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIGJ1aWxkIG91ciByZXF1ZXN0IGNvbnRleHRcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaDogX3RoaXMuYmF0Y2gsXHJcbiAgICAgICAgICAgICAgICBiYXRjaERlcGVuZGVuY3k6IGRlcGVuZGVuY3lEaXNwb3NlLFxyXG4gICAgICAgICAgICAgICAgY2FjaGluZ09wdGlvbnM6IF90aGlzLl9jYWNoaW5nT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIGNsaWVudEZhY3Rvcnk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTUEh0dHBDbGllbnQoKTsgfSxcclxuICAgICAgICAgICAgICAgIGlzQmF0Y2hlZDogX3RoaXMuaGFzQmF0Y2gsXHJcbiAgICAgICAgICAgICAgICBpc0NhY2hlZDogX3RoaXMuX2ZvcmNlQ2FjaGluZyB8fCAoX3RoaXMuX3VzZUNhY2hpbmcgJiYgL15nZXQkL2kudGVzdCh2ZXJiKSksXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgcGFyc2VyOiBwYXJzZXIsXHJcbiAgICAgICAgICAgICAgICBwaXBlbGluZTogcGlwZWxpbmUsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0QWJzb2x1dGVVcmw6IHVybCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogZ2V0R1VJRCgpLFxyXG4gICAgICAgICAgICAgICAgdmVyYjogdmVyYixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNoYXJlUG9pbnRRdWVyeWFibGU7XHJcbn0oT0RhdGFRdWVyeWFibGUpKTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBSRVNUIGNvbGxlY3Rpb24gd2hpY2ggY2FuIGJlIGZpbHRlcmVkLCBwYWdlZCwgYW5kIHNlbGVjdGVkXHJcbiAqXHJcbiAqL1xyXG52YXIgU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbHRlcnMgdGhlIHJldHVybmVkIGNvbGxlY3Rpb24gKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvb2ZmaWNlL2ZwMTQyMzg1LmFzcHgjYmtfc3VwcG9ydGVkKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWx0ZXIgVGhlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZpbHRlciBxdWVyeVxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIHRoaXMucXVlcnkuc2V0KFwiJGZpbHRlclwiLCBmaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogT3JkZXJzIGJhc2VkIG9uIHRoZSBzdXBwbGllZCBmaWVsZHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3JkZXJieSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgb24gd2hpY2ggdG8gc29ydFxyXG4gICAgICogQHBhcmFtIGFzY2VuZGluZyBJZiBmYWxzZSBERVNDIGlzIGFwcGVuZGVkLCBvdGhlcndpc2UgQVNDIChkZWZhdWx0KVxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUub3JkZXJCeSA9IGZ1bmN0aW9uIChvcmRlckJ5LCBhc2NlbmRpbmcpIHtcclxuICAgICAgICBpZiAoYXNjZW5kaW5nID09PSB2b2lkIDApIHsgYXNjZW5kaW5nID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBvID0gXCIkb3JkZXJieVwiO1xyXG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkuaGFzKG8pID8gdGhpcy5xdWVyeS5nZXQobykuc3BsaXQoXCIsXCIpIDogW107XHJcbiAgICAgICAgcXVlcnkucHVzaChvcmRlckJ5ICsgXCIgXCIgKyAoYXNjZW5kaW5nID8gXCJhc2NcIiA6IFwiZGVzY1wiKSk7XHJcbiAgICAgICAgdGhpcy5xdWVyeS5zZXQobywgcXVlcnkuam9pbihcIixcIikpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgaXRlbXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2tpcCBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHNraXBcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoc2tpcCkge1xyXG4gICAgICAgIHRoaXMucXVlcnkuc2V0KFwiJHNraXBcIiwgc2tpcC50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExpbWl0cyB0aGUgcXVlcnkgdG8gb25seSByZXR1cm4gdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgaXRlbXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdG9wIFRoZSBxdWVyeSByb3cgbGltaXRcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICh0b3ApIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5LnNldChcIiR0b3BcIiwgdG9wLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbjtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlKSk7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbmNlIHRoYXQgY2FuIGJlIHNlbGVjdGVkXHJcbiAqXHJcbiAqL1xyXG52YXIgU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEN1cnJpZXMgdGhlIHVwZGF0ZSBmdW5jdGlvbiBpbnRvIHRoZSBjb21tb24gcGllY2VzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHR5cGVcclxuICAgICAqIEBwYXJhbSBtYXBwZXJcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHR5cGUsIG1hcHBlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gX3RoaXMucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1MoZXh0ZW5kKG1ldGFkYXRhKHR5cGUpLCBwcm9wcykpLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBcIlgtSFRUUC1NZXRob2RcIjogXCJNRVJHRVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGQpIHsgcmV0dXJuIG1hcHBlcihkLCBwcm9wcyk7IH0pOyB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBEZWxldGVzIHRoaXMgaW5zdGFuY2VcclxuICAgICpcclxuICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UucHJvdG90eXBlLl9kZWxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBcIlgtSFRUUC1NZXRob2RcIjogXCJERUxFVEVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhpcyBpbnN0YW5jZSB3aXRoIGFuIGV0YWcgdmFsdWUgaW4gdGhlIGhlYWRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZVRhZyBlVGFnIHRvIGRlbGV0ZVxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UucHJvdG90eXBlLl9kZWxldGVXaXRoRVRhZyA9IGZ1bmN0aW9uIChlVGFnKSB7XHJcbiAgICAgICAgaWYgKGVUYWcgPT09IHZvaWQgMCkgeyBlVGFnID0gXCIqXCI7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgIFwiSUYtTWF0Y2hcIjogZVRhZyxcclxuICAgICAgICAgICAgICAgIFwiWC1IVFRQLU1ldGhvZFwiOiBcIkRFTEVURVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2U7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZSkpO1xyXG4vKipcclxuICogRGVjb3JhdG9yIHVzZWQgdG8gc3BlY2lmeSB0aGUgZGVmYXVsdCBwYXRoIGZvciBTaGFyZVBvaW50UXVlcnlhYmxlIG9iamVjdHNcclxuICpcclxuICogQHBhcmFtIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIGRlZmF1bHRQYXRoKHBhdGgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYXJnc1swXSwgYXJncy5sZW5ndGggPiAxICYmIGFyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3NbMV0gOiBwYXRoKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgICAgIH0odGFyZ2V0KSk7XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBjb2xsZWN0aW9uIG9mIGFsbCBzaXRlIGNvbGxlY3Rpb24gdXNlcnNcclxuICpcclxuICovXHJcbnZhciBTaXRlVXNlcnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2l0ZVVzZXJzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2l0ZVVzZXJzKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFNpdGVVc2Vyc18xID0gU2l0ZVVzZXJzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgdXNlciBmcm9tIHRoZSBjb2xsZWN0aW9uIGJ5IGlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgdXNlciB0byByZXRyaWV2ZVxyXG4gICAgICovXHJcbiAgICBTaXRlVXNlcnMucHJvdG90eXBlLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNpdGVVc2VyKHRoaXMsIFwiZ2V0QnlJZChcIiArIGlkICsgXCIpXCIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHVzZXIgZnJvbSB0aGUgY29sbGVjdGlvbiBieSBlbWFpbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbWFpbCBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlciB0byByZXRyaWV2ZVxyXG4gICAgICovXHJcbiAgICBTaXRlVXNlcnMucHJvdG90eXBlLmdldEJ5RW1haWwgPSBmdW5jdGlvbiAoZW1haWwpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNpdGVVc2VyKHRoaXMsIFwiZ2V0QnlFbWFpbCgnXCIgKyBlbWFpbCArIFwiJylcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgdXNlciBmcm9tIHRoZSBjb2xsZWN0aW9uIGJ5IGxvZ2luIG5hbWVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9naW5OYW1lIFRoZSBsb2dpbiBuYW1lIG9mIHRoZSB1c2VyIHRvIHJldHJpZXZlXHJcbiAgICAgKi9cclxuICAgIFNpdGVVc2Vycy5wcm90b3R5cGUuZ2V0QnlMb2dpbk5hbWUgPSBmdW5jdGlvbiAobG9naW5OYW1lKSB7XHJcbiAgICAgICAgdmFyIHN1ID0gbmV3IFNpdGVVc2VyKHRoaXMpO1xyXG4gICAgICAgIHN1LmNvbmNhdChcIignIUB2OjpcIiArIGVuY29kZVVSSUNvbXBvbmVudChsb2dpbk5hbWUpICsgXCInKVwiKTtcclxuICAgICAgICByZXR1cm4gc3U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgdXNlciBmcm9tIHRoZSBjb2xsZWN0aW9uIGJ5IGlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgdXNlciB0byByZW1vdmVcclxuICAgICAqL1xyXG4gICAgU2l0ZVVzZXJzLnByb3RvdHlwZS5yZW1vdmVCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2l0ZVVzZXJzXzEsIFwicmVtb3ZlQnlJZChcIiArIGlkICsgXCIpXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgdXNlciBmcm9tIHRoZSBjb2xsZWN0aW9uIGJ5IGxvZ2luIG5hbWVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9naW5OYW1lIFRoZSBsb2dpbiBuYW1lIG9mIHRoZSB1c2VyIHRvIHJlbW92ZVxyXG4gICAgICovXHJcbiAgICBTaXRlVXNlcnMucHJvdG90eXBlLnJlbW92ZUJ5TG9naW5OYW1lID0gZnVuY3Rpb24gKGxvZ2luTmFtZSkge1xyXG4gICAgICAgIHZhciBvID0gdGhpcy5jbG9uZShTaXRlVXNlcnNfMSwgXCJyZW1vdmVCeUxvZ2luTmFtZShAdilcIik7XHJcbiAgICAgICAgby5xdWVyeS5zZXQoXCJAdlwiLCBcIidcIiArIGVuY29kZVVSSUNvbXBvbmVudChsb2dpbk5hbWUpICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiBvLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgdXNlciB0byBhIGdyb3VwXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvZ2luTmFtZSBUaGUgbG9naW4gbmFtZSBvZiB0aGUgdXNlciB0byBhZGQgdG8gdGhlIGdyb3VwXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBTaXRlVXNlcnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChsb2dpbk5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNpdGVVc2Vyc18xLCBudWxsKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyhleHRlbmQobWV0YWRhdGEoXCJTUC5Vc2VyXCIpLCB7IExvZ2luTmFtZTogbG9naW5OYW1lIH0pKSxcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdldEJ5TG9naW5OYW1lKGxvZ2luTmFtZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBTaXRlVXNlcnNfMTtcclxuICAgIFNpdGVVc2VycyA9IFNpdGVVc2Vyc18xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJzaXRldXNlcnNcIilcclxuICAgIF0sIFNpdGVVc2Vycyk7XHJcbiAgICByZXR1cm4gU2l0ZVVzZXJzO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgdXNlclxyXG4gKlxyXG4gKi9cclxudmFyIFNpdGVVc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNpdGVVc2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2l0ZVVzZXIoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBVcGRhdGVzIHRoaXMgdXNlciBpbnN0YW5jZSB3aXRoIHRoZSBzdXBwbGllZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogQHBhcmFtIHByb3BlcnRpZXMgQSBwbGFpbiBvYmplY3Qgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcyB0byB1cGRhdGUgZm9yIHRoZSB1c2VyXHJcbiAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy51cGRhdGUgPSBfdGhpcy5fdXBkYXRlKFwiU1AuVXNlclwiLCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKHsgZGF0YTogZGF0YSwgdXNlcjogX3RoaXMgfSk7IH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZSB0aGlzIHVzZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmRlbGV0ZSA9IF90aGlzLl9kZWxldGU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpdGVVc2VyLnByb3RvdHlwZSwgXCJncm91cHNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGdyb3VwcyBmb3IgdGhpcyB1c2VyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaXRlR3JvdXBzKHRoaXMsIFwiZ3JvdXBzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFNpdGVVc2VyO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgY3VycmVudCB1c2VyXHJcbiAqL1xyXG52YXIgQ3VycmVudFVzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ3VycmVudFVzZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDdXJyZW50VXNlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBDdXJyZW50VXNlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwiY3VycmVudHVzZXJcIilcclxuICAgIF0sIEN1cnJlbnRVc2VyKTtcclxuICAgIHJldHVybiBDdXJyZW50VXNlcjtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UpKTtcblxuLyoqXHJcbiAqIFByaW5jaXBhbCBUeXBlIGVudW1cclxuICpcclxuICovXHJcbnZhciBQcmluY2lwYWxUeXBlO1xyXG4oZnVuY3Rpb24gKFByaW5jaXBhbFR5cGUpIHtcclxuICAgIFByaW5jaXBhbFR5cGVbUHJpbmNpcGFsVHlwZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgUHJpbmNpcGFsVHlwZVtQcmluY2lwYWxUeXBlW1wiVXNlclwiXSA9IDFdID0gXCJVc2VyXCI7XHJcbiAgICBQcmluY2lwYWxUeXBlW1ByaW5jaXBhbFR5cGVbXCJEaXN0cmlidXRpb25MaXN0XCJdID0gMl0gPSBcIkRpc3RyaWJ1dGlvbkxpc3RcIjtcclxuICAgIFByaW5jaXBhbFR5cGVbUHJpbmNpcGFsVHlwZVtcIlNlY3VyaXR5R3JvdXBcIl0gPSA0XSA9IFwiU2VjdXJpdHlHcm91cFwiO1xyXG4gICAgUHJpbmNpcGFsVHlwZVtQcmluY2lwYWxUeXBlW1wiU2hhcmVQb2ludEdyb3VwXCJdID0gOF0gPSBcIlNoYXJlUG9pbnRHcm91cFwiO1xyXG4gICAgUHJpbmNpcGFsVHlwZVtQcmluY2lwYWxUeXBlW1wiQWxsXCJdID0gMTVdID0gXCJBbGxcIjtcclxufSkoUHJpbmNpcGFsVHlwZSB8fCAoUHJpbmNpcGFsVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBjb2xsZWN0aW9uIG9mIHNpdGUgZ3JvdXBzXHJcbiAqXHJcbiAqL1xyXG52YXIgU2l0ZUdyb3VwcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaXRlR3JvdXBzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2l0ZUdyb3VwcygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBTaXRlR3JvdXBzXzEgPSBTaXRlR3JvdXBzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgZ3JvdXAgZnJvbSB0aGUgY29sbGVjdGlvbiBieSBpZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGdyb3VwIHRvIHJldHJpZXZlXHJcbiAgICAgKi9cclxuICAgIFNpdGVHcm91cHMucHJvdG90eXBlLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgc2cgPSBuZXcgU2l0ZUdyb3VwKHRoaXMpO1xyXG4gICAgICAgIHNnLmNvbmNhdChcIihcIiArIGlkICsgXCIpXCIpO1xyXG4gICAgICAgIHJldHVybiBzZztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgZ3JvdXAgdG8gdGhlIHNpdGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9wcyBUaGUgZ3JvdXAgcHJvcGVydGllcyBvYmplY3Qgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcyB0byBiZSBzZXQgZm9yIHRoZSBncm91cFxyXG4gICAgICovXHJcbiAgICBTaXRlR3JvdXBzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKGV4dGVuZChtZXRhZGF0YShcIlNQLkdyb3VwXCIpLCBwcm9wZXJ0aWVzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdENvcmUoeyBib2R5OiBwb3N0Qm9keSB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IF90aGlzLmdldEJ5SWQoZGF0YS5JZCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgZ3JvdXAgZnJvbSB0aGUgY29sbGVjdGlvbiBieSBuYW1lXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdyb3VwTmFtZSBUaGUgbmFtZSBvZiB0aGUgZ3JvdXAgdG8gcmV0cmlldmVcclxuICAgICAqL1xyXG4gICAgU2l0ZUdyb3Vwcy5wcm90b3R5cGUuZ2V0QnlOYW1lID0gZnVuY3Rpb24gKGdyb3VwTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2l0ZUdyb3VwKHRoaXMsIFwiZ2V0QnlOYW1lKCdcIiArIGdyb3VwTmFtZSArIFwiJylcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBncm91cCB3aXRoIHRoZSBzcGVjaWZpZWQgbWVtYmVyIGlkIGZyb20gdGhlIGNvbGxlY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBncm91cCB0byByZW1vdmVcclxuICAgICAqL1xyXG4gICAgU2l0ZUdyb3Vwcy5wcm90b3R5cGUucmVtb3ZlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNpdGVHcm91cHNfMSwgXCJyZW1vdmVCeUlkKCdcIiArIGlkICsgXCInKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgY3Jvc3Mtc2l0ZSBncm91cCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBmcm9tIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvZ2luTmFtZSBUaGUgbmFtZSBvZiB0aGUgZ3JvdXAgdG8gcmVtb3ZlXHJcbiAgICAgKi9cclxuICAgIFNpdGVHcm91cHMucHJvdG90eXBlLnJlbW92ZUJ5TG9naW5OYW1lID0gZnVuY3Rpb24gKGxvZ2luTmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNpdGVHcm91cHNfMSwgXCJyZW1vdmVCeUxvZ2luTmFtZSgnXCIgKyBsb2dpbk5hbWUgKyBcIicpXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIFNpdGVHcm91cHNfMTtcclxuICAgIFNpdGVHcm91cHMgPSBTaXRlR3JvdXBzXzEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcInNpdGVncm91cHNcIilcclxuICAgIF0sIFNpdGVHcm91cHMpO1xyXG4gICAgcmV0dXJuIFNpdGVHcm91cHM7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIHNpbmdsZSBncm91cFxyXG4gKlxyXG4gKi9cclxudmFyIFNpdGVHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaXRlR3JvdXAsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTaXRlR3JvdXAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudXBkYXRlID0gX3RoaXMuX3VwZGF0ZShcIlNQLkdyb3VwXCIsIGZ1bmN0aW9uIChkLCBwKSB7XHJcbiAgICAgICAgICAgIHZhciByZXRHcm91cCA9IF90aGlzO1xyXG4gICAgICAgICAgICBpZiAoaE9QKHAsIFwiVGl0bGVcIikpIHtcclxuICAgICAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1zdHJpbmctbGl0ZXJhbCAqL1xyXG4gICAgICAgICAgICAgICAgcmV0R3JvdXAgPSBfdGhpcy5nZXRQYXJlbnQoU2l0ZUdyb3VwLCBfdGhpcy5wYXJlbnRVcmwsIFwiZ2V0QnlOYW1lKCdcIiArIHBbXCJUaXRsZVwiXSArIFwiJylcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGQsXHJcbiAgICAgICAgICAgICAgICBncm91cDogcmV0R3JvdXAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpdGVHcm91cC5wcm90b3R5cGUsIFwidXNlcnNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHVzZXJzIGZvciB0aGlzIGdyb3VwXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaXRlVXNlcnModGhpcywgXCJ1c2Vyc1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBTaXRlR3JvdXA7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XG5cbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzZXQgb2Ygcm9sZSBhc3NpZ25tZW50cyBmb3IgdGhlIGN1cnJlbnQgc2NvcGVcclxuICpcclxuICovXHJcbnZhciBSb2xlQXNzaWdubWVudHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUm9sZUFzc2lnbm1lbnRzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUm9sZUFzc2lnbm1lbnRzKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFJvbGVBc3NpZ25tZW50c18xID0gUm9sZUFzc2lnbm1lbnRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByb2xlIGFzc2lnbm1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgcHJpbmNpcGFsIGlkIGZyb20gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgcm9sZSBhc3NpZ25tZW50XHJcbiAgICAgKi9cclxuICAgIFJvbGVBc3NpZ25tZW50cy5wcm90b3R5cGUuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciByYSA9IG5ldyBSb2xlQXNzaWdubWVudCh0aGlzKTtcclxuICAgICAgICByYS5jb25jYXQoXCIoXCIgKyBpZCArIFwiKVwiKTtcclxuICAgICAgICByZXR1cm4gcmE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IHJvbGUgYXNzaWdubWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgcHJpbmNpcGFsIGFuZCByb2xlIGRlZmluaXRpb25zIHRvIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByaW5jaXBhbElkIFRoZSBpZCBvZiB0aGUgdXNlciBvciBncm91cCB0byBhc3NpZ24gcGVybWlzc2lvbnMgdG9cclxuICAgICAqIEBwYXJhbSByb2xlRGVmSWQgVGhlIGlkIG9mIHRoZSByb2xlIGRlZmluaXRpb24gdGhhdCBkZWZpbmVzIHRoZSBwZXJtaXNzaW9ucyB0byBhc3NpZ25cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFJvbGVBc3NpZ25tZW50cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHByaW5jaXBhbElkLCByb2xlRGVmSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShSb2xlQXNzaWdubWVudHNfMSwgXCJhZGRyb2xlYXNzaWdubWVudChwcmluY2lwYWxpZD1cIiArIHByaW5jaXBhbElkICsgXCIsIHJvbGVkZWZpZD1cIiArIHJvbGVEZWZJZCArIFwiKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgcm9sZSBhc3NpZ25tZW50IHdpdGggdGhlIHNwZWNpZmllZCBwcmluY2lwYWwgYW5kIHJvbGUgZGVmaW5pdGlvbiBmcm9tIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByaW5jaXBhbElkIFRoZSBpZCBvZiB0aGUgdXNlciBvciBncm91cCBpbiB0aGUgcm9sZSBhc3NpZ25tZW50XHJcbiAgICAgKiBAcGFyYW0gcm9sZURlZklkIFRoZSBpZCBvZiB0aGUgcm9sZSBkZWZpbml0aW9uIGluIHRoZSByb2xlIGFzc2lnbm1lbnRcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFJvbGVBc3NpZ25tZW50cy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHByaW5jaXBhbElkLCByb2xlRGVmSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShSb2xlQXNzaWdubWVudHNfMSwgXCJyZW1vdmVyb2xlYXNzaWdubWVudChwcmluY2lwYWxpZD1cIiArIHByaW5jaXBhbElkICsgXCIsIHJvbGVkZWZpZD1cIiArIHJvbGVEZWZJZCArIFwiKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIHZhciBSb2xlQXNzaWdubWVudHNfMTtcclxuICAgIFJvbGVBc3NpZ25tZW50cyA9IFJvbGVBc3NpZ25tZW50c18xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJyb2xlYXNzaWdubWVudHNcIilcclxuICAgIF0sIFJvbGVBc3NpZ25tZW50cyk7XHJcbiAgICByZXR1cm4gUm9sZUFzc2lnbm1lbnRzO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSByb2xlIGFzc2lnbm1lbnRcclxuICpcclxuICovXHJcbnZhciBSb2xlQXNzaWdubWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSb2xlQXNzaWdubWVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJvbGVBc3NpZ25tZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZXMgdGhpcyByb2xlIGFzc2lnbm1lbnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmRlbGV0ZSA9IF90aGlzLl9kZWxldGU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvbGVBc3NpZ25tZW50LnByb3RvdHlwZSwgXCJncm91cHNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGdyb3VwcyB0aGF0IGRpcmVjdGx5IGJlbG9uZyB0byB0aGUgYWNjZXNzIGNvbnRyb2wgbGlzdCAoQUNMKSBmb3IgdGhpcyBzZWN1cmFibGUgb2JqZWN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaXRlR3JvdXBzKHRoaXMsIFwiZ3JvdXBzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvbGVBc3NpZ25tZW50LnByb3RvdHlwZSwgXCJiaW5kaW5nc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgcm9sZSBkZWZpbml0aW9uIGJpbmRpbmdzIGZvciB0aGlzIHJvbGUgYXNzaWdubWVudFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUm9sZURlZmluaXRpb25CaW5kaW5ncyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBSb2xlQXNzaWdubWVudDtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UpKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIGNvbGxlY3Rpb24gb2Ygcm9sZSBkZWZpbml0aW9uc1xyXG4gKlxyXG4gKi9cclxudmFyIFJvbGVEZWZpbml0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSb2xlRGVmaW5pdGlvbnMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSb2xlRGVmaW5pdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByb2xlIGRlZmluaXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGlkIGZyb20gdGhlIGNvbGxlY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSByb2xlIGRlZmluaXRpb25cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFJvbGVEZWZpbml0aW9ucy5wcm90b3R5cGUuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUm9sZURlZmluaXRpb24odGhpcywgXCJnZXRCeUlkKFwiICsgaWQgKyBcIilcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByb2xlIGRlZmluaXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcm9sZSBkZWZpbml0aW9uXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBSb2xlRGVmaW5pdGlvbnMucHJvdG90eXBlLmdldEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSb2xlRGVmaW5pdGlvbih0aGlzLCBcImdldGJ5bmFtZSgnXCIgKyBuYW1lICsgXCInKVwiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJvbGUgZGVmaW5pdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgcm9sZSB0eXBlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJvbGVUeXBlS2luZCBUaGUgcm9sZXR5cGVraW5kIG9mIHRoZSByb2xlIGRlZmluaXRpb24gKE5vbmU9MCwgR3Vlc3Q9MSwgUmVhZGVyPTIsIENvbnRyaWJ1dG9yPTMsIFdlYkRlc2lnbmVyPTQsIEFkbWluaXN0cmF0b3I9NSwgRWRpdG9yPTYsIFN5c3RlbT03KVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgUm9sZURlZmluaXRpb25zLnByb3RvdHlwZS5nZXRCeVR5cGUgPSBmdW5jdGlvbiAocm9sZVR5cGVLaW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSb2xlRGVmaW5pdGlvbih0aGlzLCBcImdldGJ5dHlwZShcIiArIHJvbGVUeXBlS2luZCArIFwiKVwiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByb2xlIGRlZmluaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmV3IHJvbGUgZGVmaW5pdGlvbidzIG5hbWVcclxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBUaGUgbmV3IHJvbGUgZGVmaW5pdGlvbidzIGRlc2NyaXB0aW9uXHJcbiAgICAgKiBAcGFyYW0gb3JkZXIgVGhlIG9yZGVyIGluIHdoaWNoIHRoZSByb2xlIGRlZmluaXRpb24gYXBwZWFyc1xyXG4gICAgICogQHBhcmFtIGJhc2VQZXJtaXNzaW9ucyBUaGUgcGVybWlzc2lvbnMgbWFzayBmb3IgdGhpcyByb2xlIGRlZmluaXRpb25cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFJvbGVEZWZpbml0aW9ucy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIGRlc2NyaXB0aW9uLCBvcmRlciwgYmFzZVBlcm1pc3Npb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcG9zdEJvZHkgPSBqc1Moe1xyXG4gICAgICAgICAgICBCYXNlUGVybWlzc2lvbnM6IGV4dGVuZCh7IF9fbWV0YWRhdGE6IHsgdHlwZTogXCJTUC5CYXNlUGVybWlzc2lvbnNcIiB9IH0sIGJhc2VQZXJtaXNzaW9ucyksXHJcbiAgICAgICAgICAgIERlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgTmFtZTogbmFtZSxcclxuICAgICAgICAgICAgT3JkZXI6IG9yZGVyLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhOiB7IFwidHlwZVwiOiBcIlNQLlJvbGVEZWZpbml0aW9uXCIgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3N0Q29yZSh7IGJvZHk6IHBvc3RCb2R5IH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBfdGhpcy5nZXRCeUlkKGRhdGEuSWQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFJvbGVEZWZpbml0aW9ucyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwicm9sZWRlZmluaXRpb25zXCIpXHJcbiAgICBdLCBSb2xlRGVmaW5pdGlvbnMpO1xyXG4gICAgcmV0dXJuIFJvbGVEZWZpbml0aW9ucztcclxufShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbikpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIGEgcm9sZSBkZWZpbml0aW9uXHJcbiAqXHJcbiAqL1xyXG52YXIgUm9sZURlZmluaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUm9sZURlZmluaXRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSb2xlRGVmaW5pdGlvbigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWxldGVzIHRoaXMgcm9sZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5kZWxldGUgPSBfdGhpcy5fZGVsZXRlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlICovXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhpcyByb2xlIGRlZmluaXRpb24gd2l0aCB0aGUgc3VwcGxpZWQgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIEEgcGxhaW4gb2JqZWN0IGhhc2ggb2YgdmFsdWVzIHRvIHVwZGF0ZSBmb3IgdGhlIHJvbGUgZGVmaW5pdGlvblxyXG4gICAgICovXHJcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZSBuby1zdHJpbmctbGl0ZXJhbCAqL1xyXG4gICAgUm9sZURlZmluaXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcyA9IFtcIkJhc2VQZXJtaXNzaW9uc1wiXTtcclxuICAgICAgICBpZiAoaE9QKHByb3BlcnRpZXMsIHNbMF0pICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcHJvcGVydGllc1tzWzBdXSA9IGV4dGVuZCh7IF9fbWV0YWRhdGE6IHsgdHlwZTogXCJTUC5cIiArIHNbMF0gfSB9LCBwcm9wZXJ0aWVzW3NbMF1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKGV4dGVuZChtZXRhZGF0YShcIlNQLlJvbGVEZWZpbml0aW9uXCIpLCBwcm9wZXJ0aWVzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBwb3N0Qm9keSxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgXCJYLUhUVFAtTWV0aG9kXCI6IFwiTUVSR0VcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciByZXREZWYgPSBfdGhpcztcclxuICAgICAgICAgICAgaWYgKGhPUChwcm9wZXJ0aWVzLCBcIk5hbWVcIikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IF90aGlzLmdldFBhcmVudChSb2xlRGVmaW5pdGlvbnMsIF90aGlzLnBhcmVudFVybCwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICByZXREZWYgPSBwYXJlbnRfMS5nZXRCeU5hbWUocHJvcGVydGllc1tcIk5hbWVcIl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogcmV0RGVmLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSb2xlRGVmaW5pdGlvbjtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UpKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aGUgcm9sZSBkZWZpbml0b25zIGJvdW5kIHRvIGEgcm9sZSBhc3NpZ25tZW50IG9iamVjdFxyXG4gKlxyXG4gKi9cclxudmFyIFJvbGVEZWZpbml0aW9uQmluZGluZ3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUm9sZURlZmluaXRpb25CaW5kaW5ncywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJvbGVEZWZpbml0aW9uQmluZGluZ3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUm9sZURlZmluaXRpb25CaW5kaW5ncyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwicm9sZWRlZmluaXRpb25iaW5kaW5nc1wiKVxyXG4gICAgXSwgUm9sZURlZmluaXRpb25CaW5kaW5ncyk7XHJcbiAgICByZXR1cm4gUm9sZURlZmluaXRpb25CaW5kaW5ncztcclxufShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbikpO1xuXG4vKipcclxuICogRGV0ZXJtaW5lcyB0aGUgZGlzcGxheSBtb2RlIG9mIHRoZSBnaXZlbiBjb250cm9sIG9yIHZpZXdcclxuICovXHJcbnZhciBDb250cm9sTW9kZTtcclxuKGZ1bmN0aW9uIChDb250cm9sTW9kZSkge1xyXG4gICAgQ29udHJvbE1vZGVbQ29udHJvbE1vZGVbXCJEaXNwbGF5XCJdID0gMV0gPSBcIkRpc3BsYXlcIjtcclxuICAgIENvbnRyb2xNb2RlW0NvbnRyb2xNb2RlW1wiRWRpdFwiXSA9IDJdID0gXCJFZGl0XCI7XHJcbiAgICBDb250cm9sTW9kZVtDb250cm9sTW9kZVtcIk5ld1wiXSA9IDNdID0gXCJOZXdcIjtcclxufSkoQ29udHJvbE1vZGUgfHwgKENvbnRyb2xNb2RlID0ge30pKTtcclxuLyoqXHJcbiAqIFNwZWNpZmllcyB0aGUgdHlwZSBvZiB0aGUgZmllbGQuXHJcbiAqL1xyXG52YXIgRmllbGRUeXBlcztcclxuKGZ1bmN0aW9uIChGaWVsZFR5cGVzKSB7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJJbnZhbGlkXCJdID0gMF0gPSBcIkludmFsaWRcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIkludGVnZXJcIl0gPSAxXSA9IFwiSW50ZWdlclwiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiVGV4dFwiXSA9IDJdID0gXCJUZXh0XCI7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJOb3RlXCJdID0gM10gPSBcIk5vdGVcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIkRhdGVUaW1lXCJdID0gNF0gPSBcIkRhdGVUaW1lXCI7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJDb3VudGVyXCJdID0gNV0gPSBcIkNvdW50ZXJcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIkNob2ljZVwiXSA9IDZdID0gXCJDaG9pY2VcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIkxvb2t1cFwiXSA9IDddID0gXCJMb29rdXBcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIkJvb2xlYW5cIl0gPSA4XSA9IFwiQm9vbGVhblwiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiTnVtYmVyXCJdID0gOV0gPSBcIk51bWJlclwiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiQ3VycmVuY3lcIl0gPSAxMF0gPSBcIkN1cnJlbmN5XCI7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJVUkxcIl0gPSAxMV0gPSBcIlVSTFwiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiQ29tcHV0ZWRcIl0gPSAxMl0gPSBcIkNvbXB1dGVkXCI7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJUaHJlYWRpbmdcIl0gPSAxM10gPSBcIlRocmVhZGluZ1wiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiR3VpZFwiXSA9IDE0XSA9IFwiR3VpZFwiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiTXVsdGlDaG9pY2VcIl0gPSAxNV0gPSBcIk11bHRpQ2hvaWNlXCI7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJHcmlkQ2hvaWNlXCJdID0gMTZdID0gXCJHcmlkQ2hvaWNlXCI7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJDYWxjdWxhdGVkXCJdID0gMTddID0gXCJDYWxjdWxhdGVkXCI7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJGaWxlXCJdID0gMThdID0gXCJGaWxlXCI7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJBdHRhY2htZW50c1wiXSA9IDE5XSA9IFwiQXR0YWNobWVudHNcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIlVzZXJcIl0gPSAyMF0gPSBcIlVzZXJcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIlJlY3VycmVuY2VcIl0gPSAyMV0gPSBcIlJlY3VycmVuY2VcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIkNyb3NzUHJvamVjdExpbmtcIl0gPSAyMl0gPSBcIkNyb3NzUHJvamVjdExpbmtcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIk1vZFN0YXRcIl0gPSAyM10gPSBcIk1vZFN0YXRcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIkVycm9yXCJdID0gMjRdID0gXCJFcnJvclwiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiQ29udGVudFR5cGVJZFwiXSA9IDI1XSA9IFwiQ29udGVudFR5cGVJZFwiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiUGFnZVNlcGFyYXRvclwiXSA9IDI2XSA9IFwiUGFnZVNlcGFyYXRvclwiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiVGhyZWFkSW5kZXhcIl0gPSAyN10gPSBcIlRocmVhZEluZGV4XCI7XHJcbiAgICBGaWVsZFR5cGVzW0ZpZWxkVHlwZXNbXCJXb3JrZmxvd1N0YXR1c1wiXSA9IDI4XSA9IFwiV29ya2Zsb3dTdGF0dXNcIjtcclxuICAgIEZpZWxkVHlwZXNbRmllbGRUeXBlc1tcIkFsbERheUV2ZW50XCJdID0gMjldID0gXCJBbGxEYXlFdmVudFwiO1xyXG4gICAgRmllbGRUeXBlc1tGaWVsZFR5cGVzW1wiV29ya2Zsb3dFdmVudFR5cGVcIl0gPSAzMF0gPSBcIldvcmtmbG93RXZlbnRUeXBlXCI7XHJcbn0pKEZpZWxkVHlwZXMgfHwgKEZpZWxkVHlwZXMgPSB7fSkpO1xyXG52YXIgRGF0ZVRpbWVGaWVsZEZvcm1hdFR5cGU7XHJcbihmdW5jdGlvbiAoRGF0ZVRpbWVGaWVsZEZvcm1hdFR5cGUpIHtcclxuICAgIERhdGVUaW1lRmllbGRGb3JtYXRUeXBlW0RhdGVUaW1lRmllbGRGb3JtYXRUeXBlW1wiRGF0ZU9ubHlcIl0gPSAwXSA9IFwiRGF0ZU9ubHlcIjtcclxuICAgIERhdGVUaW1lRmllbGRGb3JtYXRUeXBlW0RhdGVUaW1lRmllbGRGb3JtYXRUeXBlW1wiRGF0ZVRpbWVcIl0gPSAxXSA9IFwiRGF0ZVRpbWVcIjtcclxufSkoRGF0ZVRpbWVGaWVsZEZvcm1hdFR5cGUgfHwgKERhdGVUaW1lRmllbGRGb3JtYXRUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIFNwZWNpZmllcyB0aGUgY29udHJvbCBzZXR0aW5ncyB3aGlsZSBhZGRpbmcgYSBmaWVsZC5cclxuICovXHJcbnZhciBBZGRGaWVsZE9wdGlvbnM7XHJcbihmdW5jdGlvbiAoQWRkRmllbGRPcHRpb25zKSB7XHJcbiAgICAvKipcclxuICAgICAqICBTcGVjaWZ5IHRoYXQgYSBuZXcgZmllbGQgYWRkZWQgdG8gdGhlIGxpc3QgbXVzdCBhbHNvIGJlIGFkZGVkIHRvIHRoZSBkZWZhdWx0IGNvbnRlbnQgdHlwZSBpbiB0aGUgc2l0ZSBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIEFkZEZpZWxkT3B0aW9uc1tBZGRGaWVsZE9wdGlvbnNbXCJEZWZhdWx0VmFsdWVcIl0gPSAwXSA9IFwiRGVmYXVsdFZhbHVlXCI7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgdGhhdCBhIG5ldyBmaWVsZCBhZGRlZCB0byB0aGUgbGlzdCBtdXN0IGFsc28gYmUgYWRkZWQgdG8gdGhlIGRlZmF1bHQgY29udGVudCB0eXBlIGluIHRoZSBzaXRlIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIEFkZEZpZWxkT3B0aW9uc1tBZGRGaWVsZE9wdGlvbnNbXCJBZGRUb0RlZmF1bHRDb250ZW50VHlwZVwiXSA9IDFdID0gXCJBZGRUb0RlZmF1bHRDb250ZW50VHlwZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IHRoYXQgYSBuZXcgZmllbGQgbXVzdCBub3QgYmUgYWRkZWQgdG8gYW55IG90aGVyIGNvbnRlbnQgdHlwZVxyXG4gICAgICovXHJcbiAgICBBZGRGaWVsZE9wdGlvbnNbQWRkRmllbGRPcHRpb25zW1wiQWRkVG9Ob0NvbnRlbnRUeXBlXCJdID0gMl0gPSBcIkFkZFRvTm9Db250ZW50VHlwZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgU3BlY2lmeSB0aGF0IGEgbmV3IGZpZWxkIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHNwZWNpZmllZCBsaXN0IG11c3QgYWxzbyBiZSBhZGRlZCB0byBhbGwgY29udGVudCB0eXBlcyBpbiB0aGUgc2l0ZSBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIEFkZEZpZWxkT3B0aW9uc1tBZGRGaWVsZE9wdGlvbnNbXCJBZGRUb0FsbENvbnRlbnRUeXBlc1wiXSA9IDRdID0gXCJBZGRUb0FsbENvbnRlbnRUeXBlc1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IGFkZGluZyBhbiBpbnRlcm5hbCBmaWVsZCBuYW1lIGhpbnQgZm9yIHRoZSBwdXJwb3NlIG9mIGF2b2lkaW5nIHBvc3NpYmxlIGRhdGFiYXNlIGxvY2tpbmcgb3IgZmllbGQgcmVuYW1pbmcgb3BlcmF0aW9uc1xyXG4gICAgICovXHJcbiAgICBBZGRGaWVsZE9wdGlvbnNbQWRkRmllbGRPcHRpb25zW1wiQWRkRmllbGRJbnRlcm5hbE5hbWVIaW50XCJdID0gOF0gPSBcIkFkZEZpZWxkSW50ZXJuYWxOYW1lSGludFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IHRoYXQgYSBuZXcgZmllbGQgdGhhdCBpcyBhZGRlZCB0byB0aGUgc3BlY2lmaWVkIGxpc3QgbXVzdCBhbHNvIGJlIGFkZGVkIHRvIHRoZSBkZWZhdWx0IGxpc3Qgdmlld1xyXG4gICAgICovXHJcbiAgICBBZGRGaWVsZE9wdGlvbnNbQWRkRmllbGRPcHRpb25zW1wiQWRkRmllbGRUb0RlZmF1bHRWaWV3XCJdID0gMTZdID0gXCJBZGRGaWVsZFRvRGVmYXVsdFZpZXdcIjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSB0byBjb25maXJtIHRoYXQgbm8gb3RoZXIgZmllbGQgaGFzIHRoZSBzYW1lIGRpc3BsYXkgbmFtZVxyXG4gICAgICovXHJcbiAgICBBZGRGaWVsZE9wdGlvbnNbQWRkRmllbGRPcHRpb25zW1wiQWRkRmllbGRDaGVja0Rpc3BsYXlOYW1lXCJdID0gMzJdID0gXCJBZGRGaWVsZENoZWNrRGlzcGxheU5hbWVcIjtcclxufSkoQWRkRmllbGRPcHRpb25zIHx8IChBZGRGaWVsZE9wdGlvbnMgPSB7fSkpO1xyXG52YXIgQ2FsZW5kYXJUeXBlO1xyXG4oZnVuY3Rpb24gKENhbGVuZGFyVHlwZSkge1xyXG4gICAgQ2FsZW5kYXJUeXBlW0NhbGVuZGFyVHlwZVtcIkdyZWdvcmlhblwiXSA9IDFdID0gXCJHcmVnb3JpYW5cIjtcclxuICAgIENhbGVuZGFyVHlwZVtDYWxlbmRhclR5cGVbXCJKYXBhblwiXSA9IDNdID0gXCJKYXBhblwiO1xyXG4gICAgQ2FsZW5kYXJUeXBlW0NhbGVuZGFyVHlwZVtcIlRhaXdhblwiXSA9IDRdID0gXCJUYWl3YW5cIjtcclxuICAgIENhbGVuZGFyVHlwZVtDYWxlbmRhclR5cGVbXCJLb3JlYVwiXSA9IDVdID0gXCJLb3JlYVwiO1xyXG4gICAgQ2FsZW5kYXJUeXBlW0NhbGVuZGFyVHlwZVtcIkhpanJpXCJdID0gNl0gPSBcIkhpanJpXCI7XHJcbiAgICBDYWxlbmRhclR5cGVbQ2FsZW5kYXJUeXBlW1wiVGhhaVwiXSA9IDddID0gXCJUaGFpXCI7XHJcbiAgICBDYWxlbmRhclR5cGVbQ2FsZW5kYXJUeXBlW1wiSGVicmV3XCJdID0gOF0gPSBcIkhlYnJld1wiO1xyXG4gICAgQ2FsZW5kYXJUeXBlW0NhbGVuZGFyVHlwZVtcIkdyZWdvcmlhbk1FRnJlbmNoXCJdID0gOV0gPSBcIkdyZWdvcmlhbk1FRnJlbmNoXCI7XHJcbiAgICBDYWxlbmRhclR5cGVbQ2FsZW5kYXJUeXBlW1wiR3JlZ29yaWFuQXJhYmljXCJdID0gMTBdID0gXCJHcmVnb3JpYW5BcmFiaWNcIjtcclxuICAgIENhbGVuZGFyVHlwZVtDYWxlbmRhclR5cGVbXCJHcmVnb3JpYW5YTElURW5nbGlzaFwiXSA9IDExXSA9IFwiR3JlZ29yaWFuWExJVEVuZ2xpc2hcIjtcclxuICAgIENhbGVuZGFyVHlwZVtDYWxlbmRhclR5cGVbXCJHcmVnb3JpYW5YTElURnJlbmNoXCJdID0gMTJdID0gXCJHcmVnb3JpYW5YTElURnJlbmNoXCI7XHJcbiAgICBDYWxlbmRhclR5cGVbQ2FsZW5kYXJUeXBlW1wiS29yZWFKYXBhbkx1bmFyXCJdID0gMTRdID0gXCJLb3JlYUphcGFuTHVuYXJcIjtcclxuICAgIENhbGVuZGFyVHlwZVtDYWxlbmRhclR5cGVbXCJDaGluZXNlTHVuYXJcIl0gPSAxNV0gPSBcIkNoaW5lc2VMdW5hclwiO1xyXG4gICAgQ2FsZW5kYXJUeXBlW0NhbGVuZGFyVHlwZVtcIlNha2FFcmFcIl0gPSAxNl0gPSBcIlNha2FFcmFcIjtcclxuICAgIENhbGVuZGFyVHlwZVtDYWxlbmRhclR5cGVbXCJVbUFsUXVyYVwiXSA9IDIzXSA9IFwiVW1BbFF1cmFcIjtcclxufSkoQ2FsZW5kYXJUeXBlIHx8IChDYWxlbmRhclR5cGUgPSB7fSkpO1xyXG52YXIgVXJsRmllbGRGb3JtYXRUeXBlO1xyXG4oZnVuY3Rpb24gKFVybEZpZWxkRm9ybWF0VHlwZSkge1xyXG4gICAgVXJsRmllbGRGb3JtYXRUeXBlW1VybEZpZWxkRm9ybWF0VHlwZVtcIkh5cGVybGlua1wiXSA9IDBdID0gXCJIeXBlcmxpbmtcIjtcclxuICAgIFVybEZpZWxkRm9ybWF0VHlwZVtVcmxGaWVsZEZvcm1hdFR5cGVbXCJJbWFnZVwiXSA9IDFdID0gXCJJbWFnZVwiO1xyXG59KShVcmxGaWVsZEZvcm1hdFR5cGUgfHwgKFVybEZpZWxkRm9ybWF0VHlwZSA9IHt9KSk7XHJcbnZhciBQZXJtaXNzaW9uS2luZDtcclxuKGZ1bmN0aW9uIChQZXJtaXNzaW9uS2luZCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYXMgbm8gcGVybWlzc2lvbnMgb24gdGhlIFNpdGUuIE5vdCBhdmFpbGFibGUgdGhyb3VnaCB0aGUgdXNlciBpbnRlcmZhY2UuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiRW1wdHlNYXNrXCJdID0gMF0gPSBcIkVtcHR5TWFza1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWaWV3IGl0ZW1zIGluIGxpc3RzLCBkb2N1bWVudHMgaW4gZG9jdW1lbnQgbGlicmFyaWVzLCBhbmQgV2ViIGRpc2N1c3Npb24gY29tbWVudHMuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiVmlld0xpc3RJdGVtc1wiXSA9IDFdID0gXCJWaWV3TGlzdEl0ZW1zXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBpdGVtcyB0byBsaXN0cywgZG9jdW1lbnRzIHRvIGRvY3VtZW50IGxpYnJhcmllcywgYW5kIFdlYiBkaXNjdXNzaW9uIGNvbW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkFkZExpc3RJdGVtc1wiXSA9IDJdID0gXCJBZGRMaXN0SXRlbXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogRWRpdCBpdGVtcyBpbiBsaXN0cywgZWRpdCBkb2N1bWVudHMgaW4gZG9jdW1lbnQgbGlicmFyaWVzLCBlZGl0IFdlYiBkaXNjdXNzaW9uIGNvbW1lbnRzXHJcbiAgICAgKiBpbiBkb2N1bWVudHMsIGFuZCBjdXN0b21pemUgV2ViIFBhcnQgUGFnZXMgaW4gZG9jdW1lbnQgbGlicmFyaWVzLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkVkaXRMaXN0SXRlbXNcIl0gPSAzXSA9IFwiRWRpdExpc3RJdGVtc1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgaXRlbXMgZnJvbSBhIGxpc3QsIGRvY3VtZW50cyBmcm9tIGEgZG9jdW1lbnQgbGlicmFyeSwgYW5kIFdlYiBkaXNjdXNzaW9uXHJcbiAgICAgKiBjb21tZW50cyBpbiBkb2N1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiRGVsZXRlTGlzdEl0ZW1zXCJdID0gNF0gPSBcIkRlbGV0ZUxpc3RJdGVtc1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHByb3ZlIGEgbWlub3IgdmVyc2lvbiBvZiBhIGxpc3QgaXRlbSBvciBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgUGVybWlzc2lvbktpbmRbUGVybWlzc2lvbktpbmRbXCJBcHByb3ZlSXRlbXNcIl0gPSA1XSA9IFwiQXBwcm92ZUl0ZW1zXCI7XHJcbiAgICAvKipcclxuICAgICAqIFZpZXcgdGhlIHNvdXJjZSBvZiBkb2N1bWVudHMgd2l0aCBzZXJ2ZXItc2lkZSBmaWxlIGhhbmRsZXJzLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIk9wZW5JdGVtc1wiXSA9IDZdID0gXCJPcGVuSXRlbXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogVmlldyBwYXN0IHZlcnNpb25zIG9mIGEgbGlzdCBpdGVtIG9yIGRvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIlZpZXdWZXJzaW9uc1wiXSA9IDddID0gXCJWaWV3VmVyc2lvbnNcIjtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIHBhc3QgdmVyc2lvbnMgb2YgYSBsaXN0IGl0ZW0gb3IgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiRGVsZXRlVmVyc2lvbnNcIl0gPSA4XSA9IFwiRGVsZXRlVmVyc2lvbnNcIjtcclxuICAgIC8qKlxyXG4gICAgICogRGlzY2FyZCBvciBjaGVjayBpbiBhIGRvY3VtZW50IHdoaWNoIGlzIGNoZWNrZWQgb3V0IHRvIGFub3RoZXIgdXNlci5cclxuICAgICAqL1xyXG4gICAgUGVybWlzc2lvbktpbmRbUGVybWlzc2lvbktpbmRbXCJDYW5jZWxDaGVja291dFwiXSA9IDldID0gXCJDYW5jZWxDaGVja291dFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUsIGNoYW5nZSwgYW5kIGRlbGV0ZSBwZXJzb25hbCB2aWV3cyBvZiBsaXN0cy5cclxuICAgICAqL1xyXG4gICAgUGVybWlzc2lvbktpbmRbUGVybWlzc2lvbktpbmRbXCJNYW5hZ2VQZXJzb25hbFZpZXdzXCJdID0gMTBdID0gXCJNYW5hZ2VQZXJzb25hbFZpZXdzXCI7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbmQgZGVsZXRlIGxpc3RzLCBhZGQgb3IgcmVtb3ZlIGNvbHVtbnMgaW4gYSBsaXN0LCBhbmQgYWRkIG9yIHJlbW92ZSBwdWJsaWMgdmlld3Mgb2YgYSBsaXN0LlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIk1hbmFnZUxpc3RzXCJdID0gMTJdID0gXCJNYW5hZ2VMaXN0c1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWaWV3IGZvcm1zLCB2aWV3cywgYW5kIGFwcGxpY2F0aW9uIHBhZ2VzLCBhbmQgZW51bWVyYXRlIGxpc3RzLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIlZpZXdGb3JtUGFnZXNcIl0gPSAxM10gPSBcIlZpZXdGb3JtUGFnZXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogTWFrZSBjb250ZW50IG9mIGEgbGlzdCBvciBkb2N1bWVudCBsaWJyYXJ5IHJldHJpZXZlYWJsZSBmb3IgYW5vbnltb3VzIHVzZXJzIHRocm91Z2ggU2hhcmVQb2ludCBzZWFyY2guXHJcbiAgICAgKiBUaGUgbGlzdCBwZXJtaXNzaW9ucyBpbiB0aGUgc2l0ZSBkbyBub3QgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkFub255bW91c1NlYXJjaEFjY2Vzc0xpc3RcIl0gPSAxNF0gPSBcIkFub255bW91c1NlYXJjaEFjY2Vzc0xpc3RcIjtcclxuICAgIC8qKlxyXG4gICAgICogQWxsb3cgdXNlcnMgdG8gb3BlbiBhIFNpdGUsIGxpc3QsIG9yIGZvbGRlciB0byBhY2Nlc3MgaXRlbXMgaW5zaWRlIHRoYXQgY29udGFpbmVyLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIk9wZW5cIl0gPSAxN10gPSBcIk9wZW5cIjtcclxuICAgIC8qKlxyXG4gICAgICogVmlldyBwYWdlcyBpbiBhIFNpdGUuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiVmlld1BhZ2VzXCJdID0gMThdID0gXCJWaWV3UGFnZXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogQWRkLCBjaGFuZ2UsIG9yIGRlbGV0ZSBIVE1MIHBhZ2VzIG9yIFdlYiBQYXJ0IFBhZ2VzLCBhbmQgZWRpdCB0aGUgU2l0ZSB1c2luZ1xyXG4gICAgICogYSBXaW5kb3dzIFNoYXJlUG9pbnQgU2VydmljZXMgY29tcGF0aWJsZSBlZGl0b3IuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiQWRkQW5kQ3VzdG9taXplUGFnZXNcIl0gPSAxOV0gPSBcIkFkZEFuZEN1c3RvbWl6ZVBhZ2VzXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IGEgdGhlbWUgb3IgYm9yZGVycyB0byB0aGUgZW50aXJlIFNpdGUuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiQXBwbHlUaGVtZUFuZEJvcmRlclwiXSA9IDIwXSA9IFwiQXBwbHlUaGVtZUFuZEJvcmRlclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBhIHN0eWxlIHNoZWV0ICguY3NzIGZpbGUpIHRvIHRoZSBTaXRlLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkFwcGx5U3R5bGVTaGVldHNcIl0gPSAyMV0gPSBcIkFwcGx5U3R5bGVTaGVldHNcIjtcclxuICAgIC8qKlxyXG4gICAgICogVmlldyByZXBvcnRzIG9uIFNpdGUgdXNhZ2UuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiVmlld1VzYWdlRGF0YVwiXSA9IDIyXSA9IFwiVmlld1VzYWdlRGF0YVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBTaXRlIHVzaW5nIFNlbGYtU2VydmljZSBTaXRlIENyZWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkNyZWF0ZVNTQ1NpdGVcIl0gPSAyM10gPSBcIkNyZWF0ZVNTQ1NpdGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHN1YnNpdGVzIHN1Y2ggYXMgdGVhbSBzaXRlcywgTWVldGluZyBXb3Jrc3BhY2Ugc2l0ZXMsIGFuZCBEb2N1bWVudCBXb3Jrc3BhY2Ugc2l0ZXMuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiTWFuYWdlU3Vid2Vic1wiXSA9IDI0XSA9IFwiTWFuYWdlU3Vid2Vic1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBncm91cCBvZiB1c2VycyB0aGF0IGNhbiBiZSB1c2VkIGFueXdoZXJlIHdpdGhpbiB0aGUgc2l0ZSBjb2xsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkNyZWF0ZUdyb3Vwc1wiXSA9IDI1XSA9IFwiQ3JlYXRlR3JvdXBzXCI7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbmQgY2hhbmdlIHBlcm1pc3Npb24gbGV2ZWxzIG9uIHRoZSBTaXRlIGFuZCBhc3NpZ24gcGVybWlzc2lvbnMgdG8gdXNlcnNcclxuICAgICAqIGFuZCBncm91cHMuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiTWFuYWdlUGVybWlzc2lvbnNcIl0gPSAyNl0gPSBcIk1hbmFnZVBlcm1pc3Npb25zXCI7XHJcbiAgICAvKipcclxuICAgICAqIEVudW1lcmF0ZSBmaWxlcyBhbmQgZm9sZGVycyBpbiBhIFNpdGUgdXNpbmcgTWljcm9zb2Z0IE9mZmljZSBTaGFyZVBvaW50IERlc2lnbmVyXHJcbiAgICAgKiBhbmQgV2ViREFWIGludGVyZmFjZXMuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiQnJvd3NlRGlyZWN0b3JpZXNcIl0gPSAyN10gPSBcIkJyb3dzZURpcmVjdG9yaWVzXCI7XHJcbiAgICAvKipcclxuICAgICAqIFZpZXcgaW5mb3JtYXRpb24gYWJvdXQgdXNlcnMgb2YgdGhlIFNpdGUuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiQnJvd3NlVXNlckluZm9cIl0gPSAyOF0gPSBcIkJyb3dzZVVzZXJJbmZvXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBvciByZW1vdmUgcGVyc29uYWwgV2ViIFBhcnRzIG9uIGEgV2ViIFBhcnQgUGFnZS5cclxuICAgICAqL1xyXG4gICAgUGVybWlzc2lvbktpbmRbUGVybWlzc2lvbktpbmRbXCJBZGREZWxQcml2YXRlV2ViUGFydHNcIl0gPSAyOV0gPSBcIkFkZERlbFByaXZhdGVXZWJQYXJ0c1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgV2ViIFBhcnRzIHRvIGRpc3BsYXkgcGVyc29uYWxpemVkIGluZm9ybWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIlVwZGF0ZVBlcnNvbmFsV2ViUGFydHNcIl0gPSAzMF0gPSBcIlVwZGF0ZVBlcnNvbmFsV2ViUGFydHNcIjtcclxuICAgIC8qKlxyXG4gICAgICogR3JhbnQgdGhlIGFiaWxpdHkgdG8gcGVyZm9ybSBhbGwgYWRtaW5pc3RyYXRpb24gdGFza3MgZm9yIHRoZSBTaXRlIGFzIHdlbGwgYXNcclxuICAgICAqIG1hbmFnZSBjb250ZW50LCBhY3RpdmF0ZSwgZGVhY3RpdmF0ZSwgb3IgZWRpdCBwcm9wZXJ0aWVzIG9mIFNpdGUgc2NvcGVkIEZlYXR1cmVzXHJcbiAgICAgKiB0aHJvdWdoIHRoZSBvYmplY3QgbW9kZWwgb3IgdGhyb3VnaCB0aGUgdXNlciBpbnRlcmZhY2UgKFVJKS4gV2hlbiBncmFudGVkIG9uIHRoZVxyXG4gICAgICogcm9vdCBTaXRlIG9mIGEgU2l0ZSBDb2xsZWN0aW9uLCBhY3RpdmF0ZSwgZGVhY3RpdmF0ZSwgb3IgZWRpdCBwcm9wZXJ0aWVzIG9mXHJcbiAgICAgKiBzaXRlIGNvbGxlY3Rpb24gc2NvcGVkIEZlYXR1cmVzIHRocm91Z2ggdGhlIG9iamVjdCBtb2RlbC4gVG8gYnJvd3NlIHRvIHRoZSBTaXRlXHJcbiAgICAgKiBDb2xsZWN0aW9uIEZlYXR1cmVzIHBhZ2UgYW5kIGFjdGl2YXRlIG9yIGRlYWN0aXZhdGUgU2l0ZSBDb2xsZWN0aW9uIHNjb3BlZCBGZWF0dXJlc1xyXG4gICAgICogdGhyb3VnaCB0aGUgVUksIHlvdSBtdXN0IGJlIGEgU2l0ZSBDb2xsZWN0aW9uIGFkbWluaXN0cmF0b3IuXHJcbiAgICAgKi9cclxuICAgIFBlcm1pc3Npb25LaW5kW1Blcm1pc3Npb25LaW5kW1wiTWFuYWdlV2ViXCJdID0gMzFdID0gXCJNYW5hZ2VXZWJcIjtcclxuICAgIC8qKlxyXG4gICAgICogQ29udGVudCBvZiBsaXN0cyBhbmQgZG9jdW1lbnQgbGlicmFyaWVzIGluIHRoZSBXZWIgc2l0ZSB3aWxsIGJlIHJldHJpZXZlYWJsZSBmb3IgYW5vbnltb3VzIHVzZXJzIHRocm91Z2hcclxuICAgICAqIFNoYXJlUG9pbnQgc2VhcmNoIGlmIHRoZSBsaXN0IG9yIGRvY3VtZW50IGxpYnJhcnkgaGFzIEFub255bW91c1NlYXJjaEFjY2Vzc0xpc3Qgc2V0LlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkFub255bW91c1NlYXJjaEFjY2Vzc1dlYkxpc3RzXCJdID0gMzJdID0gXCJBbm9ueW1vdXNTZWFyY2hBY2Nlc3NXZWJMaXN0c1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgZmVhdHVyZXMgdGhhdCBsYXVuY2ggY2xpZW50IGFwcGxpY2F0aW9ucy4gT3RoZXJ3aXNlLCB1c2VycyBtdXN0IHdvcmsgb24gZG9jdW1lbnRzXHJcbiAgICAgKiBsb2NhbGx5IGFuZCB1cGxvYWQgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgUGVybWlzc2lvbktpbmRbUGVybWlzc2lvbktpbmRbXCJVc2VDbGllbnRJbnRlZ3JhdGlvblwiXSA9IDM3XSA9IFwiVXNlQ2xpZW50SW50ZWdyYXRpb25cIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIFNPQVAsIFdlYkRBViwgb3IgTWljcm9zb2Z0IE9mZmljZSBTaGFyZVBvaW50IERlc2lnbmVyIGludGVyZmFjZXMgdG8gYWNjZXNzIHRoZSBTaXRlLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIlVzZVJlbW90ZUFQSXNcIl0gPSAzOF0gPSBcIlVzZVJlbW90ZUFQSXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogTWFuYWdlIGFsZXJ0cyBmb3IgYWxsIHVzZXJzIG9mIHRoZSBTaXRlLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIk1hbmFnZUFsZXJ0c1wiXSA9IDM5XSA9IFwiTWFuYWdlQWxlcnRzXCI7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBlLW1haWwgYWxlcnRzLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkNyZWF0ZUFsZXJ0c1wiXSA9IDQwXSA9IFwiQ3JlYXRlQWxlcnRzXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFsbG93cyBhIHVzZXIgdG8gY2hhbmdlIGhpcyBvciBoZXIgdXNlciBpbmZvcm1hdGlvbiwgc3VjaCBhcyBhZGRpbmcgYSBwaWN0dXJlLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkVkaXRNeVVzZXJJbmZvXCJdID0gNDFdID0gXCJFZGl0TXlVc2VySW5mb1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtZXJhdGUgcGVybWlzc2lvbnMgb24gU2l0ZSwgbGlzdCwgZm9sZGVyLCBkb2N1bWVudCwgb3IgbGlzdCBpdGVtLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkVudW1lcmF0ZVBlcm1pc3Npb25zXCJdID0gNjNdID0gXCJFbnVtZXJhdGVQZXJtaXNzaW9uc1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYXMgYWxsIHBlcm1pc3Npb25zIG9uIHRoZSBTaXRlLiBOb3QgYXZhaWxhYmxlIHRocm91Z2ggdGhlIHVzZXIgaW50ZXJmYWNlLlxyXG4gICAgICovXHJcbiAgICBQZXJtaXNzaW9uS2luZFtQZXJtaXNzaW9uS2luZFtcIkZ1bGxNYXNrXCJdID0gNjVdID0gXCJGdWxsTWFza1wiO1xyXG59KShQZXJtaXNzaW9uS2luZCB8fCAoUGVybWlzc2lvbktpbmQgPSB7fSkpO1xyXG4vKipcclxuICogU3BlY2lmaWVzIHRoZSB0eXBlIG9mIGEgcHJpbmNpcGFsLlxyXG4gKi9cclxuLyogdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZSAqL1xyXG52YXIgUHJpbmNpcGFsVHlwZSQxO1xyXG4oZnVuY3Rpb24gKFByaW5jaXBhbFR5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRpb24gd2hvc2UgdmFsdWUgc3BlY2lmaWVzIG5vIHByaW5jaXBhbCB0eXBlLlxyXG4gICAgICovXHJcbiAgICBQcmluY2lwYWxUeXBlW1ByaW5jaXBhbFR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRpb24gd2hvc2UgdmFsdWUgc3BlY2lmaWVzIGEgdXNlciBhcyB0aGUgcHJpbmNpcGFsIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIFByaW5jaXBhbFR5cGVbUHJpbmNpcGFsVHlwZVtcIlVzZXJcIl0gPSAxXSA9IFwiVXNlclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtZXJhdGlvbiB3aG9zZSB2YWx1ZSBzcGVjaWZpZXMgYSBkaXN0cmlidXRpb24gbGlzdCBhcyB0aGUgcHJpbmNpcGFsIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIFByaW5jaXBhbFR5cGVbUHJpbmNpcGFsVHlwZVtcIkRpc3RyaWJ1dGlvbkxpc3RcIl0gPSAyXSA9IFwiRGlzdHJpYnV0aW9uTGlzdFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtZXJhdGlvbiB3aG9zZSB2YWx1ZSBzcGVjaWZpZXMgYSBzZWN1cml0eSBncm91cCBhcyB0aGUgcHJpbmNpcGFsIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIFByaW5jaXBhbFR5cGVbUHJpbmNpcGFsVHlwZVtcIlNlY3VyaXR5R3JvdXBcIl0gPSA0XSA9IFwiU2VjdXJpdHlHcm91cFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtZXJhdGlvbiB3aG9zZSB2YWx1ZSBzcGVjaWZpZXMgYSBncm91cCBhcyB0aGUgcHJpbmNpcGFsIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIFByaW5jaXBhbFR5cGVbUHJpbmNpcGFsVHlwZVtcIlNoYXJlUG9pbnRHcm91cFwiXSA9IDhdID0gXCJTaGFyZVBvaW50R3JvdXBcIjtcclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRpb24gd2hvc2UgdmFsdWUgc3BlY2lmaWVzIGFsbCBwcmluY2lwYWwgdHlwZXMuXHJcbiAgICAgKi9cclxuICAgIFByaW5jaXBhbFR5cGVbUHJpbmNpcGFsVHlwZVtcIkFsbFwiXSA9IDE1XSA9IFwiQWxsXCI7XHJcbn0pKFByaW5jaXBhbFR5cGUkMSB8fCAoUHJpbmNpcGFsVHlwZSQxID0ge30pKTtcclxuLyogdHNsaW50OmVuYWJsZTpuby1iaXR3aXNlICovXHJcbi8qKlxyXG4gKiBTcGVjaWZpZXMgdGhlIHNvdXJjZSBvZiBhIHByaW5jaXBhbC5cclxuICovXHJcbi8qIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2UgKi9cclxudmFyIFByaW5jaXBhbFNvdXJjZTtcclxuKGZ1bmN0aW9uIChQcmluY2lwYWxTb3VyY2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRpb24gd2hvc2UgdmFsdWUgc3BlY2lmaWVzIG5vIHByaW5jaXBhbCBzb3VyY2UuXHJcbiAgICAgKi9cclxuICAgIFByaW5jaXBhbFNvdXJjZVtQcmluY2lwYWxTb3VyY2VbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRpb24gd2hvc2UgdmFsdWUgc3BlY2lmaWVzIHVzZXIgaW5mb3JtYXRpb24gbGlzdCBhcyB0aGUgcHJpbmNpcGFsIHNvdXJjZS5cclxuICAgICAqL1xyXG4gICAgUHJpbmNpcGFsU291cmNlW1ByaW5jaXBhbFNvdXJjZVtcIlVzZXJJbmZvTGlzdFwiXSA9IDFdID0gXCJVc2VySW5mb0xpc3RcIjtcclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRpb24gd2hvc2UgdmFsdWUgc3BlY2lmaWVzIEFjdGl2ZSBEaXJlY3RvcnkgYXMgdGhlIHByaW5jaXBhbCBzb3VyY2UuXHJcbiAgICAgKi9cclxuICAgIFByaW5jaXBhbFNvdXJjZVtQcmluY2lwYWxTb3VyY2VbXCJXaW5kb3dzXCJdID0gMl0gPSBcIldpbmRvd3NcIjtcclxuICAgIC8qKlxyXG4gICAgICogRW51bWVyYXRpb24gd2hvc2UgdmFsdWUgc3BlY2lmaWVzIHRoZSBjdXJyZW50IG1lbWJlcnNoaXAgcHJvdmlkZXIgYXMgdGhlIHByaW5jaXBhbCBzb3VyY2UuXHJcbiAgICAgKi9cclxuICAgIFByaW5jaXBhbFNvdXJjZVtQcmluY2lwYWxTb3VyY2VbXCJNZW1iZXJzaGlwUHJvdmlkZXJcIl0gPSA0XSA9IFwiTWVtYmVyc2hpcFByb3ZpZGVyXCI7XHJcbiAgICAvKipcclxuICAgICAqIEVudW1lcmF0aW9uIHdob3NlIHZhbHVlIHNwZWNpZmllcyB0aGUgY3VycmVudCByb2xlIHByb3ZpZGVyIGFzIHRoZSBwcmluY2lwYWwgc291cmNlLlxyXG4gICAgICovXHJcbiAgICBQcmluY2lwYWxTb3VyY2VbUHJpbmNpcGFsU291cmNlW1wiUm9sZVByb3ZpZGVyXCJdID0gOF0gPSBcIlJvbGVQcm92aWRlclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtZXJhdGlvbiB3aG9zZSB2YWx1ZSBzcGVjaWZpZXMgYWxsIHByaW5jaXBhbCBzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBQcmluY2lwYWxTb3VyY2VbUHJpbmNpcGFsU291cmNlW1wiQWxsXCJdID0gMTVdID0gXCJBbGxcIjtcclxufSkoUHJpbmNpcGFsU291cmNlIHx8IChQcmluY2lwYWxTb3VyY2UgPSB7fSkpO1xyXG4vKiB0c2xpbnQ6ZW5hYmxlOm5vLWJpdHdpc2UgKi9cclxudmFyIFJvbGVUeXBlO1xyXG4oZnVuY3Rpb24gKFJvbGVUeXBlKSB7XHJcbiAgICBSb2xlVHlwZVtSb2xlVHlwZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgUm9sZVR5cGVbUm9sZVR5cGVbXCJHdWVzdFwiXSA9IDFdID0gXCJHdWVzdFwiO1xyXG4gICAgUm9sZVR5cGVbUm9sZVR5cGVbXCJSZWFkZXJcIl0gPSAyXSA9IFwiUmVhZGVyXCI7XHJcbiAgICBSb2xlVHlwZVtSb2xlVHlwZVtcIkNvbnRyaWJ1dG9yXCJdID0gM10gPSBcIkNvbnRyaWJ1dG9yXCI7XHJcbiAgICBSb2xlVHlwZVtSb2xlVHlwZVtcIldlYkRlc2lnbmVyXCJdID0gNF0gPSBcIldlYkRlc2lnbmVyXCI7XHJcbiAgICBSb2xlVHlwZVtSb2xlVHlwZVtcIkFkbWluaXN0cmF0b3JcIl0gPSA1XSA9IFwiQWRtaW5pc3RyYXRvclwiO1xyXG59KShSb2xlVHlwZSB8fCAoUm9sZVR5cGUgPSB7fSkpO1xyXG52YXIgUGFnZVR5cGU7XHJcbihmdW5jdGlvbiAoUGFnZVR5cGUpIHtcclxuICAgIFBhZ2VUeXBlW1BhZ2VUeXBlW1wiSW52YWxpZFwiXSA9IC0xXSA9IFwiSW52YWxpZFwiO1xyXG4gICAgUGFnZVR5cGVbUGFnZVR5cGVbXCJEZWZhdWx0Vmlld1wiXSA9IDBdID0gXCJEZWZhdWx0Vmlld1wiO1xyXG4gICAgUGFnZVR5cGVbUGFnZVR5cGVbXCJOb3JtYWxWaWV3XCJdID0gMV0gPSBcIk5vcm1hbFZpZXdcIjtcclxuICAgIFBhZ2VUeXBlW1BhZ2VUeXBlW1wiRGlhbG9nVmlld1wiXSA9IDJdID0gXCJEaWFsb2dWaWV3XCI7XHJcbiAgICBQYWdlVHlwZVtQYWdlVHlwZVtcIlZpZXdcIl0gPSAzXSA9IFwiVmlld1wiO1xyXG4gICAgUGFnZVR5cGVbUGFnZVR5cGVbXCJEaXNwbGF5Rm9ybVwiXSA9IDRdID0gXCJEaXNwbGF5Rm9ybVwiO1xyXG4gICAgUGFnZVR5cGVbUGFnZVR5cGVbXCJEaXNwbGF5Rm9ybURpYWxvZ1wiXSA9IDVdID0gXCJEaXNwbGF5Rm9ybURpYWxvZ1wiO1xyXG4gICAgUGFnZVR5cGVbUGFnZVR5cGVbXCJFZGl0Rm9ybVwiXSA9IDZdID0gXCJFZGl0Rm9ybVwiO1xyXG4gICAgUGFnZVR5cGVbUGFnZVR5cGVbXCJFZGl0Rm9ybURpYWxvZ1wiXSA9IDddID0gXCJFZGl0Rm9ybURpYWxvZ1wiO1xyXG4gICAgUGFnZVR5cGVbUGFnZVR5cGVbXCJOZXdGb3JtXCJdID0gOF0gPSBcIk5ld0Zvcm1cIjtcclxuICAgIFBhZ2VUeXBlW1BhZ2VUeXBlW1wiTmV3Rm9ybURpYWxvZ1wiXSA9IDldID0gXCJOZXdGb3JtRGlhbG9nXCI7XHJcbiAgICBQYWdlVHlwZVtQYWdlVHlwZVtcIlNvbHV0aW9uRm9ybVwiXSA9IDEwXSA9IFwiU29sdXRpb25Gb3JtXCI7XHJcbiAgICBQYWdlVHlwZVtQYWdlVHlwZVtcIlBBR0VfTUFYSVRFTVNcIl0gPSAxMV0gPSBcIlBBR0VfTUFYSVRFTVNcIjtcclxufSkoUGFnZVR5cGUgfHwgKFBhZ2VUeXBlID0ge30pKTtcclxudmFyIFNoYXJpbmdMaW5rS2luZDtcclxuKGZ1bmN0aW9uIChTaGFyaW5nTGlua0tpbmQpIHtcclxuICAgIC8qKlxyXG4gICAgICogVW5pbml0aWFsaXplZCBsaW5rXHJcbiAgICAgKi9cclxuICAgIFNoYXJpbmdMaW5rS2luZFtTaGFyaW5nTGlua0tpbmRbXCJVbmluaXRpYWxpemVkXCJdID0gMF0gPSBcIlVuaW5pdGlhbGl6ZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogRGlyZWN0IGxpbmsgdG8gdGhlIG9iamVjdCBiZWluZyBzaGFyZWRcclxuICAgICAqL1xyXG4gICAgU2hhcmluZ0xpbmtLaW5kW1NoYXJpbmdMaW5rS2luZFtcIkRpcmVjdFwiXSA9IDFdID0gXCJEaXJlY3RcIjtcclxuICAgIC8qKlxyXG4gICAgICogT3JnYW5pemF0aW9uLXNoYXJlYWJsZSBsaW5rIHRvIHRoZSBvYmplY3QgYmVpbmcgc2hhcmVkIHdpdGggdmlldyBwZXJtaXNzaW9uc1xyXG4gICAgICovXHJcbiAgICBTaGFyaW5nTGlua0tpbmRbU2hhcmluZ0xpbmtLaW5kW1wiT3JnYW5pemF0aW9uVmlld1wiXSA9IDJdID0gXCJPcmdhbml6YXRpb25WaWV3XCI7XHJcbiAgICAvKipcclxuICAgICAqIE9yZ2FuaXphdGlvbi1zaGFyZWFibGUgbGluayB0byB0aGUgb2JqZWN0IGJlaW5nIHNoYXJlZCB3aXRoIGVkaXQgcGVybWlzc2lvbnNcclxuICAgICAqL1xyXG4gICAgU2hhcmluZ0xpbmtLaW5kW1NoYXJpbmdMaW5rS2luZFtcIk9yZ2FuaXphdGlvbkVkaXRcIl0gPSAzXSA9IFwiT3JnYW5pemF0aW9uRWRpdFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWaWV3IG9ubHkgYW5vbnltb3VzIGxpbmtcclxuICAgICAqL1xyXG4gICAgU2hhcmluZ0xpbmtLaW5kW1NoYXJpbmdMaW5rS2luZFtcIkFub255bW91c1ZpZXdcIl0gPSA0XSA9IFwiQW5vbnltb3VzVmlld1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkL1dyaXRlIGFub255bW91cyBsaW5rXHJcbiAgICAgKi9cclxuICAgIFNoYXJpbmdMaW5rS2luZFtTaGFyaW5nTGlua0tpbmRbXCJBbm9ueW1vdXNFZGl0XCJdID0gNV0gPSBcIkFub255bW91c0VkaXRcIjtcclxuICAgIC8qKlxyXG4gICAgICogRmxleGlibGUgc2hhcmluZyBMaW5rIHdoZXJlIHByb3BlcnRpZXMgY2FuIGNoYW5nZSB3aXRob3V0IGFmZmVjdGluZyBsaW5rIFVSTFxyXG4gICAgICovXHJcbiAgICBTaGFyaW5nTGlua0tpbmRbU2hhcmluZ0xpbmtLaW5kW1wiRmxleGlibGVcIl0gPSA2XSA9IFwiRmxleGlibGVcIjtcclxufSkoU2hhcmluZ0xpbmtLaW5kIHx8IChTaGFyaW5nTGlua0tpbmQgPSB7fSkpO1xyXG4vKipcclxuICogSW5kaWNhdGVzIHRoZSByb2xlIG9mIHRoZSBzaGFyaW5nIGxpbmtcclxuICovXHJcbnZhciBTaGFyaW5nUm9sZTtcclxuKGZ1bmN0aW9uIChTaGFyaW5nUm9sZSkge1xyXG4gICAgU2hhcmluZ1JvbGVbU2hhcmluZ1JvbGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIFNoYXJpbmdSb2xlW1NoYXJpbmdSb2xlW1wiVmlld1wiXSA9IDFdID0gXCJWaWV3XCI7XHJcbiAgICBTaGFyaW5nUm9sZVtTaGFyaW5nUm9sZVtcIkVkaXRcIl0gPSAyXSA9IFwiRWRpdFwiO1xyXG4gICAgU2hhcmluZ1JvbGVbU2hhcmluZ1JvbGVbXCJPd25lclwiXSA9IDNdID0gXCJPd25lclwiO1xyXG59KShTaGFyaW5nUm9sZSB8fCAoU2hhcmluZ1JvbGUgPSB7fSkpO1xyXG52YXIgU2hhcmluZ09wZXJhdGlvblN0YXR1c0NvZGU7XHJcbihmdW5jdGlvbiAoU2hhcmluZ09wZXJhdGlvblN0YXR1c0NvZGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNoYXJlIG9wZXJhdGlvbiBjb21wbGV0ZWQgd2l0aG91dCBlcnJvcnMuXHJcbiAgICAgKi9cclxuICAgIFNoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1NoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1wiQ29tcGxldGVkU3VjY2Vzc2Z1bGx5XCJdID0gMF0gPSBcIkNvbXBsZXRlZFN1Y2Nlc3NmdWxseVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2hhcmUgb3BlcmF0aW9uIGNvbXBsZXRlZCBhbmQgZ2VuZXJhdGVkIHJlcXVlc3RzIGZvciBhY2Nlc3MuXHJcbiAgICAgKi9cclxuICAgIFNoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1NoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1wiQWNjZXNzUmVxdWVzdHNRdWV1ZWRcIl0gPSAxXSA9IFwiQWNjZXNzUmVxdWVzdHNRdWV1ZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNoYXJlIG9wZXJhdGlvbiBmYWlsZWQgYXMgdGhlcmUgd2VyZSBubyByZXNvbHZlZCB1c2Vycy5cclxuICAgICAqL1xyXG4gICAgU2hhcmluZ09wZXJhdGlvblN0YXR1c0NvZGVbU2hhcmluZ09wZXJhdGlvblN0YXR1c0NvZGVbXCJOb1Jlc29sdmVkVXNlcnNcIl0gPSAtMV0gPSBcIk5vUmVzb2x2ZWRVc2Vyc1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2hhcmUgb3BlcmF0aW9uIGZhaWxlZCBkdWUgdG8gaW5zdWZmaWNpZW50IHBlcm1pc3Npb25zLlxyXG4gICAgICovXHJcbiAgICBTaGFyaW5nT3BlcmF0aW9uU3RhdHVzQ29kZVtTaGFyaW5nT3BlcmF0aW9uU3RhdHVzQ29kZVtcIkFjY2Vzc0RlbmllZFwiXSA9IC0yXSA9IFwiQWNjZXNzRGVuaWVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaGFyZSBvcGVyYXRpb24gZmFpbGVkIHdoZW4gYXR0ZW1wdGluZyBhIGNyb3NzIHNpdGUgc2hhcmUsIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIFNoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1NoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1wiQ3Jvc3NTaXRlUmVxdWVzdE5vdFN1cHBvcnRlZFwiXSA9IC0zXSA9IFwiQ3Jvc3NTaXRlUmVxdWVzdE5vdFN1cHBvcnRlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2hhcmluZyBvcGVyYXRpb24gZmFpbGVkIGR1ZSB0byBhbiB1bmtub3duIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBTaGFyaW5nT3BlcmF0aW9uU3RhdHVzQ29kZVtTaGFyaW5nT3BlcmF0aW9uU3RhdHVzQ29kZVtcIlVua25vd0Vycm9yXCJdID0gLTRdID0gXCJVbmtub3dFcnJvclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCB5b3UgdHlwZWQgaXMgdG9vIGxvbmcuIFBsZWFzZSBzaG9ydGVuIGl0LlxyXG4gICAgICovXHJcbiAgICBTaGFyaW5nT3BlcmF0aW9uU3RhdHVzQ29kZVtTaGFyaW5nT3BlcmF0aW9uU3RhdHVzQ29kZVtcIkVtYWlsQm9keVRvb0xvbmdcIl0gPSAtNV0gPSBcIkVtYWlsQm9keVRvb0xvbmdcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHVuaXF1ZSBzY29wZXMgaW4gdGhlIGxpc3QgaGFzIGJlZW4gZXhjZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIFNoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1NoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1wiTGlzdFVuaXF1ZVNjb3Blc0V4Y2VlZGVkXCJdID0gLTZdID0gXCJMaXN0VW5pcXVlU2NvcGVzRXhjZWVkZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNoYXJlIG9wZXJhdGlvbiBmYWlsZWQgYmVjYXVzZSBhIHNoYXJpbmcgY2FwYWJpbGl0eSBpcyBkaXNhYmxlZCBpbiB0aGUgc2l0ZS5cclxuICAgICAqL1xyXG4gICAgU2hhcmluZ09wZXJhdGlvblN0YXR1c0NvZGVbU2hhcmluZ09wZXJhdGlvblN0YXR1c0NvZGVbXCJDYXBhYmlsaXR5RGlzYWJsZWRcIl0gPSAtN10gPSBcIkNhcGFiaWxpdHlEaXNhYmxlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3BlY2lmaWVkIG9iamVjdCBmb3IgdGhlIHNoYXJlIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICovXHJcbiAgICBTaGFyaW5nT3BlcmF0aW9uU3RhdHVzQ29kZVtTaGFyaW5nT3BlcmF0aW9uU3RhdHVzQ29kZVtcIk9iamVjdE5vdFN1cHBvcnRlZFwiXSA9IC04XSA9IFwiT2JqZWN0Tm90U3VwcG9ydGVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIEEgU2hhcmVQb2ludCBncm91cCBjYW5ub3QgY29udGFpbiBhbm90aGVyIFNoYXJlUG9pbnQgZ3JvdXAuXHJcbiAgICAgKi9cclxuICAgIFNoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1NoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlW1wiTmVzdGVkR3JvdXBzTm90U3VwcG9ydGVkXCJdID0gLTldID0gXCJOZXN0ZWRHcm91cHNOb3RTdXBwb3J0ZWRcIjtcclxufSkoU2hhcmluZ09wZXJhdGlvblN0YXR1c0NvZGUgfHwgKFNoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlID0ge30pKTtcclxudmFyIFNQU2hhcmVkT2JqZWN0VHlwZTtcclxuKGZ1bmN0aW9uIChTUFNoYXJlZE9iamVjdFR5cGUpIHtcclxuICAgIFNQU2hhcmVkT2JqZWN0VHlwZVtTUFNoYXJlZE9iamVjdFR5cGVbXCJVbmtub3duXCJdID0gMF0gPSBcIlVua25vd25cIjtcclxuICAgIFNQU2hhcmVkT2JqZWN0VHlwZVtTUFNoYXJlZE9iamVjdFR5cGVbXCJGaWxlXCJdID0gMV0gPSBcIkZpbGVcIjtcclxuICAgIFNQU2hhcmVkT2JqZWN0VHlwZVtTUFNoYXJlZE9iamVjdFR5cGVbXCJGb2xkZXJcIl0gPSAyXSA9IFwiRm9sZGVyXCI7XHJcbiAgICBTUFNoYXJlZE9iamVjdFR5cGVbU1BTaGFyZWRPYmplY3RUeXBlW1wiSXRlbVwiXSA9IDNdID0gXCJJdGVtXCI7XHJcbiAgICBTUFNoYXJlZE9iamVjdFR5cGVbU1BTaGFyZWRPYmplY3RUeXBlW1wiTGlzdFwiXSA9IDRdID0gXCJMaXN0XCI7XHJcbiAgICBTUFNoYXJlZE9iamVjdFR5cGVbU1BTaGFyZWRPYmplY3RUeXBlW1wiV2ViXCJdID0gNV0gPSBcIldlYlwiO1xyXG4gICAgU1BTaGFyZWRPYmplY3RUeXBlW1NQU2hhcmVkT2JqZWN0VHlwZVtcIk1heFwiXSA9IDZdID0gXCJNYXhcIjtcclxufSkoU1BTaGFyZWRPYmplY3RUeXBlIHx8IChTUFNoYXJlZE9iamVjdFR5cGUgPSB7fSkpO1xyXG52YXIgU2hhcmluZ0RvbWFpblJlc3RyaWN0aW9uTW9kZTtcclxuKGZ1bmN0aW9uIChTaGFyaW5nRG9tYWluUmVzdHJpY3Rpb25Nb2RlKSB7XHJcbiAgICBTaGFyaW5nRG9tYWluUmVzdHJpY3Rpb25Nb2RlW1NoYXJpbmdEb21haW5SZXN0cmljdGlvbk1vZGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIFNoYXJpbmdEb21haW5SZXN0cmljdGlvbk1vZGVbU2hhcmluZ0RvbWFpblJlc3RyaWN0aW9uTW9kZVtcIkFsbG93TGlzdFwiXSA9IDFdID0gXCJBbGxvd0xpc3RcIjtcclxuICAgIFNoYXJpbmdEb21haW5SZXN0cmljdGlvbk1vZGVbU2hhcmluZ0RvbWFpblJlc3RyaWN0aW9uTW9kZVtcIkJsb2NrTGlzdFwiXSA9IDJdID0gXCJCbG9ja0xpc3RcIjtcclxufSkoU2hhcmluZ0RvbWFpblJlc3RyaWN0aW9uTW9kZSB8fCAoU2hhcmluZ0RvbWFpblJlc3RyaWN0aW9uTW9kZSA9IHt9KSk7XHJcbnZhciBSZW5kZXJMaXN0RGF0YU9wdGlvbnM7XHJcbihmdW5jdGlvbiAoUmVuZGVyTGlzdERhdGFPcHRpb25zKSB7XHJcbiAgICBSZW5kZXJMaXN0RGF0YU9wdGlvbnNbUmVuZGVyTGlzdERhdGFPcHRpb25zW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICBSZW5kZXJMaXN0RGF0YU9wdGlvbnNbUmVuZGVyTGlzdERhdGFPcHRpb25zW1wiQ29udGV4dEluZm9cIl0gPSAxXSA9IFwiQ29udGV4dEluZm9cIjtcclxuICAgIFJlbmRlckxpc3REYXRhT3B0aW9uc1tSZW5kZXJMaXN0RGF0YU9wdGlvbnNbXCJMaXN0RGF0YVwiXSA9IDJdID0gXCJMaXN0RGF0YVwiO1xyXG4gICAgUmVuZGVyTGlzdERhdGFPcHRpb25zW1JlbmRlckxpc3REYXRhT3B0aW9uc1tcIkxpc3RTY2hlbWFcIl0gPSA0XSA9IFwiTGlzdFNjaGVtYVwiO1xyXG4gICAgUmVuZGVyTGlzdERhdGFPcHRpb25zW1JlbmRlckxpc3REYXRhT3B0aW9uc1tcIk1lbnVWaWV3XCJdID0gOF0gPSBcIk1lbnVWaWV3XCI7XHJcbiAgICBSZW5kZXJMaXN0RGF0YU9wdGlvbnNbUmVuZGVyTGlzdERhdGFPcHRpb25zW1wiTGlzdENvbnRlbnRUeXBlXCJdID0gMTZdID0gXCJMaXN0Q29udGVudFR5cGVcIjtcclxuICAgIFJlbmRlckxpc3REYXRhT3B0aW9uc1tSZW5kZXJMaXN0RGF0YU9wdGlvbnNbXCJGaWxlU3lzdGVtSXRlbUlkXCJdID0gMzJdID0gXCJGaWxlU3lzdGVtSXRlbUlkXCI7XHJcbiAgICBSZW5kZXJMaXN0RGF0YU9wdGlvbnNbUmVuZGVyTGlzdERhdGFPcHRpb25zW1wiQ2xpZW50Rm9ybVNjaGVtYVwiXSA9IDY0XSA9IFwiQ2xpZW50Rm9ybVNjaGVtYVwiO1xyXG4gICAgUmVuZGVyTGlzdERhdGFPcHRpb25zW1JlbmRlckxpc3REYXRhT3B0aW9uc1tcIlF1aWNrTGF1bmNoXCJdID0gMTI4XSA9IFwiUXVpY2tMYXVuY2hcIjtcclxuICAgIFJlbmRlckxpc3REYXRhT3B0aW9uc1tSZW5kZXJMaXN0RGF0YU9wdGlvbnNbXCJTcG90bGlnaHRcIl0gPSAyNTZdID0gXCJTcG90bGlnaHRcIjtcclxuICAgIFJlbmRlckxpc3REYXRhT3B0aW9uc1tSZW5kZXJMaXN0RGF0YU9wdGlvbnNbXCJWaXN1YWxpemF0aW9uXCJdID0gNTEyXSA9IFwiVmlzdWFsaXphdGlvblwiO1xyXG4gICAgUmVuZGVyTGlzdERhdGFPcHRpb25zW1JlbmRlckxpc3REYXRhT3B0aW9uc1tcIlZpZXdNZXRhZGF0YVwiXSA9IDEwMjRdID0gXCJWaWV3TWV0YWRhdGFcIjtcclxuICAgIFJlbmRlckxpc3REYXRhT3B0aW9uc1tSZW5kZXJMaXN0RGF0YU9wdGlvbnNbXCJEaXNhYmxlQXV0b0h5cGVybGlua1wiXSA9IDIwNDhdID0gXCJEaXNhYmxlQXV0b0h5cGVybGlua1wiO1xyXG4gICAgUmVuZGVyTGlzdERhdGFPcHRpb25zW1JlbmRlckxpc3REYXRhT3B0aW9uc1tcIkVuYWJsZU1lZGlhVEFVcmxzXCJdID0gNDA5Nl0gPSBcIkVuYWJsZU1lZGlhVEFVcmxzXCI7XHJcbiAgICBSZW5kZXJMaXN0RGF0YU9wdGlvbnNbUmVuZGVyTGlzdERhdGFPcHRpb25zW1wiUGFyZW50SW5mb1wiXSA9IDgxOTJdID0gXCJQYXJlbnRJbmZvXCI7XHJcbiAgICBSZW5kZXJMaXN0RGF0YU9wdGlvbnNbUmVuZGVyTGlzdERhdGFPcHRpb25zW1wiUGFnZUNvbnRleHRJbmZvXCJdID0gMTYzODRdID0gXCJQYWdlQ29udGV4dEluZm9cIjtcclxuICAgIFJlbmRlckxpc3REYXRhT3B0aW9uc1tSZW5kZXJMaXN0RGF0YU9wdGlvbnNbXCJDbGllbnRTaWRlQ29tcG9uZW50TWFuaWZlc3RcIl0gPSAzMjc2OF0gPSBcIkNsaWVudFNpZGVDb21wb25lbnRNYW5pZmVzdFwiO1xyXG59KShSZW5kZXJMaXN0RGF0YU9wdGlvbnMgfHwgKFJlbmRlckxpc3REYXRhT3B0aW9ucyA9IHt9KSk7XHJcbnZhciBGaWVsZFVzZXJTZWxlY3Rpb25Nb2RlO1xyXG4oZnVuY3Rpb24gKEZpZWxkVXNlclNlbGVjdGlvbk1vZGUpIHtcclxuICAgIEZpZWxkVXNlclNlbGVjdGlvbk1vZGVbRmllbGRVc2VyU2VsZWN0aW9uTW9kZVtcIlBlb3BsZUFuZEdyb3Vwc1wiXSA9IDFdID0gXCJQZW9wbGVBbmRHcm91cHNcIjtcclxuICAgIEZpZWxkVXNlclNlbGVjdGlvbk1vZGVbRmllbGRVc2VyU2VsZWN0aW9uTW9kZVtcIlBlb3BsZU9ubHlcIl0gPSAwXSA9IFwiUGVvcGxlT25seVwiO1xyXG59KShGaWVsZFVzZXJTZWxlY3Rpb25Nb2RlIHx8IChGaWVsZFVzZXJTZWxlY3Rpb25Nb2RlID0ge30pKTtcclxudmFyIENob2ljZUZpZWxkRm9ybWF0VHlwZTtcclxuKGZ1bmN0aW9uIChDaG9pY2VGaWVsZEZvcm1hdFR5cGUpIHtcclxuICAgIENob2ljZUZpZWxkRm9ybWF0VHlwZVtDaG9pY2VGaWVsZEZvcm1hdFR5cGVbXCJEcm9wZG93blwiXSA9IDBdID0gXCJEcm9wZG93blwiO1xyXG4gICAgQ2hvaWNlRmllbGRGb3JtYXRUeXBlW0Nob2ljZUZpZWxkRm9ybWF0VHlwZVtcIlJhZGlvQnV0dG9uc1wiXSA9IDFdID0gXCJSYWRpb0J1dHRvbnNcIjtcclxufSkoQ2hvaWNlRmllbGRGb3JtYXRUeXBlIHx8IChDaG9pY2VGaWVsZEZvcm1hdFR5cGUgPSB7fSkpO1xyXG4vKipcclxuICogU3BlY2lmaWVzIHRoZSBvcmlnaW5hdGluZyB6b25lIG9mIGEgcmVxdWVzdCByZWNlaXZlZC5cclxuICovXHJcbnZhciBVcmxab25lO1xyXG4oZnVuY3Rpb24gKFVybFpvbmUpIHtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHRoZSBkZWZhdWx0IHpvbmUgdXNlZCBmb3IgcmVxdWVzdHMgdW5sZXNzIGFub3RoZXIgem9uZSBpcyBzcGVjaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIFVybFpvbmVbVXJsWm9uZVtcIkRlZmF1bHRab25lXCJdID0gMF0gPSBcIkRlZmF1bHRab25lXCI7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyBhbiBpbnRyYW5ldCB6b25lLlxyXG4gICAgICovXHJcbiAgICBVcmxab25lW1VybFpvbmVbXCJJbnRyYW5ldFwiXSA9IDFdID0gXCJJbnRyYW5ldFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgYW4gSW50ZXJuZXQgem9uZS5cclxuICAgICAqL1xyXG4gICAgVXJsWm9uZVtVcmxab25lW1wiSW50ZXJuZXRcIl0gPSAyXSA9IFwiSW50ZXJuZXRcIjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIGEgY3VzdG9tIHpvbmUuXHJcbiAgICAgKi9cclxuICAgIFVybFpvbmVbVXJsWm9uZVtcIkN1c3RvbVwiXSA9IDNdID0gXCJDdXN0b21cIjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIGFuIGV4dHJhbmV0IHpvbmUuXHJcbiAgICAgKi9cclxuICAgIFVybFpvbmVbVXJsWm9uZVtcIkV4dHJhbmV0XCJdID0gNF0gPSBcIkV4dHJhbmV0XCI7XHJcbn0pKFVybFpvbmUgfHwgKFVybFpvbmUgPSB7fSkpO1xuXG52YXIgU2hhcmVQb2ludFF1ZXJ5YWJsZVNlY3VyYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaGFyZVBvaW50UXVlcnlhYmxlU2VjdXJhYmxlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2hhcmVQb2ludFF1ZXJ5YWJsZVNlY3VyYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hhcmVQb2ludFF1ZXJ5YWJsZVNlY3VyYWJsZS5wcm90b3R5cGUsIFwicm9sZUFzc2lnbm1lbnRzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBzZXQgb2Ygcm9sZSBhc3NpZ25tZW50cyBmb3IgdGhpcyBpdGVtXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSb2xlQXNzaWdubWVudHModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hhcmVQb2ludFF1ZXJ5YWJsZVNlY3VyYWJsZS5wcm90b3R5cGUsIFwiZmlyc3RVbmlxdWVBbmNlc3RvclNlY3VyYWJsZU9iamVjdFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY2xvc2VzdCBzZWN1cmFibGUgdXAgdGhlIHNlY3VyaXR5IGhpZXJhcmNoeSB3aG9zZSBwZXJtaXNzaW9ucyBhcmUgYXBwbGllZCB0byB0aGlzIGxpc3QgaXRlbVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKHRoaXMsIFwiRmlyc3RVbmlxdWVBbmNlc3RvclNlY3VyYWJsZU9iamVjdFwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZWZmZWN0aXZlIHBlcm1pc3Npb25zIGZvciB0aGUgdXNlciBzdXBwbGllZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2dpbk5hbWUgVGhlIGNsYWltcyB1c2VybmFtZSBmb3IgdGhlIHVzZXIgKGV4OiBpOjAjLmZ8bWVtYmVyc2hpcHx1c2VyQGRvbWFpbi5jb20pXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTZWN1cmFibGUucHJvdG90eXBlLmdldFVzZXJFZmZlY3RpdmVQZXJtaXNzaW9ucyA9IGZ1bmN0aW9uIChsb2dpbk5hbWUpIHtcclxuICAgICAgICB2YXIgcSA9IHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZSwgXCJnZXRVc2VyRWZmZWN0aXZlUGVybWlzc2lvbnMoQHVzZXIpXCIpO1xyXG4gICAgICAgIHEucXVlcnkuc2V0KFwiQHVzZXJcIiwgXCInXCIgKyBlbmNvZGVVUklDb21wb25lbnQobG9naW5OYW1lKSArIFwiJ1wiKTtcclxuICAgICAgICByZXR1cm4gcS5nZXQoKS50aGVuKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSB2ZXJib3NlIG1vZGVcclxuICAgICAgICAgICAgcmV0dXJuIGhPUChyLCBcIkdldFVzZXJFZmZlY3RpdmVQZXJtaXNzaW9uc1wiKSA/IHIuR2V0VXNlckVmZmVjdGl2ZVBlcm1pc3Npb25zIDogcjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGVmZmVjdGl2ZSBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnQgdXNlclxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlU2VjdXJhYmxlLnByb3RvdHlwZS5nZXRDdXJyZW50VXNlckVmZmVjdGl2ZVBlcm1pc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gcmVtb3ZlIG5lZWQgdG8gcmVmZXJlbmNlIFdlYiBoZXJlLCB3aGljaCBjcmVhdGVkIGEgY2lyY3VsYXIgYnVpbGQgaXNzdWVcclxuICAgICAgICB2YXIgdyA9IG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UoXCJfYXBpL3dlYlwiLCBcImN1cnJlbnR1c2VyXCIpO1xyXG4gICAgICAgIHJldHVybiB3LnNlbGVjdChcIkxvZ2luTmFtZVwiKS5nZXQoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRVc2VyRWZmZWN0aXZlUGVybWlzc2lvbnModXNlci5Mb2dpbk5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQnJlYWtzIHRoZSBzZWN1cml0eSBpbmhlcml0YW5jZSBhdCB0aGlzIGxldmVsIG9wdGluYWxseSBjb3B5aW5nIHBlcm1pc3Npb25zIGFuZCBjbGVhcmluZyBzdWJzY29wZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29weVJvbGVBc3NpZ25tZW50cyBJZiB0cnVlIHRoZSBwZXJtaXNzaW9ucyBhcmUgY29waWVkIGZyb20gdGhlIGN1cnJlbnQgcGFyZW50IHNjb3BlXHJcbiAgICAgKiBAcGFyYW0gY2xlYXJTdWJzY29wZXMgT3B0aW9uYWwuIHRydWUgdG8gbWFrZSBhbGwgY2hpbGQgc2VjdXJhYmxlIG9iamVjdHMgaW5oZXJpdCByb2xlIGFzc2lnbm1lbnRzIGZyb20gdGhlIGN1cnJlbnQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTZWN1cmFibGUucHJvdG90eXBlLmJyZWFrUm9sZUluaGVyaXRhbmNlID0gZnVuY3Rpb24gKGNvcHlSb2xlQXNzaWdubWVudHMsIGNsZWFyU3Vic2NvcGVzKSB7XHJcbiAgICAgICAgaWYgKGNvcHlSb2xlQXNzaWdubWVudHMgPT09IHZvaWQgMCkgeyBjb3B5Um9sZUFzc2lnbm1lbnRzID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAoY2xlYXJTdWJzY29wZXMgPT09IHZvaWQgMCkgeyBjbGVhclN1YnNjb3BlcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZVNlY3VyYWJsZSwgXCJicmVha3JvbGVpbmhlcml0YW5jZShjb3B5cm9sZWFzc2lnbm1lbnRzPVwiICsgY29weVJvbGVBc3NpZ25tZW50cyArIFwiLCBjbGVhcnN1YnNjb3Blcz1cIiArIGNsZWFyU3Vic2NvcGVzICsgXCIpXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBsb2NhbCByb2xlIGFzc2lnbm1lbnRzIHNvIHRoYXQgaXQgcmUtaW5oZXJpdCByb2xlIGFzc2lnbm1lbnRzIGZyb20gdGhlIHBhcmVudCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlU2VjdXJhYmxlLnByb3RvdHlwZS5yZXNldFJvbGVJbmhlcml0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTaGFyZVBvaW50UXVlcnlhYmxlU2VjdXJhYmxlLCBcInJlc2V0cm9sZWluaGVyaXRhbmNlXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdXNlciBoYXMgdGhlIGFwcHJvcHJpYXRlIHBlcm1pc3Npb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvZ2luTmFtZSBUaGUgdXNlciB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gVGhlIHBlcm1pc3Npb24gYmVpbmcgY2hlY2tlZFxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlU2VjdXJhYmxlLnByb3RvdHlwZS51c2VySGFzUGVybWlzc2lvbnMgPSBmdW5jdGlvbiAobG9naW5OYW1lLCBwZXJtaXNzaW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVc2VyRWZmZWN0aXZlUGVybWlzc2lvbnMobG9naW5OYW1lKS50aGVuKGZ1bmN0aW9uIChwZXJtcykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuaGFzUGVybWlzc2lvbnMocGVybXMsIHBlcm1pc3Npb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCB1c2VyIGhhcyB0aGUgcmVxdWVzdGVkIHBlcm1pc3Npb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gVGhlIHBlcm1pc3Npb24gd2Ugd2lzaCB0byBjaGVja1xyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlU2VjdXJhYmxlLnByb3RvdHlwZS5jdXJyZW50VXNlckhhc1Blcm1pc3Npb25zID0gZnVuY3Rpb24gKHBlcm1pc3Npb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRVc2VyRWZmZWN0aXZlUGVybWlzc2lvbnMoKS50aGVuKGZ1bmN0aW9uIChwZXJtcykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuaGFzUGVybWlzc2lvbnMocGVybXMsIHBlcm1pc3Npb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGFrZW4gZnJvbSBzcC5qcywgY2hlY2tzIHRoZSBzdXBwbGllZCBwZXJtaXNzaW9ucyBhZ2FpbnN0IHRoZSBtYXNrXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBzZWN1cml0eSBwcmluY2lwYWwncyBwZXJtaXNzaW9ucyBvbiB0aGUgZ2l2ZW4gb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gcGVybSBUaGUgcGVybWlzc2lvbiBjaGVja2VkIGFnYWluc3QgdGhlIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2UgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTZWN1cmFibGUucHJvdG90eXBlLmhhc1Blcm1pc3Npb25zID0gZnVuY3Rpb24gKHZhbHVlLCBwZXJtKSB7XHJcbiAgICAgICAgaWYgKCFwZXJtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGVybSA9PT0gUGVybWlzc2lvbktpbmQuRnVsbE1hc2spIHtcclxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZS5IaWdoICYgMzI3NjcpID09PSAzMjc2NyAmJiB2YWx1ZS5Mb3cgPT09IDY1NTM1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBwZXJtID0gcGVybSAtIDE7XHJcbiAgICAgICAgdmFyIG51bSA9IDE7XHJcbiAgICAgICAgaWYgKHBlcm0gPj0gMCAmJiBwZXJtIDwgMzIpIHtcclxuICAgICAgICAgICAgbnVtID0gbnVtIDw8IHBlcm07XHJcbiAgICAgICAgICAgIHJldHVybiAwICE9PSAodmFsdWUuTG93ICYgbnVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGVybSA+PSAzMiAmJiBwZXJtIDwgNjQpIHtcclxuICAgICAgICAgICAgbnVtID0gbnVtIDw8IHBlcm0gLSAzMjtcclxuICAgICAgICAgICAgcmV0dXJuIDAgIT09ICh2YWx1ZS5IaWdoICYgbnVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTaGFyZVBvaW50UXVlcnlhYmxlU2VjdXJhYmxlO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xuXG4vKipcclxuICogSW50ZXJuYWwgaGVscGVyIGNsYXNzIHVzZWQgdG8gYXVnbWVudCBjbGFzc2VzIHRvIGluY2x1ZGUgc2hhcmluZyBmdW5jdGlvbmFsaXR5XHJcbiAqL1xyXG52YXIgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBzaGFyaW5nIGxpbmsgZm9yIHRoZSBzdXBwbGllZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIGxpbmsgdG8gc2hhcmVcclxuICAgICAqIEBwYXJhbSBleHBpcmF0aW9uIFRoZSBvcHRpb25hbCBleHBpcmF0aW9uIGZvciB0aGlzIGxpbmtcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZS5wcm90b3R5cGUuZ2V0U2hhcmVMaW5rID0gZnVuY3Rpb24gKGtpbmQsIGV4cGlyYXRpb24pIHtcclxuICAgICAgICBpZiAoZXhwaXJhdGlvbiA9PT0gdm9pZCAwKSB7IGV4cGlyYXRpb24gPSBudWxsOyB9XHJcbiAgICAgICAgLy8gZGF0ZSBuZWVkcyB0byBiZSBhbiBJU08gc3RyaW5nIG9yIG51bGxcclxuICAgICAgICB2YXIgZXhwU3RyaW5nID0gZXhwaXJhdGlvbiAhPT0gbnVsbCA/IGV4cGlyYXRpb24udG9JU09TdHJpbmcoKSA6IG51bGw7XHJcbiAgICAgICAgLy8gY2xvbmUgdXNpbmcgdGhlIGZhY3RvcnkgYW5kIHNlbmQgdGhlIHJlcXVlc3RcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlLCBcInNoYXJlTGlua1wiKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyh7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTGluazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBlbWFpbERhdGE6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJhdGlvbjogZXhwU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rS2luZDoga2luZCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaGFyZXMgdGhpcyBpbnN0YW5jZSB3aXRoIHRoZSBzdXBwbGllZCB1c2Vyc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2dpbk5hbWVzIFJlc29sdmVkIGxvZ2luIG5hbWVzIHRvIHNoYXJlXHJcbiAgICAgKiBAcGFyYW0gcm9sZSBUaGUgcm9sZVxyXG4gICAgICogQHBhcmFtIHJlcXVpcmVTaWduaW4gVHJ1ZSB0byByZXF1aXJlIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICogQHBhcmFtIHByb3BhZ2F0ZUFjbCBUcnVlIHRvIGFwcGx5IHRoaXMgc2hhcmUgdG8gYWxsIGNoaWxkcmVuXHJcbiAgICAgKiBAcGFyYW0gZW1haWxEYXRhIElmIHN1cHBsaWVkIGFuIGVtYWlsIHdpbGwgYmUgc2VudCB3aXRoIHRoZSBpbmRpY2F0ZWQgcHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlLnByb3RvdHlwZS5zaGFyZVdpdGggPSBmdW5jdGlvbiAobG9naW5OYW1lcywgcm9sZSwgcmVxdWlyZVNpZ25pbiwgcHJvcGFnYXRlQWNsLCBlbWFpbERhdGEpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChyZXF1aXJlU2lnbmluID09PSB2b2lkIDApIHsgcmVxdWlyZVNpZ25pbiA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKHByb3BhZ2F0ZUFjbCA9PT0gdm9pZCAwKSB7IHByb3BhZ2F0ZUFjbCA9IGZhbHNlOyB9XHJcbiAgICAgICAgLy8gaGFuZGxlIHRoZSBtdWx0aXBsZSBpbnB1dCB0eXBlc1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsb2dpbk5hbWVzKSkge1xyXG4gICAgICAgICAgICBsb2dpbk5hbWVzID0gW2xvZ2luTmFtZXNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdXNlclN0ciA9IGpzUyhsb2dpbk5hbWVzLm1hcChmdW5jdGlvbiAobG9naW4pIHsgcmV0dXJuIHsgS2V5OiBsb2dpbiB9OyB9KSk7XHJcbiAgICAgICAgdmFyIHJvbGVGaWx0ZXIgPSByb2xlID09PSBTaGFyaW5nUm9sZS5FZGl0ID8gUm9sZVR5cGUuQ29udHJpYnV0b3IgOiBSb2xlVHlwZS5SZWFkZXI7XHJcbiAgICAgICAgLy8gc3RhcnQgYnkgbG9va2luZyB1cCB0aGUgcm9sZSBkZWZpbml0aW9uIGlkIHdlIG5lZWQgdG8gc2V0IHRoZSByb2xlVmFsdWVcclxuICAgICAgICAvLyByZW1vdmUgbmVlZCB0byByZWZlcmVuY2UgV2ViIGhlcmUsIHdoaWNoIGNyZWF0ZWQgYSBjaXJjdWxhciBidWlsZCBpc3N1ZVxyXG4gICAgICAgIHZhciB3ID0gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKFwiX2FwaS93ZWJcIiwgXCJyb2xlZGVmaW5pdGlvbnNcIik7XHJcbiAgICAgICAgcmV0dXJuIHcuc2VsZWN0KFwiSWRcIikuZmlsdGVyKFwiUm9sZVR5cGVLaW5kIGVxIFwiICsgcm9sZUZpbHRlcikuZ2V0KCkudGhlbihmdW5jdGlvbiAoZGVmKSB7XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZWYpIHx8IGRlZi5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBsb2NhdGUgYSByb2xlIGRlZmludGlvbiB3aXRoIFJvbGVUeXBlS2luZCBcIiArIHJvbGVGaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwb3N0Qm9keSA9IHtcclxuICAgICAgICAgICAgICAgIGluY2x1ZGVBbm9ueW1vdXNMaW5rSW5FbWFpbDogcmVxdWlyZVNpZ25pbixcclxuICAgICAgICAgICAgICAgIHBlb3BsZVBpY2tlcklucHV0OiB1c2VyU3RyLFxyXG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlQWNsOiBwcm9wYWdhdGVBY2wsXHJcbiAgICAgICAgICAgICAgICByb2xlVmFsdWU6IFwicm9sZTpcIiArIGRlZlswXS5JZCxcclxuICAgICAgICAgICAgICAgIHVzZVNpbXBsaWZpZWRSb2xlczogdHJ1ZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGVtYWlsRGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0Qm9keSA9IGV4dGVuZChwb3N0Qm9keSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsQm9keTogZW1haWxEYXRhLmJvZHksXHJcbiAgICAgICAgICAgICAgICAgICAgZW1haWxTdWJqZWN0OiBlbWFpbERhdGEuc3ViamVjdCAhPT0gdW5kZWZpbmVkID8gZW1haWxEYXRhLnN1YmplY3QgOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRFbWFpbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jbG9uZShTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlLCBcInNoYXJlT2JqZWN0XCIpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgICAgIGJvZHk6IGpzUyhwb3N0Qm9keSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2hhcmVzIGFuIG9iamVjdCBiYXNlZCBvbiB0aGUgc3VwcGxpZWQgb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBzZXQgb2Ygb3B0aW9ucyB0byBzZW5kIHRvIHRoZSBTaGFyZU9iamVjdCBtZXRob2RcclxuICAgICAqIEBwYXJhbSBieXBhc3MgSWYgdHJ1ZSBhbnkgcHJvY2Vzc2luZyBpcyBza2lwcGVkIGFuZCB0aGUgb3B0aW9ucyBhcmUgc2VudCBkaXJlY3RseSB0byB0aGUgU2hhcmVPYmplY3QgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUucHJvdG90eXBlLnNoYXJlT2JqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGJ5cGFzcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGJ5cGFzcyA9PT0gdm9pZCAwKSB7IGJ5cGFzcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGJ5cGFzcykge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgYnlwYXNzIGZsYWcgaXMgc2V0IHNlbmQgdGhlIHN1cHBsaWVkIHBhcmFtZXRlcnMgZGlyZWN0bHkgdG8gdGhlIHNlcnZpY2VcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFNoYXJlT2JqZWN0UmVxdWVzdChvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXh0ZW5kIG91ciBvcHRpb25zIHdpdGggc29tZSBkZWZhdWx0c1xyXG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQob3B0aW9ucywge1xyXG4gICAgICAgICAgICBncm91cDogbnVsbCxcclxuICAgICAgICAgICAgaW5jbHVkZUFub255bW91c0xpbmtJbkVtYWlsOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJvcGFnYXRlQWNsOiBmYWxzZSxcclxuICAgICAgICAgICAgdXNlU2ltcGxpZmllZFJvbGVzOiB0cnVlLFxyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJvbGVWYWx1ZShvcHRpb25zLnJvbGUsIG9wdGlvbnMuZ3JvdXApLnRoZW4oZnVuY3Rpb24gKHJvbGVWYWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgdGhlIG11bHRpcGxlIGlucHV0IHR5cGVzXHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmxvZ2luTmFtZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvZ2luTmFtZXMgPSBbb3B0aW9ucy5sb2dpbk5hbWVzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdXNlclN0ciA9IGpzUyhvcHRpb25zLmxvZ2luTmFtZXMubWFwKGZ1bmN0aW9uIChsb2dpbikgeyByZXR1cm4geyBLZXk6IGxvZ2luIH07IH0pKTtcclxuICAgICAgICAgICAgdmFyIHBvc3RCb2R5ID0ge1xyXG4gICAgICAgICAgICAgICAgcGVvcGxlUGlja2VySW5wdXQ6IHVzZXJTdHIsXHJcbiAgICAgICAgICAgICAgICByb2xlVmFsdWU6IHJvbGVWYWx1ZSxcclxuICAgICAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVtYWlsRGF0YSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuZW1haWxEYXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0Qm9keSA9IGV4dGVuZChwb3N0Qm9keSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsQm9keTogb3B0aW9ucy5lbWFpbERhdGEuYm9keSxcclxuICAgICAgICAgICAgICAgICAgICBlbWFpbFN1YmplY3Q6IG9wdGlvbnMuZW1haWxEYXRhLnN1YmplY3QgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZW1haWxEYXRhLnN1YmplY3QgOiBcIlNoYXJlZCB3aXRoIHlvdS5cIixcclxuICAgICAgICAgICAgICAgICAgICBzZW5kRW1haWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZFNoYXJlT2JqZWN0UmVxdWVzdChwb3N0Qm9keSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyB0aGUgd2ViJ3MgVW5zaGFyZU9iamVjdCBtZXRob2RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSB1cmwgb2YgdGhlIG9iamVjdCB0byB1bnNoYXJlXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUucHJvdG90eXBlLnVuc2hhcmVPYmplY3RXZWIgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZSwgXCJ1bnNoYXJlT2JqZWN0XCIpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHtcclxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBQZXJtaXNzaW9ucyBvbiB0aGUgbGlzdCBvZiBVc2VycyBhbmQgcmV0dXJucyBiYWNrIHJvbGUgdGhlIHVzZXJzIGhhdmUgb24gdGhlIEl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlY2lwaWVudHMgVGhlIGFycmF5IG9mIEVudGl0aWVzIGZvciB3aGljaCBQZXJtaXNzaW9ucyBuZWVkIHRvIGJlIGNoZWNrZWQuXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUucHJvdG90eXBlLmNoZWNrUGVybWlzc2lvbnMgPSBmdW5jdGlvbiAocmVjaXBpZW50cykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUsIFwiY2hlY2tQZXJtaXNzaW9uc1wiKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyh7XHJcbiAgICAgICAgICAgICAgICByZWNpcGllbnRzOiByZWNpcGllbnRzLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBTaGFyaW5nIEluZm9ybWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBTaGFyaW5nSW5mb3JtYXRpb25SZXF1ZXN0IE9iamVjdC5cclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZS5wcm90b3R5cGUuZ2V0U2hhcmluZ0luZm9ybWF0aW9uID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcclxuICAgICAgICBpZiAocmVxdWVzdCA9PT0gdm9pZCAwKSB7IHJlcXVlc3QgPSBudWxsOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZSwgXCJnZXRTaGFyaW5nSW5mb3JtYXRpb25cIikucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1Moe1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzaGFyaW5nIHNldHRpbmdzIG9mIGFuIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZVNpbXBsaWZpZWRSb2xlcyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIHNpbXBsaWZpZWQgcm9sZXMuXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUucHJvdG90eXBlLmdldE9iamVjdFNoYXJpbmdTZXR0aW5ncyA9IGZ1bmN0aW9uICh1c2VTaW1wbGlmaWVkUm9sZXMpIHtcclxuICAgICAgICBpZiAodXNlU2ltcGxpZmllZFJvbGVzID09PSB2b2lkIDApIHsgdXNlU2ltcGxpZmllZFJvbGVzID0gdHJ1ZTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUsIFwiZ2V0T2JqZWN0U2hhcmluZ1NldHRpbmdzXCIpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHtcclxuICAgICAgICAgICAgICAgIHVzZVNpbXBsaWZpZWRSb2xlczogdXNlU2ltcGxpZmllZFJvbGVzLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVuc2hhcmVzIHRoaXMgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUucHJvdG90eXBlLnVuc2hhcmVPYmplY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZSwgXCJ1bnNoYXJlT2JqZWN0XCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgbGluayBieSB0eXBlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtpbmQgRGVsZXRlcyBhIHNoYXJpbmcgbGluayBieSB0aGUga2luZCBvZiBsaW5rXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUucHJvdG90eXBlLmRlbGV0ZUxpbmtCeUtpbmQgPSBmdW5jdGlvbiAoa2luZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUsIFwiZGVsZXRlTGlua0J5S2luZFwiKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyh7IGxpbmtLaW5kOiBraW5kIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpbmsgdG8gdGhlIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgbGluayB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHBhcmFtIHNoYXJlSWRcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZS5wcm90b3R5cGUudW5zaGFyZUxpbmsgPSBmdW5jdGlvbiAoa2luZCwgc2hhcmVJZCkge1xyXG4gICAgICAgIGlmIChzaGFyZUlkID09PSB2b2lkIDApIHsgc2hhcmVJZCA9IFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCI7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlLCBcInVuc2hhcmVMaW5rXCIpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHsgbGlua0tpbmQ6IGtpbmQsIHNoYXJlSWQ6IHNoYXJlSWQgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSByb2xlVmFsdWUgc3RyaW5nIHVzZWQgaW4gdGhlIHNoYXJpbmcgcXVlcnlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcm9sZSBUaGUgU2hhcmluZyBSb2xlXHJcbiAgICAgKiBAcGFyYW0gZ3JvdXAgVGhlIEdyb3VwIHR5cGVcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZS5wcm90b3R5cGUuZ2V0Um9sZVZhbHVlID0gZnVuY3Rpb24gKHJvbGUsIGdyb3VwKSB7XHJcbiAgICAgICAgLy8gd2Ugd2lsbCBnaXZlIGdyb3VwIHByZWNlZGVuY2UsIGJlY2F1c2Ugd2UgaGFkIHRvIG1ha2UgYSBjaG9pY2VcclxuICAgICAgICBpZiAoZ3JvdXAgIT09IHVuZGVmaW5lZCAmJiBncm91cCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJvbGVUeXBlLkNvbnRyaWJ1dG9yOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBuZWVkIHRvIHJlZmVyZW5jZSBXZWIgaGVyZSwgd2hpY2ggY3JlYXRlZCBhIGNpcmN1bGFyIGJ1aWxkIGlzc3VlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lbWJlckdyb3VwID0gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZShcIl9hcGkvd2ViXCIsIFwiYXNzb2NpYXRlZG1lbWJlcmdyb3VwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXJHcm91cC5zZWxlY3QoXCJJZFwiKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChnKSB7IHJldHVybiBcImdyb3VwOiBcIiArIGcuSWQ7IH0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb2xlVHlwZS5SZWFkZXI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJvbGVUeXBlLkd1ZXN0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBuZWVkIHRvIHJlZmVyZW5jZSBXZWIgaGVyZSwgd2hpY2ggY3JlYXRlZCBhIGNpcmN1bGFyIGJ1aWxkIGlzc3VlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2l0b3JHcm91cCA9IG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UoXCJfYXBpL3dlYlwiLCBcImFzc29jaWF0ZWR2aXNpdG9yZ3JvdXBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3JHcm91cC5zZWxlY3QoXCJJZFwiKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChnKSB7IHJldHVybiBcImdyb3VwOiBcIiArIGcuSWQ7IH0pO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlcm1pbmUgcm9sZSB2YWx1ZSBmb3Igc3VwcGxpZWQgdmFsdWUuIENvbnRyaWJ1dG9yLCBSZWFkZXIsIGFuZCBHdWVzdCBhcmUgc3VwcG9ydGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcm9sZUZpbHRlciA9IHJvbGUgPT09IFNoYXJpbmdSb2xlLkVkaXQgPyBSb2xlVHlwZS5Db250cmlidXRvciA6IFJvbGVUeXBlLlJlYWRlcjtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIG5lZWQgdG8gcmVmZXJlbmNlIFdlYiBoZXJlLCB3aGljaCBjcmVhdGVkIGEgY2lyY3VsYXIgYnVpbGQgaXNzdWVcclxuICAgICAgICAgICAgdmFyIHJvbGVEZWZzID0gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKFwiX2FwaS93ZWJcIiwgXCJyb2xlZGVmaW5pdGlvbnNcIik7XHJcbiAgICAgICAgICAgIHJldHVybiByb2xlRGVmcy5zZWxlY3QoXCJJZFwiKS50b3AoMSkuZmlsdGVyKFwiUm9sZVR5cGVLaW5kIGVxIFwiICsgcm9sZUZpbHRlcikuZ2V0KCkudGhlbihmdW5jdGlvbiAoZGVmKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBsb2NhdGUgYXNzb2NpYXRlZCByb2xlIGRlZmluaXRpb24gZm9yIHN1cHBsaWVkIHJvbGUuIEVkaXQgYW5kIFZpZXcgYXJlIHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBcInJvbGU6IFwiICsgZGVmWzBdLklkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZS5wcm90b3R5cGUuZ2V0U2hhcmVPYmplY3RXZWIgPSBmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKGV4dHJhY3RXZWJVcmwoY2FuZGlkYXRlKSwgXCIvX2FwaS9TUC5XZWIuU2hhcmVPYmplY3RcIikpO1xyXG4gICAgfTtcclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUucHJvdG90eXBlLnNlbmRTaGFyZU9iamVjdFJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNoYXJlT2JqZWN0V2ViKHRoaXMudG9VcmwoKSkudGhlbihmdW5jdGlvbiAod2ViKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWIuZXhwYW5kKFwiVXNlcnNXaXRoQWNjZXNzUmVxdWVzdHNcIiwgXCJHcm91cHNTaGFyZWRXaXRoXCIpLmFzKFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgICAgIGJvZHk6IGpzUyhvcHRpb25zKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGU7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZSkpO1xyXG52YXIgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZVdlYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlV2ViLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZVdlYigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNoYXJlcyB0aGlzIHdlYiB3aXRoIHRoZSBzdXBwbGllZCB1c2Vyc1xyXG4gICAgICogQHBhcmFtIGxvZ2luTmFtZXMgVGhlIHJlc29sdmVkIGxvZ2luIG5hbWVzIHRvIHNoYXJlXHJcbiAgICAgKiBAcGFyYW0gcm9sZSBUaGUgcm9sZSB0byBzaGFyZSB0aGlzIHdlYlxyXG4gICAgICogQHBhcmFtIGVtYWlsRGF0YSBPcHRpb25hbCBlbWFpbCBkYXRhXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVXZWIucHJvdG90eXBlLnNoYXJlV2l0aCA9IGZ1bmN0aW9uIChsb2dpbk5hbWVzLCByb2xlLCBlbWFpbERhdGEpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChyb2xlID09PSB2b2lkIDApIHsgcm9sZSA9IFNoYXJpbmdSb2xlLlZpZXc7IH1cclxuICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IHRoaXMuYWRkQmF0Y2hEZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgLy8gcmVtb3ZlIG5lZWQgdG8gcmVmZXJlbmNlIFdlYiBoZXJlLCB3aGljaCBjcmVhdGVkIGEgY2lyY3VsYXIgYnVpbGQgaXNzdWVcclxuICAgICAgICB2YXIgd2ViID0gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZShleHRyYWN0V2ViVXJsKHRoaXMudG9VcmwoKSksIFwiL19hcGkvd2ViL3VybFwiKTtcclxuICAgICAgICByZXR1cm4gd2ViLmdldCgpLnRoZW4oZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICBkZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaGFyZU9iamVjdChjb21iaW5lKHVybCwgXCIvX2xheW91dHMvMTUvYWNsaW52LmFzcHg/Zm9yU2hhcmluZz0xJm1ieXBhc3M9MVwiKSwgbG9naW5OYW1lcywgcm9sZSwgZW1haWxEYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIHN0YXRpYyB3ZWIuU2hhcmVPYmplY3QgbWV0aG9kXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVybCBUaGUgdXJsIHRvIHNoYXJlXHJcbiAgICAgKiBAcGFyYW0gbG9naW5OYW1lcyBSZXNvbHZlZCBsb2dpbm5hbWVzIHN0cmluZ1tdIG9mIGEgc2luZ2xlIGxvZ2luIG5hbWUgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gcm9sZVZhbHVlIFJvbGUgdmFsdWVcclxuICAgICAqIEBwYXJhbSBlbWFpbERhdGEgT3B0aW9uYWwgZW1haWwgZGF0YVxyXG4gICAgICogQHBhcmFtIGdyb3VwSWQgT3B0aW9uYWwgZ3JvdXAgaWRcclxuICAgICAqIEBwYXJhbSBwcm9wYWdhdGVBY2xcclxuICAgICAqIEBwYXJhbSBpbmNsdWRlQW5vbnltb3VzTGlua0luRW1haWxcclxuICAgICAqIEBwYXJhbSB1c2VTaW1wbGlmaWVkUm9sZXNcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZVdlYi5wcm90b3R5cGUuc2hhcmVPYmplY3QgPSBmdW5jdGlvbiAodXJsLCBsb2dpbk5hbWVzLCByb2xlLCBlbWFpbERhdGEsIGdyb3VwLCBwcm9wYWdhdGVBY2wsIGluY2x1ZGVBbm9ueW1vdXNMaW5rSW5FbWFpbCwgdXNlU2ltcGxpZmllZFJvbGVzKSB7XHJcbiAgICAgICAgaWYgKHByb3BhZ2F0ZUFjbCA9PT0gdm9pZCAwKSB7IHByb3BhZ2F0ZUFjbCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGluY2x1ZGVBbm9ueW1vdXNMaW5rSW5FbWFpbCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVBbm9ueW1vdXNMaW5rSW5FbWFpbCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKHVzZVNpbXBsaWZpZWRSb2xlcyA9PT0gdm9pZCAwKSB7IHVzZVNpbXBsaWZpZWRSb2xlcyA9IHRydWU7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlLCBudWxsKS5zaGFyZU9iamVjdCh7XHJcbiAgICAgICAgICAgIGVtYWlsRGF0YTogZW1haWxEYXRhLFxyXG4gICAgICAgICAgICBncm91cDogZ3JvdXAsXHJcbiAgICAgICAgICAgIGluY2x1ZGVBbm9ueW1vdXNMaW5rSW5FbWFpbDogaW5jbHVkZUFub255bW91c0xpbmtJbkVtYWlsLFxyXG4gICAgICAgICAgICBsb2dpbk5hbWVzOiBsb2dpbk5hbWVzLFxyXG4gICAgICAgICAgICBwcm9wYWdhdGVBY2w6IHByb3BhZ2F0ZUFjbCxcclxuICAgICAgICAgICAgcm9sZTogcm9sZSxcclxuICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgIHVzZVNpbXBsaWZpZWRSb2xlczogdXNlU2ltcGxpZmllZFJvbGVzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3VwcGxpZXMgYSBtZXRob2QgdG8gcGFzcyBhbnkgc2V0IG9mIGFyZ3VtZW50cyB0byBTaGFyZU9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBzZXQgb2Ygb3B0aW9ucyB0byBzZW5kIHRvIFNoYXJlT2JqZWN0XHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVXZWIucHJvdG90eXBlLnNoYXJlT2JqZWN0UmF3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlLCBudWxsKS5zaGFyZU9iamVjdChvcHRpb25zLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVuc2hhcmVzIHRoZSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSB1cmwgb2YgdGhlIG9iamVjdCB0byBzdG9wIHNoYXJpbmdcclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZVdlYi5wcm90b3R5cGUudW5zaGFyZU9iamVjdCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlLCBudWxsKS51bnNoYXJlT2JqZWN0V2ViKHVybCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVXZWI7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZVNlY3VyYWJsZSkpO1xyXG52YXIgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZUl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZUl0ZW0sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlSXRlbSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBsaW5rIHN1aXRhYmxlIGZvciBzaGFyaW5nIGZvciB0aGlzIGl0ZW1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2luZCBUaGUgdHlwZSBvZiBsaW5rIHRvIHNoYXJlXHJcbiAgICAgKiBAcGFyYW0gZXhwaXJhdGlvbiBUaGUgb3B0aW9uYWwgZXhwaXJhdGlvbiBkYXRlXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVJdGVtLnByb3RvdHlwZS5nZXRTaGFyZUxpbmsgPSBmdW5jdGlvbiAoa2luZCwgZXhwaXJhdGlvbikge1xyXG4gICAgICAgIGlmIChraW5kID09PSB2b2lkIDApIHsga2luZCA9IFNoYXJpbmdMaW5rS2luZC5Pcmdhbml6YXRpb25WaWV3OyB9XHJcbiAgICAgICAgaWYgKGV4cGlyYXRpb24gPT09IHZvaWQgMCkgeyBleHBpcmF0aW9uID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUsIG51bGwpLmdldFNoYXJlTGluayhraW5kLCBleHBpcmF0aW9uKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNoYXJlcyB0aGlzIGl0ZW0gd2l0aCBvbmUgb3IgbW9yZSB1c2Vyc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2dpbk5hbWVzIHN0cmluZyBvciBzdHJpbmdbXSBvZiByZXNvbHZlZCBsb2dpbiBuYW1lcyB0byB3aGljaCB0aGlzIGl0ZW0gd2lsbCBiZSBzaGFyZWRcclxuICAgICAqIEBwYXJhbSByb2xlIFRoZSByb2xlIChWaWV3IHwgRWRpdCkgYXBwbGllZCB0byB0aGUgc2hhcmVcclxuICAgICAqIEBwYXJhbSBlbWFpbERhdGEgT3B0aW9uYWwsIGlmIGlubHVjZGVkIGFuIGVtYWlsIHdpbGwgYmUgc2VudC4gTm90ZSBzdWJqZWN0IGN1cnJlbnRseSBoYXMgbm8gZWZmZWN0LlxyXG4gICAgICovXHJcbiAgICBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlSXRlbS5wcm90b3R5cGUuc2hhcmVXaXRoID0gZnVuY3Rpb24gKGxvZ2luTmFtZXMsIHJvbGUsIHJlcXVpcmVTaWduaW4sIGVtYWlsRGF0YSkge1xyXG4gICAgICAgIGlmIChyb2xlID09PSB2b2lkIDApIHsgcm9sZSA9IFNoYXJpbmdSb2xlLlZpZXc7IH1cclxuICAgICAgICBpZiAocmVxdWlyZVNpZ25pbiA9PT0gdm9pZCAwKSB7IHJlcXVpcmVTaWduaW4gPSBmYWxzZTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUsIG51bGwpLnNoYXJlV2l0aChsb2dpbk5hbWVzLCByb2xlLCByZXF1aXJlU2lnbmluLCBmYWxzZSwgZW1haWxEYXRhKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBQZXJtaXNzaW9ucyBvbiB0aGUgbGlzdCBvZiBVc2VycyBhbmQgcmV0dXJucyBiYWNrIHJvbGUgdGhlIHVzZXJzIGhhdmUgb24gdGhlIEl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlY2lwaWVudHMgVGhlIGFycmF5IG9mIEVudGl0aWVzIGZvciB3aGljaCBQZXJtaXNzaW9ucyBuZWVkIHRvIGJlIGNoZWNrZWQuXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVJdGVtLnByb3RvdHlwZS5jaGVja1NoYXJpbmdQZXJtaXNzaW9ucyA9IGZ1bmN0aW9uIChyZWNpcGllbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZSwgbnVsbCkuY2hlY2tQZXJtaXNzaW9ucyhyZWNpcGllbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBTaGFyaW5nIEluZm9ybWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBTaGFyaW5nSW5mb3JtYXRpb25SZXF1ZXN0IE9iamVjdC5cclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZUl0ZW0ucHJvdG90eXBlLmdldFNoYXJpbmdJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgaWYgKHJlcXVlc3QgPT09IHZvaWQgMCkgeyByZXF1ZXN0ID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUsIG51bGwpLmdldFNoYXJpbmdJbmZvcm1hdGlvbihyZXF1ZXN0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHNoYXJpbmcgc2V0dGluZ3Mgb2YgYW4gaXRlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNlU2ltcGxpZmllZFJvbGVzIERldGVybWluZXMgd2hldGhlciB0byB1c2Ugc2ltcGxpZmllZCByb2xlcy5cclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZUl0ZW0ucHJvdG90eXBlLmdldE9iamVjdFNoYXJpbmdTZXR0aW5ncyA9IGZ1bmN0aW9uICh1c2VTaW1wbGlmaWVkUm9sZXMpIHtcclxuICAgICAgICBpZiAodXNlU2ltcGxpZmllZFJvbGVzID09PSB2b2lkIDApIHsgdXNlU2ltcGxpZmllZFJvbGVzID0gdHJ1ZTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUsIG51bGwpLmdldE9iamVjdFNoYXJpbmdTZXR0aW5ncyh1c2VTaW1wbGlmaWVkUm9sZXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zaGFyZSB0aGlzIGl0ZW1cclxuICAgICAqL1xyXG4gICAgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZUl0ZW0ucHJvdG90eXBlLnVuc2hhcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZSwgbnVsbCkudW5zaGFyZU9iamVjdCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhIHNoYXJpbmcgbGluayBieSBraW5kXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtpbmQgRGVsZXRlcyBhIHNoYXJpbmcgbGluayBieSB0aGUga2luZCBvZiBsaW5rXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVJdGVtLnByb3RvdHlwZS5kZWxldGVTaGFyaW5nTGlua0J5S2luZCA9IGZ1bmN0aW9uIChraW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZSwgbnVsbCkuZGVsZXRlTGlua0J5S2luZChraW5kKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaW5rIHRvIHRoZSBpdGVtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIGxpbmsgdG8gYmUgZGVsZXRlZC5cclxuICAgICAqIEBwYXJhbSBzaGFyZUlkXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVJdGVtLnByb3RvdHlwZS51bnNoYXJlTGluayA9IGZ1bmN0aW9uIChraW5kLCBzaGFyZUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZSwgbnVsbCkudW5zaGFyZUxpbmsoa2luZCwgc2hhcmVJZCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVJdGVtO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVTZWN1cmFibGUpKTtcclxudmFyIEZpbGVGb2xkZXJTaGFyZWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmlsZUZvbGRlclNoYXJlZCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZpbGVGb2xkZXJTaGFyZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgbGluayBzdWl0YWJsZSBmb3Igc2hhcmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIGxpbmsgdG8gZ2V0XHJcbiAgICAgKiBAcGFyYW0gZXhwaXJhdGlvbiBPcHRpb25hbCwgYW4gZXhwaXJhdGlvbiBmb3IgdGhpcyBsaW5rXHJcbiAgICAgKi9cclxuICAgIEZpbGVGb2xkZXJTaGFyZWQucHJvdG90eXBlLmdldFNoYXJlTGluayA9IGZ1bmN0aW9uIChraW5kLCBleHBpcmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IHZvaWQgMCkgeyBraW5kID0gU2hhcmluZ0xpbmtLaW5kLk9yZ2FuaXphdGlvblZpZXc7IH1cclxuICAgICAgICBpZiAoZXhwaXJhdGlvbiA9PT0gdm9pZCAwKSB7IGV4cGlyYXRpb24gPSBudWxsOyB9XHJcbiAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSB0aGlzLmFkZEJhdGNoRGVwZW5kZW5jeSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNoYXJlYWJsZSgpLnRoZW4oZnVuY3Rpb24gKHNoYXJlYWJsZSkge1xyXG4gICAgICAgICAgICBkZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFyZWFibGUuZ2V0U2hhcmVMaW5rKGtpbmQsIGV4cGlyYXRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBQZXJtaXNzaW9ucyBvbiB0aGUgbGlzdCBvZiBVc2VycyBhbmQgcmV0dXJucyBiYWNrIHJvbGUgdGhlIHVzZXJzIGhhdmUgb24gdGhlIEl0ZW0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gcmVjaXBpZW50cyBUaGUgYXJyYXkgb2YgRW50aXRpZXMgZm9yIHdoaWNoIFBlcm1pc3Npb25zIG5lZWQgdG8gYmUgY2hlY2tlZC5cclxuICAgICAgICAgKi9cclxuICAgIEZpbGVGb2xkZXJTaGFyZWQucHJvdG90eXBlLmNoZWNrU2hhcmluZ1Blcm1pc3Npb25zID0gZnVuY3Rpb24gKHJlY2lwaWVudHMpIHtcclxuICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IHRoaXMuYWRkQmF0Y2hEZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hhcmVhYmxlKCkudGhlbihmdW5jdGlvbiAoc2hhcmVhYmxlKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZGVuY3koKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlYWJsZS5jaGVja1Blcm1pc3Npb25zKHJlY2lwaWVudHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IFNoYXJpbmcgSW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3QgVGhlIFNoYXJpbmdJbmZvcm1hdGlvblJlcXVlc3QgT2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBGaWxlRm9sZGVyU2hhcmVkLnByb3RvdHlwZS5nZXRTaGFyaW5nSW5mb3JtYXRpb24gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgIGlmIChyZXF1ZXN0ID09PSB2b2lkIDApIHsgcmVxdWVzdCA9IG51bGw7IH1cclxuICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IHRoaXMuYWRkQmF0Y2hEZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hhcmVhYmxlKCkudGhlbihmdW5jdGlvbiAoc2hhcmVhYmxlKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZGVuY3koKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlYWJsZS5nZXRTaGFyaW5nSW5mb3JtYXRpb24ocmVxdWVzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzaGFyaW5nIHNldHRpbmdzIG9mIGFuIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVzZVNpbXBsaWZpZWRSb2xlcyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIHNpbXBsaWZpZWQgcm9sZXMuXHJcbiAgICAgKi9cclxuICAgIEZpbGVGb2xkZXJTaGFyZWQucHJvdG90eXBlLmdldE9iamVjdFNoYXJpbmdTZXR0aW5ncyA9IGZ1bmN0aW9uICh1c2VTaW1wbGlmaWVkUm9sZXMpIHtcclxuICAgICAgICBpZiAodXNlU2ltcGxpZmllZFJvbGVzID09PSB2b2lkIDApIHsgdXNlU2ltcGxpZmllZFJvbGVzID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBkZXBlbmRlbmN5ID0gdGhpcy5hZGRCYXRjaERlcGVuZGVuY3koKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaGFyZWFibGUoKS50aGVuKGZ1bmN0aW9uIChzaGFyZWFibGUpIHtcclxuICAgICAgICAgICAgZGVwZW5kZW5jeSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hhcmVhYmxlLmdldE9iamVjdFNoYXJpbmdTZXR0aW5ncyh1c2VTaW1wbGlmaWVkUm9sZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5zaGFyZSB0aGlzIGl0ZW1cclxuICAgICAqL1xyXG4gICAgRmlsZUZvbGRlclNoYXJlZC5wcm90b3R5cGUudW5zaGFyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IHRoaXMuYWRkQmF0Y2hEZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hhcmVhYmxlKCkudGhlbihmdW5jdGlvbiAoc2hhcmVhYmxlKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZGVuY3koKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlYWJsZS51bnNoYXJlT2JqZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgc2hhcmluZyBsaW5rIGJ5IHRoZSBraW5kIG9mIGxpbmtcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiBsaW5rIHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgKi9cclxuICAgIEZpbGVGb2xkZXJTaGFyZWQucHJvdG90eXBlLmRlbGV0ZVNoYXJpbmdMaW5rQnlLaW5kID0gZnVuY3Rpb24gKGtpbmQpIHtcclxuICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IHRoaXMuYWRkQmF0Y2hEZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hhcmVhYmxlKCkudGhlbihmdW5jdGlvbiAoc2hhcmVhYmxlKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZGVuY3koKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYXJlYWJsZS5kZWxldGVMaW5rQnlLaW5kKGtpbmQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpbmsgdG8gdGhlIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgbGluayB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHBhcmFtIHNoYXJlSWQgVGhlIHNoYXJlIGlkIHRvIGRlbGV0ZVxyXG4gICAgICovXHJcbiAgICBGaWxlRm9sZGVyU2hhcmVkLnByb3RvdHlwZS51bnNoYXJlTGluayA9IGZ1bmN0aW9uIChraW5kLCBzaGFyZUlkKSB7XHJcbiAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSB0aGlzLmFkZEJhdGNoRGVwZW5kZW5jeSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNoYXJlYWJsZSgpLnRoZW4oZnVuY3Rpb24gKHNoYXJlYWJsZSkge1xyXG4gICAgICAgICAgICBkZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFyZWFibGUudW5zaGFyZUxpbmsoa2luZCwgc2hhcmVJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZmlsZXMgYW5kIGZvbGRlcnMgd2UgbmVlZCB0byB1c2UgdGhlIGFzc29jaWF0ZWQgaXRlbSBlbmQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgRmlsZUZvbGRlclNoYXJlZC5wcm90b3R5cGUuZ2V0U2hhcmVhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gc2hhcmluZyBvbmx5IHdvcmtzIG9uIHRoZSBpdGVtIGVuZCBwb2ludCwgbm90IHRoZSBmaWxlIG9uZSAtIHNvIHdlIGNyZWF0ZSBhIGZvbGRlciBpbnN0YW5jZSB3aXRoIHRoZSBpdGVtIHVybCBpbnRlcm5hbGx5XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZUZpbGUsIFwibGlzdEl0ZW1BbGxGaWVsZHNcIiwgZmFsc2UpLnNlbGVjdChcIm9kYXRhLmlkXCIpLmdldCgpLnRoZW4oZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIHNoYXJlYWJsZSA9IG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlKG9kYXRhVXJsRnJvbShkKSk7XHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaGFuZGxlIGJhdGNoaW5nXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5oYXNCYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgc2hhcmVhYmxlID0gc2hhcmVhYmxlLmluQmF0Y2goX3RoaXMuYmF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFyZWFibGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZpbGVGb2xkZXJTaGFyZWQ7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XHJcbnZhciBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlRmlsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlRmlsZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVGaWxlKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hhcmVzIHRoaXMgaXRlbSB3aXRoIG9uZSBvciBtb3JlIHVzZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvZ2luTmFtZXMgc3RyaW5nIG9yIHN0cmluZ1tdIG9mIHJlc29sdmVkIGxvZ2luIG5hbWVzIHRvIHdoaWNoIHRoaXMgaXRlbSB3aWxsIGJlIHNoYXJlZFxyXG4gICAgICogQHBhcmFtIHJvbGUgVGhlIHJvbGUgKFZpZXcgfCBFZGl0KSBhcHBsaWVkIHRvIHRoZSBzaGFyZVxyXG4gICAgICogQHBhcmFtIHNoYXJlRXZlcnl0aGluZyBTaGFyZSBldmVyeXRoaW5nIGluIHRoaXMgZm9sZGVyLCBldmVuIGl0ZW1zIHdpdGggdW5pcXVlIHBlcm1pc3Npb25zLlxyXG4gICAgICogQHBhcmFtIHJlcXVpcmVTaWduaW4gSWYgdHJ1ZSB0aGUgdXNlciBtdXN0IHNpZ25pbiB0byB2aWV3IGxpbmssIG90aGVyd2lzZSBhbnlvbmUgd2l0aCB0aGUgbGluayBjYW4gYWNjZXNzIHRoZSByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGVtYWlsRGF0YSBPcHRpb25hbCwgaWYgaW5sdWNkZWQgYW4gZW1haWwgd2lsbCBiZSBzZW50LiBOb3RlIHN1YmplY3QgY3VycmVudGx5IGhhcyBubyBlZmZlY3QuXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVGaWxlLnByb3RvdHlwZS5zaGFyZVdpdGggPSBmdW5jdGlvbiAobG9naW5OYW1lcywgcm9sZSwgcmVxdWlyZVNpZ25pbiwgZW1haWxEYXRhKSB7XHJcbiAgICAgICAgaWYgKHJvbGUgPT09IHZvaWQgMCkgeyByb2xlID0gU2hhcmluZ1JvbGUuVmlldzsgfVxyXG4gICAgICAgIGlmIChyZXF1aXJlU2lnbmluID09PSB2b2lkIDApIHsgcmVxdWlyZVNpZ25pbiA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSB0aGlzLmFkZEJhdGNoRGVwZW5kZW5jeSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNoYXJlYWJsZSgpLnRoZW4oZnVuY3Rpb24gKHNoYXJlYWJsZSkge1xyXG4gICAgICAgICAgICBkZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFyZWFibGUuc2hhcmVXaXRoKGxvZ2luTmFtZXMsIHJvbGUsIHJlcXVpcmVTaWduaW4sIGZhbHNlLCBlbWFpbERhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlRmlsZTtcclxufShGaWxlRm9sZGVyU2hhcmVkKSk7XHJcbnZhciBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlRm9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVGb2xkZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlRm9sZGVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hhcmVzIHRoaXMgaXRlbSB3aXRoIG9uZSBvciBtb3JlIHVzZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvZ2luTmFtZXMgc3RyaW5nIG9yIHN0cmluZ1tdIG9mIHJlc29sdmVkIGxvZ2luIG5hbWVzIHRvIHdoaWNoIHRoaXMgaXRlbSB3aWxsIGJlIHNoYXJlZFxyXG4gICAgICogQHBhcmFtIHJvbGUgVGhlIHJvbGUgKFZpZXcgfCBFZGl0KSBhcHBsaWVkIHRvIHRoZSBzaGFyZVxyXG4gICAgICogQHBhcmFtIHNoYXJlRXZlcnl0aGluZyBTaGFyZSBldmVyeXRoaW5nIGluIHRoaXMgZm9sZGVyLCBldmVuIGl0ZW1zIHdpdGggdW5pcXVlIHBlcm1pc3Npb25zLlxyXG4gICAgICogQHBhcmFtIHJlcXVpcmVTaWduaW4gSWYgdHJ1ZSB0aGUgdXNlciBtdXN0IHNpZ25pbiB0byB2aWV3IGxpbmssIG90aGVyd2lzZSBhbnlvbmUgd2l0aCB0aGUgbGluayBjYW4gYWNjZXNzIHRoZSByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGVtYWlsRGF0YSBPcHRpb25hbCwgaWYgaW5sdWNkZWQgYW4gZW1haWwgd2lsbCBiZSBzZW50LiBOb3RlIHN1YmplY3QgY3VycmVudGx5IGhhcyBubyBlZmZlY3QuXHJcbiAgICAgKi9cclxuICAgIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVGb2xkZXIucHJvdG90eXBlLnNoYXJlV2l0aCA9IGZ1bmN0aW9uIChsb2dpbk5hbWVzLCByb2xlLCByZXF1aXJlU2lnbmluLCBzaGFyZUV2ZXJ5dGhpbmcsIGVtYWlsRGF0YSkge1xyXG4gICAgICAgIGlmIChyb2xlID09PSB2b2lkIDApIHsgcm9sZSA9IFNoYXJpbmdSb2xlLlZpZXc7IH1cclxuICAgICAgICBpZiAocmVxdWlyZVNpZ25pbiA9PT0gdm9pZCAwKSB7IHJlcXVpcmVTaWduaW4gPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmIChzaGFyZUV2ZXJ5dGhpbmcgPT09IHZvaWQgMCkgeyBzaGFyZUV2ZXJ5dGhpbmcgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBkZXBlbmRlbmN5ID0gdGhpcy5hZGRCYXRjaERlcGVuZGVuY3koKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaGFyZWFibGUoKS50aGVuKGZ1bmN0aW9uIChzaGFyZWFibGUpIHtcclxuICAgICAgICAgICAgZGVwZW5kZW5jeSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hhcmVhYmxlLnNoYXJlV2l0aChsb2dpbk5hbWVzLCByb2xlLCByZXF1aXJlU2lnbmluLCBzaGFyZUV2ZXJ5dGhpbmcsIGVtYWlsRGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVGb2xkZXI7XHJcbn0oRmlsZUZvbGRlclNoYXJlZCkpO1xuXG52YXIgTGltaXRlZFdlYlBhcnRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExpbWl0ZWRXZWJQYXJ0TWFuYWdlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpbWl0ZWRXZWJQYXJ0TWFuYWdlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGltaXRlZFdlYlBhcnRNYW5hZ2VyLnByb3RvdHlwZSwgXCJ3ZWJwYXJ0c1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgc2V0IG9mIHdlYiBwYXJ0IGRlZmluaXRpb25zIGNvbnRhaW5lZCBieSB0aGlzIHdlYiBwYXJ0IG1hbmFnZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYlBhcnREZWZpbml0aW9ucyh0aGlzLCBcIndlYnBhcnRzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBvcnRzIGEgd2VicGFydCBkZWZpbml0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIHRoZSBHVUlEIGlkIG9mIHRoZSBkZWZpbml0aW9uIHRvIGV4cG9ydFxyXG4gICAgICovXHJcbiAgICBMaW1pdGVkV2ViUGFydE1hbmFnZXIucHJvdG90eXBlLmV4cG9ydCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKExpbWl0ZWRXZWJQYXJ0TWFuYWdlciwgXCJFeHBvcnRXZWJQYXJ0XCIpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHsgd2ViUGFydElkOiBpZCB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEltcG9ydHMgYSB3ZWJwYXJ0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHhtbCB3ZWJwYXJ0IGRlZmluaXRpb24gd2hpY2ggbXVzdCBiZSB2YWxpZCBYTUwgaW4gdGhlIC5kd3Agb3IgLndlYnBhcnQgZm9ybWF0XHJcbiAgICAgKi9cclxuICAgIExpbWl0ZWRXZWJQYXJ0TWFuYWdlci5wcm90b3R5cGUuaW1wb3J0ID0gZnVuY3Rpb24gKHhtbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKExpbWl0ZWRXZWJQYXJ0TWFuYWdlciwgXCJJbXBvcnRXZWJQYXJ0XCIpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHsgd2ViUGFydFhtbDogeG1sIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaW1pdGVkV2ViUGFydE1hbmFnZXI7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZSkpO1xyXG52YXIgV2ViUGFydERlZmluaXRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdlYlBhcnREZWZpbml0aW9ucywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFdlYlBhcnREZWZpbml0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB3ZWIgcGFydCBkZWZpbml0aW9uIGZyb20gdGhlIGNvbGxlY3Rpb24gYnkgaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgVGhlIHN0b3JhZ2UgSUQgb2YgdGhlIFNQV2ViUGFydERlZmluaXRpb24gdG8gcmV0cmlldmVcclxuICAgICAqL1xyXG4gICAgV2ViUGFydERlZmluaXRpb25zLnByb3RvdHlwZS5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJQYXJ0RGVmaW5pdGlvbih0aGlzLCBcImdldGJ5aWQoJ1wiICsgaWQgKyBcIicpXCIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHdlYiBwYXJ0IGRlZmluaXRpb24gZnJvbSB0aGUgY29sbGVjdGlvbiBieSBzdG9yYWdlIGlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIFRoZSBXZWJQYXJ0LklEIG9mIHRoZSBTUFdlYlBhcnREZWZpbml0aW9uIHRvIHJldHJpZXZlXHJcbiAgICAgKi9cclxuICAgIFdlYlBhcnREZWZpbml0aW9ucy5wcm90b3R5cGUuZ2V0QnlDb250cm9sSWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFdlYlBhcnREZWZpbml0aW9uKHRoaXMsIFwiZ2V0QnlDb250cm9sSWQoJ1wiICsgaWQgKyBcIicpXCIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBXZWJQYXJ0RGVmaW5pdGlvbnM7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24pKTtcclxudmFyIFdlYlBhcnREZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdlYlBhcnREZWZpbml0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gV2ViUGFydERlZmluaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlBhcnREZWZpbml0aW9uLnByb3RvdHlwZSwgXCJ3ZWJwYXJ0XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB3ZWJwYXJ0IGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGRlZmluaXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJQYXJ0KHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlcyBjaGFuZ2VzIHRvIHRoZSBXZWIgUGFydCBtYWRlIHVzaW5nIG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb24gdGhlIFNQV2ViUGFydERlZmluaXRpb24gb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIFdlYlBhcnREZWZpbml0aW9uLnByb3RvdHlwZS5zYXZlQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShXZWJQYXJ0RGVmaW5pdGlvbiwgXCJTYXZlV2ViUGFydENoYW5nZXNcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBXZWIgUGFydCB0byBhIGRpZmZlcmVudCBsb2NhdGlvbiBvbiBhIFdlYiBQYXJ0IFBhZ2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gem9uZUlkIFRoZSBJRCBvZiB0aGUgV2ViIFBhcnQgWm9uZSB0byB3aGljaCB0byBtb3ZlIHRoZSBXZWIgUGFydFxyXG4gICAgICogQHBhcmFtIHpvbmVJbmRleCBBIFdlYiBQYXJ0IHpvbmUgaW5kZXggdGhhdCBzcGVjaWZpZXMgdGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBXZWIgUGFydCBpcyB0byBiZSBtb3ZlZCB3aXRoaW4gdGhlIGRlc3RpbmF0aW9uIFdlYiBQYXJ0IHpvbmVcclxuICAgICAqL1xyXG4gICAgV2ViUGFydERlZmluaXRpb24ucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh6b25lSWQsIHpvbmVJbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFdlYlBhcnREZWZpbml0aW9uLCBcIk1vdmVXZWJQYXJ0VG8oem9uZUlEPSdcIiArIHpvbmVJZCArIFwiJywgem9uZUluZGV4PVwiICsgem9uZUluZGV4ICsgXCIpXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIFdlYiBQYXJ0LiBJZiB0aGUgV2ViIFBhcnQgaXMgYWxyZWFkeSBjbG9zZWQsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZ1xyXG4gICAgICovXHJcbiAgICBXZWJQYXJ0RGVmaW5pdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoV2ViUGFydERlZmluaXRpb24sIFwiQ2xvc2VXZWJQYXJ0XCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyB0aGUgV2ViIFBhcnQuIElmIHRoZSBXZWIgUGFydCBpcyBhbHJlYWR5IGNsb3NlZCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nXHJcbiAgICAgKi9cclxuICAgIFdlYlBhcnREZWZpbml0aW9uLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFdlYlBhcnREZWZpbml0aW9uLCBcIk9wZW5XZWJQYXJ0XCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgd2VicGFydCBmcm9tIGEgcGFnZSwgYWxsIHNldHRpbmdzIHdpbGwgYmUgbG9zdFxyXG4gICAgICovXHJcbiAgICBXZWJQYXJ0RGVmaW5pdGlvbi5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFdlYlBhcnREZWZpbml0aW9uLCBcIkRlbGV0ZVdlYlBhcnRcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gV2ViUGFydERlZmluaXRpb247XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XHJcbnZhciBXZWJQYXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdlYlBhcnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBXZWJQYXJ0KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFdlYlBhcnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcIndlYnBhcnRcIilcclxuICAgIF0sIFdlYlBhcnQpO1xyXG4gICAgcmV0dXJuIFdlYlBhcnQ7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XG5cbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBjb2xsZWN0aW9uIG9mIEZvbGRlciBvYmplY3RzXHJcbiAqXHJcbiAqL1xyXG52YXIgRm9sZGVycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGb2xkZXJzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRm9sZGVycygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBGb2xkZXJzXzEgPSBGb2xkZXJzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgZm9sZGVyIGJ5IGZvbGRlciBuYW1lXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBGb2xkZXJzLnByb3RvdHlwZS5nZXRCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBmID0gbmV3IEZvbGRlcih0aGlzKTtcclxuICAgICAgICBmLmNvbmNhdChcIignXCIgKyBuYW1lICsgXCInKVwiKTtcclxuICAgICAgICByZXR1cm4gZjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgZm9sZGVyIHRvIHRoZSBjdXJyZW50IGZvbGRlciAocmVsYXRpdmUpIG9yIGFueSBmb2xkZXIgKGFic29sdXRlKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmwgVGhlIHJlbGF0aXZlIG9yIGFic29sdXRlIHVybCB3aGVyZSB0aGUgbmV3IGZvbGRlciB3aWxsIGJlIGNyZWF0ZWQuIFVybHMgc3RhcnRpbmcgd2l0aCBhIGZvcndhcmQgc2xhc2ggYXJlIGFic29sdXRlLlxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBGb2xkZXIgYW5kIHRoZSByYXcgcmVzcG9uc2UuXHJcbiAgICAgKi9cclxuICAgIEZvbGRlcnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZvbGRlcnNfMSwgXCJhZGQoJ1wiICsgdXJsICsgXCInKVwiKS5wb3N0Q29yZSgpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZSxcclxuICAgICAgICAgICAgICAgIGZvbGRlcjogX3RoaXMuZ2V0QnlOYW1lKHVybCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIEZvbGRlcnNfMTtcclxuICAgIEZvbGRlcnMgPSBGb2xkZXJzXzEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcImZvbGRlcnNcIilcclxuICAgIF0sIEZvbGRlcnMpO1xyXG4gICAgcmV0dXJuIEZvbGRlcnM7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIHNpbmdsZSBGb2xkZXIgaW5zdGFuY2VcclxuICpcclxuICovXHJcbnZhciBGb2xkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRm9sZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRm9sZGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnVwZGF0ZSA9IF90aGlzLl91cGRhdGUoXCJTUC5Gb2xkZXJcIiwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuICh7IGRhdGE6IGRhdGEsIGZvbGRlcjogX3RoaXMgfSk7IH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb2xkZXIucHJvdG90eXBlLCBcImNvbnRlbnRUeXBlT3JkZXJcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgc2VxdWVuY2UgaW4gd2hpY2ggY29udGVudCB0eXBlcyBhcmUgZGlzcGxheWVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24odGhpcywgXCJjb250ZW50VHlwZU9yZGVyXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvbGRlci5wcm90b3R5cGUsIFwiZmlsZXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhpcyBmb2xkZXIncyBmaWxlc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlsZXModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9sZGVyLnByb3RvdHlwZSwgXCJmb2xkZXJzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoaXMgZm9sZGVyJ3Mgc3ViIGZvbGRlcnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRlcnModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9sZGVyLnByb3RvdHlwZSwgXCJsaXN0SXRlbUFsbEZpZWxkc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGlzIGZvbGRlcidzIGxpc3QgaXRlbSBmaWVsZCB2YWx1ZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSh0aGlzLCBcImxpc3RJdGVtQWxsRmllbGRzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvbGRlci5wcm90b3R5cGUsIFwicGFyZW50Rm9sZGVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBwYXJlbnQgZm9sZGVyLCBpZiBhdmFpbGFibGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRlcih0aGlzLCBcInBhcmVudEZvbGRlclwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb2xkZXIucHJvdG90eXBlLCBcInByb3BlcnRpZXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhpcyBmb2xkZXIncyBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UodGhpcywgXCJwcm9wZXJ0aWVzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvbGRlci5wcm90b3R5cGUsIFwic2VydmVyUmVsYXRpdmVVcmxcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhpcyBmb2xkZXIncyBzZXJ2ZXIgcmVsYXRpdmUgdXJsXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlKHRoaXMsIFwic2VydmVyUmVsYXRpdmVVcmxcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9sZGVyLnByb3RvdHlwZSwgXCJ1bmlxdWVDb250ZW50VHlwZU9yZGVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbnRlbnQgdHlwZSBvcmRlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKHRoaXMsIFwidW5pcXVlQ29udGVudFR5cGVPcmRlclwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgKiBEZWxldGUgdGhpcyBmb2xkZXJcclxuICAgICpcclxuICAgICogQHBhcmFtIGVUYWcgVmFsdWUgdXNlZCBpbiB0aGUgSUYtTWF0Y2ggaGVhZGVyLCBieSBkZWZhdWx0IFwiKlwiXHJcbiAgICAqL1xyXG4gICAgRm9sZGVyLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoZVRhZykge1xyXG4gICAgICAgIGlmIChlVGFnID09PSB2b2lkIDApIHsgZVRhZyA9IFwiKlwiOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoRm9sZGVyLCBudWxsKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgIFwiSUYtTWF0Y2hcIjogZVRhZyxcclxuICAgICAgICAgICAgICAgIFwiWC1IVFRQLU1ldGhvZFwiOiBcIkRFTEVURVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIGZvbGRlciB0byB0aGUgUmVjeWNsZSBCaW4gYW5kIHJldHVybnMgdGhlIGlkZW50aWZpZXIgb2YgdGhlIG5ldyBSZWN5Y2xlIEJpbiBpdGVtLlxyXG4gICAgICovXHJcbiAgICBGb2xkZXIucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoRm9sZGVyLCBcInJlY3ljbGVcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGFzc29jaWF0ZWQgbGlzdCBpdGVtIGZvciB0aGlzIGZvbGRlciwgbG9hZGluZyB0aGUgZGVmYXVsdCBwcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIEZvbGRlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VsZWN0cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdHNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLmxpc3RJdGVtQWxsRmllbGRzO1xyXG4gICAgICAgIHJldHVybiBxLnNlbGVjdC5hcHBseShxLCBzZWxlY3RzKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQobmV3IEl0ZW0ob2RhdGFVcmxGcm9tKGQpKSwgZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBhIGZvbGRlciB0byBkZXN0aW5hdGlvbiBwYXRoXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRlc3RVcmwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIG9mIHRoZSBkZXN0aW5hdGlvbiBwYXRoXHJcbiAgICAgKi9cclxuICAgIEZvbGRlci5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKGRlc3RVcmwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdChcIlNlcnZlclJlbGF0aXZlVXJsXCIpLmdldCgpLnRoZW4oZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBzcmNVcmwgPSBfYS5TZXJ2ZXJSZWxhdGl2ZVVybDtcclxuICAgICAgICAgICAgdmFyIGNsaWVudCA9IG5ldyBTUEh0dHBDbGllbnQoKTtcclxuICAgICAgICAgICAgdmFyIHdlYkJhc2VVcmwgPSBfdGhpcy50b1VybCgpLnNwbGl0KFwiL19hcGlcIilbMF07XHJcbiAgICAgICAgICAgIHZhciBob3N0VXJsID0gd2ViQmFzZVVybC5yZXBsYWNlKFwiOi8vXCIsIFwiX19fXCIpLnNwbGl0KFwiL1wiKVswXS5yZXBsYWNlKFwiX19fXCIsIFwiOi8vXCIpO1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kVXJsID0gd2ViQmFzZVVybCArIFwiL19hcGkvU1AuTW92ZUNvcHlVdGlsLk1vdmVGb2xkZXIoKVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnBvc3QobWV0aG9kVXJsLCB7XHJcbiAgICAgICAgICAgICAgICBib2R5OiBqc1Moe1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RVcmw6IGRlc3RVcmwuaW5kZXhPZihcImh0dHBcIikgPT09IDAgPyBkZXN0VXJsIDogXCJcIiArIGhvc3RVcmwgKyBkZXN0VXJsLFxyXG4gICAgICAgICAgICAgICAgICAgIHNyY1VybDogXCJcIiArIGhvc3RVcmwgKyBzcmNVcmwsXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocikgeyByZXR1cm4gci5qc29uKCk7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGb2xkZXI7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZUZvbGRlcikpO1xuXG4vKipcclxuICogRGVzY3JpYmVzIGEgY29sbGVjdGlvbiBvZiBjb250ZW50IHR5cGVzXHJcbiAqXHJcbiAqL1xyXG52YXIgQ29udGVudFR5cGVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbnRlbnRUeXBlcywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbnRlbnRUeXBlcygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBDb250ZW50VHlwZXNfMSA9IENvbnRlbnRUeXBlcztcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBleGlzdGluZyBjb250ZW50dHlwZSB0byBhIGNvbnRlbnQgdHlwZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRlbnRUeXBlSWQgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQsIGZvciBleGFtcGxlOiAweDAxMDEwMlxyXG4gICAgICovXHJcbiAgICBDb250ZW50VHlwZXMucHJvdG90eXBlLmFkZEF2YWlsYWJsZUNvbnRlbnRUeXBlID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlSWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwb3N0Qm9keSA9IGpzUyh7XHJcbiAgICAgICAgICAgIFwiY29udGVudFR5cGVJZFwiOiBjb250ZW50VHlwZUlkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKENvbnRlbnRUeXBlc18xLCBcImFkZEF2YWlsYWJsZUNvbnRlbnRUeXBlXCIpLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHkgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IF90aGlzLmdldEJ5SWQoZGF0YS5pZCksXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIENvbnRlbnRUeXBlIGJ5IGNvbnRlbnQgdHlwZSBpZFxyXG4gICAgICovXHJcbiAgICBDb250ZW50VHlwZXMucHJvdG90eXBlLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgY3QgPSBuZXcgQ29udGVudFR5cGUodGhpcyk7XHJcbiAgICAgICAgY3QuY29uY2F0KFwiKCdcIiArIGlkICsgXCInKVwiKTtcclxuICAgICAgICByZXR1cm4gY3Q7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGNvbnRlbnQgdHlwZSB0byB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCBUaGUgZGVzaXJlZCBjb250ZW50IHR5cGUgaWQgZm9yIHRoZSBuZXcgY29udGVudCB0eXBlIChhbHNvIGRldGVybWluZXMgdGhlIHBhcmVudCBjb250ZW50IHR5cGUpXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29udGVudCB0eXBlXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBjb250ZW50IHR5cGVcclxuICAgICAqIEBwYXJhbSBncm91cCBUaGUgZ3JvdXAgaW4gd2hpY2ggdG8gYWRkIHRoZSBjb250ZW50IHR5cGVcclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsU2V0dGluZ3MgQW55IGFkZGl0aW9uYWwgc2V0dGluZ3MgdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIHRoZSBjb250ZW50IHR5cGVcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIENvbnRlbnRUeXBlcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGlkLCBuYW1lLCBkZXNjcmlwdGlvbiwgZ3JvdXAsIGFkZGl0aW9uYWxTZXR0aW5ncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09PSB2b2lkIDApIHsgZGVzY3JpcHRpb24gPSBcIlwiOyB9XHJcbiAgICAgICAgaWYgKGdyb3VwID09PSB2b2lkIDApIHsgZ3JvdXAgPSBcIkN1c3RvbSBDb250ZW50IFR5cGVzXCI7IH1cclxuICAgICAgICBpZiAoYWRkaXRpb25hbFNldHRpbmdzID09PSB2b2lkIDApIHsgYWRkaXRpb25hbFNldHRpbmdzID0ge307IH1cclxuICAgICAgICB2YXIgcG9zdEJvZHkgPSBqc1MoT2JqZWN0LmFzc2lnbihtZXRhZGF0YShcIlNQLkNvbnRlbnRUeXBlXCIpLCB7XHJcbiAgICAgICAgICAgIFwiRGVzY3JpcHRpb25cIjogZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgIFwiR3JvdXBcIjogZ3JvdXAsXHJcbiAgICAgICAgICAgIFwiSWRcIjogeyBcIlN0cmluZ1ZhbHVlXCI6IGlkIH0sXHJcbiAgICAgICAgICAgIFwiTmFtZVwiOiBuYW1lLFxyXG4gICAgICAgIH0sIGFkZGl0aW9uYWxTZXR0aW5ncykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHkgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBjb250ZW50VHlwZTogX3RoaXMuZ2V0QnlJZChkYXRhLmlkKSwgZGF0YTogZGF0YSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBDb250ZW50VHlwZXNfMTtcclxuICAgIENvbnRlbnRUeXBlcyA9IENvbnRlbnRUeXBlc18xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJjb250ZW50dHlwZXNcIilcclxuICAgIF0sIENvbnRlbnRUeXBlcyk7XHJcbiAgICByZXR1cm4gQ29udGVudFR5cGVzO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgQ29udGVudFR5cGUgaW5zdGFuY2VcclxuICpcclxuICovXHJcbnZhciBDb250ZW50VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb250ZW50VHlwZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbnRlbnRUeXBlKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZSB0aGlzIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmRlbGV0ZSA9IF90aGlzLl9kZWxldGU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRlbnRUeXBlLnByb3RvdHlwZSwgXCJmaWVsZExpbmtzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjb2x1bW4gKGFsc28ga25vd24gYXMgZmllbGQpIHJlZmVyZW5jZXMgaW4gdGhlIGNvbnRlbnQgdHlwZS5cclxuICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpZWxkTGlua3ModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGVudFR5cGUucHJvdG90eXBlLCBcImZpZWxkc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsZWN0aW9uIG9mIGZpZWxkcyBmb3IgdGhlIGNvbnRlbnQgdHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbih0aGlzLCBcImZpZWxkc1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250ZW50VHlwZS5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBwYXJlbnQgY29udGVudCB0eXBlIG9mIHRoZSBjb250ZW50IHR5cGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29udGVudFR5cGUodGhpcywgXCJwYXJlbnRcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGVudFR5cGUucHJvdG90eXBlLCBcIndvcmtmbG93QXNzb2NpYXRpb25zXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxlY3Rpb24gb2Ygd29ya2Zsb3cgYXNzb2NpYXRpb25zIGZvciB0aGUgY29udGVudCB0eXBlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKHRoaXMsIFwid29ya2Zsb3dBc3NvY2lhdGlvbnNcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQ29udGVudFR5cGU7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBmaWVsZCBsaW5rIGluc3RhbmNlc1xyXG4gKi9cclxudmFyIEZpZWxkTGlua3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmllbGRMaW5rcywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZpZWxkTGlua3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgRmllbGRMaW5rIGJ5IEdVSUQgaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgVGhlIEdVSUQgaWQgb2YgdGhlIGZpZWxkIGxpbmtcclxuICAgICAqL1xyXG4gICAgRmllbGRMaW5rcy5wcm90b3R5cGUuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBmbCA9IG5ldyBGaWVsZExpbmsodGhpcyk7XHJcbiAgICAgICAgZmwuY29uY2F0KFwiKGd1aWQnXCIgKyBpZCArIFwiJylcIik7XHJcbiAgICAgICAgcmV0dXJuIGZsO1xyXG4gICAgfTtcclxuICAgIEZpZWxkTGlua3MgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcImZpZWxkbGlua3NcIilcclxuICAgIF0sIEZpZWxkTGlua3MpO1xyXG4gICAgcmV0dXJuIEZpZWxkTGlua3M7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24pKTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBmaWVsZCBsaW5rIGluc3RhbmNlXHJcbiAqL1xyXG52YXIgRmllbGRMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZpZWxkTGluaywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZpZWxkTGluaygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRmllbGRMaW5rO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xuXG4vKipcclxuICogRGVzY3JpYmVzIGEgY29sbGVjdGlvbiBvZiBJdGVtIG9iamVjdHNcclxuICpcclxuICovXHJcbnZhciBBdHRhY2htZW50RmlsZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXR0YWNobWVudEZpbGVzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXR0YWNobWVudEZpbGVzKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEF0dGFjaG1lbnRGaWxlc18xID0gQXR0YWNobWVudEZpbGVzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgQXR0YWNobWVudCBGaWxlIGJ5IGZpbGVuYW1lXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUsIGluY2x1ZGluZyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIEF0dGFjaG1lbnRGaWxlcy5wcm90b3R5cGUuZ2V0QnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgZiA9IG5ldyBBdHRhY2htZW50RmlsZSh0aGlzKTtcclxuICAgICAgICBmLmNvbmNhdChcIignXCIgKyBuYW1lICsgXCInKVwiKTtcclxuICAgICAgICByZXR1cm4gZjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgYXR0YWNobWVudCB0byB0aGUgY29sbGVjdGlvbi4gTm90IHN1cHBvcnRlZCBmb3IgYmF0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUsIGluY2x1ZGluZyBleHRlbnNpb24uXHJcbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgQmFzZTY0IGZpbGUgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgQXR0YWNobWVudEZpbGVzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgY29udGVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoQXR0YWNobWVudEZpbGVzXzEsIFwiYWRkKEZpbGVOYW1lPSdcIiArIG5hbWUgKyBcIicpXCIsIGZhbHNlKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGNvbnRlbnQsXHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgZmlsZTogX3RoaXMuZ2V0QnlOYW1lKG5hbWUpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBtdWx0aXBsZSBuZXcgYXR0YWNobWVudCB0byB0aGUgY29sbGVjdGlvbi4gTm90IHN1cHBvcnRlZCBmb3IgYmF0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQGZpbGVzIG5hbWUgVGhlIGNvbGxlY3Rpb24gb2YgZmlsZXMgdG8gYWRkXHJcbiAgICAgKi9cclxuICAgIEF0dGFjaG1lbnRGaWxlcy5wcm90b3R5cGUuYWRkTXVsdGlwbGUgPSBmdW5jdGlvbiAoZmlsZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGFkZCB0aGUgZmlsZXMgaW4gc2VyaWVzIHNvIHdlIGRvbid0IGdldCB1cGRhdGUgY29uZmxpY3RzXHJcbiAgICAgICAgcmV0dXJuIGZpbGVzLnJlZHVjZShmdW5jdGlvbiAoY2hhaW4sIGZpbGUpIHsgcmV0dXJuIGNoYWluLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvbmUoQXR0YWNobWVudEZpbGVzXzEsIFwiYWRkKEZpbGVOYW1lPSdcIiArIGZpbGUubmFtZSArIFwiJylcIiwgZmFsc2UpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keTogZmlsZS5jb250ZW50LFxyXG4gICAgICAgIH0pOyB9KTsgfSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIG11bHRpcGxlIGF0dGFjaG1lbnRzIGZyb20gdGhlIGNvbGxlY3Rpb24uIE5vdCBzdXBwb3J0ZWQgZm9yIGJhdGNoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBmaWxlcyBuYW1lIFRoZSBjb2xsZWN0aW9uIG9mIGZpbGVzIHRvIGRlbGV0ZVxyXG4gICAgICovXHJcbiAgICBBdHRhY2htZW50RmlsZXMucHJvdG90eXBlLmRlbGV0ZU11bHRpcGxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGZpbGVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgZmlsZXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbGVzLnJlZHVjZShmdW5jdGlvbiAoY2hhaW4sIGZpbGUpIHsgcmV0dXJuIGNoYWluLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0QnlOYW1lKGZpbGUpLmRlbGV0ZSgpOyB9KTsgfSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xyXG4gICAgfTtcclxuICAgIHZhciBBdHRhY2htZW50RmlsZXNfMTtcclxuICAgIEF0dGFjaG1lbnRGaWxlcyA9IEF0dGFjaG1lbnRGaWxlc18xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJBdHRhY2htZW50RmlsZXNcIilcclxuICAgIF0sIEF0dGFjaG1lbnRGaWxlcyk7XHJcbiAgICByZXR1cm4gQXR0YWNobWVudEZpbGVzO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgYXR0YWNobWVudCBmaWxlIGluc3RhbmNlXHJcbiAqXHJcbiAqL1xyXG52YXIgQXR0YWNobWVudEZpbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXR0YWNobWVudEZpbGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBdHRhY2htZW50RmlsZSgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kZWxldGUgPSBfdGhpcy5fZGVsZXRlV2l0aEVUYWc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBhcyB0ZXh0XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBBdHRhY2htZW50RmlsZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJzZWQobmV3IFRleHRQYXJzZXIoKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBhcyBhIGJsb2IsIGRvZXMgbm90IHdvcmsgaW4gTm9kZS5qc1xyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgQXR0YWNobWVudEZpbGUucHJvdG90eXBlLmdldEJsb2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyc2VkKG5ldyBCbG9iUGFyc2VyKCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY29udGVudHMgb2YgYSBmaWxlIGFzIGFuIEFycmF5QnVmZmVyLCB3b3JrcyBpbiBOb2RlLmpzXHJcbiAgICAgKi9cclxuICAgIEF0dGFjaG1lbnRGaWxlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyc2VkKG5ldyBCdWZmZXJQYXJzZXIoKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjb250ZW50cyBvZiBhIGZpbGUgYXMgYW4gQXJyYXlCdWZmZXIsIHdvcmtzIGluIE5vZGUuanNcclxuICAgICAqL1xyXG4gICAgQXR0YWNobWVudEZpbGUucHJvdG90eXBlLmdldEpTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyc2VkKG5ldyBKU09OUGFyc2VyKCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29udGVudCBvZiBhIGZpbGUuIE5vdCBzdXBwb3J0ZWQgZm9yIGJhdGNoaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIHZhbHVlIHRvIHNldCBmb3IgdGhlIGZpbGUgY29udGVudHNcclxuICAgICAqL1xyXG4gICAgQXR0YWNobWVudEZpbGUucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoQXR0YWNobWVudEZpbGUsIFwiJHZhbHVlXCIsIGZhbHNlKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgIFwiWC1IVFRQLU1ldGhvZFwiOiBcIlBVVFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIG5ldyBBdHRhY2htZW50RmlsZShfdGhpcyk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8vIC8qKlxyXG4gICAgLy8gICogRGVsZXRlIHRoaXMgYXR0YWNobWVudCBmaWxlXHJcbiAgICAvLyAgKlxyXG4gICAgLy8gICogQHBhcmFtIGVUYWcgVmFsdWUgdXNlZCBpbiB0aGUgSUYtTWF0Y2ggaGVhZGVyLCBieSBkZWZhdWx0IFwiKlwiXHJcbiAgICAvLyAgKi9cclxuICAgIC8vIHB1YmxpYyBkZWxldGUoZVRhZyA9IFwiKlwiKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMucG9zdENvcmUoe1xyXG4gICAgLy8gICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAvLyAgICAgICAgICAgICBcIklGLU1hdGNoXCI6IGVUYWcsXHJcbiAgICAvLyAgICAgICAgICAgICBcIlgtSFRUUC1NZXRob2RcIjogXCJERUxFVEVcIixcclxuICAgIC8vICAgICAgICAgfSxcclxuICAgIC8vICAgICB9KTtcclxuICAgIC8vIH1cclxuICAgIEF0dGFjaG1lbnRGaWxlLnByb3RvdHlwZS5nZXRQYXJzZWQgPSBmdW5jdGlvbiAocGFyc2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoQXR0YWNobWVudEZpbGUsIFwiJHZhbHVlXCIsIGZhbHNlKS5nZXQocGFyc2VyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXR0YWNobWVudEZpbGU7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XG5cbi8qKlxyXG4gKiBEZXNjcmliZXMgdGhlIHZpZXdzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0XHJcbiAqXHJcbiAqL1xyXG52YXIgVmlld3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVmlld3MsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWaWV3cygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBWaWV3c18xID0gVmlld3M7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2aWV3IGJ5IGd1aWQgaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgVGhlIEdVSUQgaWQgb2YgdGhlIHZpZXdcclxuICAgICAqL1xyXG4gICAgVmlld3MucHJvdG90eXBlLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgdiA9IG5ldyBWaWV3KHRoaXMpO1xyXG4gICAgICAgIHYuY29uY2F0KFwiKCdcIiArIGlkICsgXCInKVwiKTtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2aWV3IGJ5IHRpdGxlIChjYXNlLXNlbnNpdGl2ZSlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGl0bGUgVGhlIGNhc2Utc2Vuc2l0aXZlIHRpdGxlIG9mIHRoZSB2aWV3XHJcbiAgICAgKi9cclxuICAgIFZpZXdzLnByb3RvdHlwZS5nZXRCeVRpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3KHRoaXMsIFwiZ2V0QnlUaXRsZSgnXCIgKyB0aXRsZSArIFwiJylcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IHZpZXcgdG8gdGhlIGNvbGxlY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGl0bGUgVGhlIG5ldyB2aWV3cydzIHRpdGxlXHJcbiAgICAgKiBAcGFyYW0gcGVyc29uYWxWaWV3IFRydWUgaWYgdGhpcyBpcyBhIHBlcnNvbmFsIHZpZXcsIG90aGVyd2lzZSBmYWxzZSwgZGVmYXVsdCA9IGZhbHNlXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbFNldHRpbmdzIFdpbGwgYmUgcGFzc2VkIGFzIHBhcnQgb2YgdGhlIHZpZXcgY3JlYXRpb24gYm9keVxyXG4gICAgICovXHJcbiAgICBWaWV3cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRpdGxlLCBwZXJzb25hbFZpZXcsIGFkZGl0aW9uYWxTZXR0aW5ncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHBlcnNvbmFsVmlldyA9PT0gdm9pZCAwKSB7IHBlcnNvbmFsVmlldyA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxTZXR0aW5ncyA9PT0gdm9pZCAwKSB7IGFkZGl0aW9uYWxTZXR0aW5ncyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKE9iamVjdC5hc3NpZ24obWV0YWRhdGEoXCJTUC5WaWV3XCIpLCB7XHJcbiAgICAgICAgICAgIFwiUGVyc29uYWxWaWV3XCI6IHBlcnNvbmFsVmlldyxcclxuICAgICAgICAgICAgXCJUaXRsZVwiOiB0aXRsZSxcclxuICAgICAgICB9LCBhZGRpdGlvbmFsU2V0dGluZ3MpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShWaWV3c18xLCBudWxsKS5wb3N0Q29yZSh7IGJvZHk6IHBvc3RCb2R5IH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICB2aWV3OiBfdGhpcy5nZXRCeUlkKGRhdGEuSWQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBWaWV3c18xO1xyXG4gICAgVmlld3MgPSBWaWV3c18xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJ2aWV3c1wiKVxyXG4gICAgXSwgVmlld3MpO1xyXG4gICAgcmV0dXJuIFZpZXdzO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgVmlldyBpbnN0YW5jZVxyXG4gKlxyXG4gKi9cclxudmFyIFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZpZXcoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGlzIHZpZXcgaW50YW5jZSB3aXRoIHRoZSBzdXBwbGllZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBBIHBsYWluIG9iamVjdCBoYXNoIG9mIHZhbHVlcyB0byB1cGRhdGUgZm9yIHRoZSB2aWV3XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMudXBkYXRlID0gX3RoaXMuX3VwZGF0ZShcIlNQLlZpZXdcIiwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuICh7IGRhdGE6IGRhdGEsIHZpZXc6IF90aGlzIH0pOyB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWxldGUgdGhpcyB2aWV3XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5kZWxldGUgPSBfdGhpcy5fZGVsZXRlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3LnByb3RvdHlwZSwgXCJmaWVsZHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZpZXdGaWVsZHModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxpc3QgdmlldyBhcyBIVE1MLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVuZGVyQXNIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNoYXJlUG9pbnRRdWVyeWFibGUsIFwicmVuZGVyYXNodG1sXCIpLmdldCgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWaWV3O1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xyXG52YXIgVmlld0ZpZWxkcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWaWV3RmllbGRzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmlld0ZpZWxkcygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBWaWV3RmllbGRzXzEgPSBWaWV3RmllbGRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgdmFsdWUgdGhhdCBzcGVjaWZpZXMgdGhlIFhNTCBzY2hlbWEgdGhhdCByZXByZXNlbnRzIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBWaWV3RmllbGRzLnByb3RvdHlwZS5nZXRTY2hlbWFYbWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2hhcmVQb2ludFF1ZXJ5YWJsZSwgXCJzY2hlbWF4bWxcIikuZ2V0KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBmaWVsZCB3aXRoIHRoZSBzcGVjaWZpZWQgZmllbGQgaW50ZXJuYWwgbmFtZSBvciBkaXNwbGF5IG5hbWUgdG8gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpZWxkVGl0bGVPckludGVybmFsTmFtZSBUaGUgY2FzZS1zZW5zaXRpdmUgaW50ZXJuYWwgbmFtZSBvciBkaXNwbGF5IG5hbWUgb2YgdGhlIGZpZWxkIHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgVmlld0ZpZWxkcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGZpZWxkVGl0bGVPckludGVybmFsTmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFZpZXdGaWVsZHNfMSwgXCJhZGR2aWV3ZmllbGQoJ1wiICsgZmllbGRUaXRsZU9ySW50ZXJuYWxOYW1lICsgXCInKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIGZpZWxkIHdpdGggdGhlIHNwZWNpZmllZCBmaWVsZCBpbnRlcm5hbCBuYW1lIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpZWxkSW50ZXJuYWxOYW1lIFRoZSBjYXNlLXNlbnNpdGl2ZSBpbnRlcm5hbCBuYW1lIG9mIHRoZSBmaWVsZCB0byBtb3ZlLlxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoZSBuZXcgcG9zaXRpb24gZm9yIHRoZSBmaWVsZC5cclxuICAgICAqL1xyXG4gICAgVmlld0ZpZWxkcy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChmaWVsZEludGVybmFsTmFtZSwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShWaWV3RmllbGRzXzEsIFwibW92ZXZpZXdmaWVsZHRvXCIpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHsgXCJmaWVsZFwiOiBmaWVsZEludGVybmFsTmFtZSwgXCJpbmRleFwiOiBpbmRleCB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBmaWVsZHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgVmlld0ZpZWxkcy5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFZpZXdGaWVsZHNfMSwgXCJyZW1vdmVhbGx2aWV3ZmllbGRzXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBmaWVsZCB3aXRoIHRoZSBzcGVjaWZpZWQgZmllbGQgaW50ZXJuYWwgbmFtZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWVsZEludGVybmFsTmFtZSBUaGUgY2FzZS1zZW5zaXRpdmUgaW50ZXJuYWwgbmFtZSBvZiB0aGUgZmllbGQgdG8gcmVtb3ZlIGZyb20gdGhlIHZpZXcuXHJcbiAgICAgKi9cclxuICAgIFZpZXdGaWVsZHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChmaWVsZEludGVybmFsTmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFZpZXdGaWVsZHNfMSwgXCJyZW1vdmV2aWV3ZmllbGQoJ1wiICsgZmllbGRJbnRlcm5hbE5hbWUgKyBcIicpXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIFZpZXdGaWVsZHNfMTtcclxuICAgIFZpZXdGaWVsZHMgPSBWaWV3RmllbGRzXzEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcInZpZXdmaWVsZHNcIilcclxuICAgIF0sIFZpZXdGaWVsZHMpO1xyXG4gICAgcmV0dXJuIFZpZXdGaWVsZHM7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24pKTtcblxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIGNvbGxlY3Rpb24gb2YgRmllbGQgb2JqZWN0c1xyXG4gKlxyXG4gKi9cclxudmFyIEZpZWxkcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGaWVsZHMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGaWVsZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRmllbGRzXzEgPSBGaWVsZHM7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBmaWVsZCBmcm9tIHRoZSBjb2xsZWN0aW9uIGJ5IGlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIFRoZSBJZCBvZiB0aGUgbGlzdFxyXG4gICAgICovXHJcbiAgICBGaWVsZHMucHJvdG90eXBlLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgZiA9IG5ldyBGaWVsZCh0aGlzKTtcclxuICAgICAgICBmLmNvbmNhdChcIignXCIgKyBpZCArIFwiJylcIik7XHJcbiAgICAgICAgcmV0dXJuIGY7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgZmllbGQgZnJvbSB0aGUgY29sbGVjdGlvbiBieSB0aXRsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aXRsZSBUaGUgY2FzZS1zZW5zaXRpdmUgdGl0bGUgb2YgdGhlIGZpZWxkXHJcbiAgICAgKi9cclxuICAgIEZpZWxkcy5wcm90b3R5cGUuZ2V0QnlUaXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGQodGhpcywgXCJnZXRCeVRpdGxlKCdcIiArIHRpdGxlICsgXCInKVwiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBmaWVsZCBmcm9tIHRoZSBjb2xsZWN0aW9uIGJ5IHVzaW5nIGludGVybmFsIG5hbWUgb3IgdGl0bGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgY2FzZS1zZW5zaXRpdmUgaW50ZXJuYWwgbmFtZSBvciB0aXRsZSBvZiB0aGUgZmllbGRcclxuICAgICAqL1xyXG4gICAgRmllbGRzLnByb3RvdHlwZS5nZXRCeUludGVybmFsTmFtZU9yVGl0bGUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGQodGhpcywgXCJnZXRCeUludGVybmFsTmFtZU9yVGl0bGUoJ1wiICsgbmFtZSArIFwiJylcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZmllbGQgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBzY2hlbWFcclxuICAgICAqL1xyXG4gICAgRmllbGRzLnByb3RvdHlwZS5jcmVhdGVGaWVsZEFzWG1sID0gZnVuY3Rpb24gKHhtbCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGluZm87XHJcbiAgICAgICAgaWYgKHR5cGVvZiB4bWwgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgaW5mbyA9IHsgU2NoZW1hWG1sOiB4bWwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluZm8gPSB4bWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb3N0Qm9keSA9IGpzUyh7XHJcbiAgICAgICAgICAgIFwicGFyYW1ldGVyc1wiOiBleHRlbmQobWV0YWRhdGEoXCJTUC5YbWxTY2hlbWFGaWVsZENyZWF0aW9uSW5mb3JtYXRpb25cIiksIGluZm8pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpZWxkc18xLCBcImNyZWF0ZWZpZWxkYXN4bWxcIikucG9zdENvcmUoeyBib2R5OiBwb3N0Qm9keSB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZmllbGQ6IF90aGlzLmdldEJ5SWQoZGF0YS5JZCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGZpZWxkIHRvIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSBuZXcgZmllbGQncyB0aXRsZVxyXG4gICAgICogQHBhcmFtIGZpZWxkVHlwZSBUaGUgbmV3IGZpZWxkJ3MgdHlwZSAoZXg6IFNQLkZpZWxkVGV4dClcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIERpZmZlciBieSB0eXBlIG9mIGZpZWxkIGJlaW5nIGNyZWF0ZWQgKHNlZTogaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9vZmZpY2UvZG42MDAxODIuYXNweClcclxuICAgICAqL1xyXG4gICAgRmllbGRzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGl0bGUsIGZpZWxkVHlwZSwgcHJvcGVydGllcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKE9iamVjdC5hc3NpZ24obWV0YWRhdGEoZmllbGRUeXBlKSwge1xyXG4gICAgICAgICAgICBcIlRpdGxlXCI6IHRpdGxlLFxyXG4gICAgICAgIH0sIHByb3BlcnRpZXMpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGaWVsZHNfMSwgbnVsbCkucG9zdENvcmUoeyBib2R5OiBwb3N0Qm9keSB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZmllbGQ6IF90aGlzLmdldEJ5SWQoZGF0YS5JZCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IFNQLkZpZWxkVGV4dCB0byB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aXRsZSBUaGUgZmllbGQgdGl0bGVcclxuICAgICAqIEBwYXJhbSBtYXhMZW5ndGggVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgYWxsb3dlZCBpbiB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXMgRGlmZmVyIGJ5IHR5cGUgb2YgZmllbGQgYmVpbmcgY3JlYXRlZCAoc2VlOiBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L29mZmljZS9kbjYwMDE4Mi5hc3B4KVxyXG4gICAgICovXHJcbiAgICBGaWVsZHMucHJvdG90eXBlLmFkZFRleHQgPSBmdW5jdGlvbiAodGl0bGUsIG1heExlbmd0aCwgcHJvcGVydGllcykge1xyXG4gICAgICAgIGlmIChtYXhMZW5ndGggPT09IHZvaWQgMCkgeyBtYXhMZW5ndGggPSAyNTU7IH1cclxuICAgICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgICAgIEZpZWxkVHlwZUtpbmQ6IDIsXHJcbiAgICAgICAgICAgIE1heExlbmd0aDogbWF4TGVuZ3RoLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHRpdGxlLCBcIlNQLkZpZWxkVGV4dFwiLCBleHRlbmQocHJvcHMsIHByb3BlcnRpZXMpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgU1AuRmllbGRDYWxjdWxhdGVkIHRvIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSBmaWVsZCB0aXRsZS5cclxuICAgICAqIEBwYXJhbSBmb3JtdWxhIFRoZSBmb3JtdWxhIGZvciB0aGUgZmllbGQuXHJcbiAgICAgKiBAcGFyYW0gZGF0ZUZvcm1hdCBUaGUgZGF0ZSBhbmQgdGltZSBmb3JtYXQgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIGZpZWxkLlxyXG4gICAgICogQHBhcmFtIG91dHB1dFR5cGUgU3BlY2lmaWVzIHRoZSBvdXRwdXQgZm9ybWF0IGZvciB0aGUgZmllbGQuIFJlcHJlc2VudHMgYSBGaWVsZFR5cGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBEaWZmZXIgYnkgdHlwZSBvZiBmaWVsZCBiZWluZyBjcmVhdGVkIChzZWU6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvb2ZmaWNlL2RuNjAwMTgyLmFzcHgpXHJcbiAgICAgKi9cclxuICAgIEZpZWxkcy5wcm90b3R5cGUuYWRkQ2FsY3VsYXRlZCA9IGZ1bmN0aW9uICh0aXRsZSwgZm9ybXVsYSwgZGF0ZUZvcm1hdCwgb3V0cHV0VHlwZSwgcHJvcGVydGllcykge1xyXG4gICAgICAgIGlmIChvdXRwdXRUeXBlID09PSB2b2lkIDApIHsgb3V0cHV0VHlwZSA9IEZpZWxkVHlwZXMuVGV4dDsgfVxyXG4gICAgICAgIHZhciBwcm9wcyA9IHtcclxuICAgICAgICAgICAgRGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcclxuICAgICAgICAgICAgRmllbGRUeXBlS2luZDogMTcsXHJcbiAgICAgICAgICAgIEZvcm11bGE6IGZvcm11bGEsXHJcbiAgICAgICAgICAgIE91dHB1dFR5cGU6IG91dHB1dFR5cGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQodGl0bGUsIFwiU1AuRmllbGRDYWxjdWxhdGVkXCIsIGV4dGVuZChwcm9wcywgcHJvcGVydGllcykpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBTUC5GaWVsZERhdGVUaW1lIHRvIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSBmaWVsZCB0aXRsZVxyXG4gICAgICogQHBhcmFtIGRpc3BsYXlGb3JtYXQgVGhlIGZvcm1hdCBvZiB0aGUgZGF0ZSBhbmQgdGltZSB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgZmllbGQuXHJcbiAgICAgKiBAcGFyYW0gY2FsZW5kYXJUeXBlIFNwZWNpZmllcyB0aGUgY2FsZW5kYXIgdHlwZSBvZiB0aGUgZmllbGQuXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBEaWZmZXIgYnkgdHlwZSBvZiBmaWVsZCBiZWluZyBjcmVhdGVkIChzZWU6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvb2ZmaWNlL2RuNjAwMTgyLmFzcHgpXHJcbiAgICAgKi9cclxuICAgIEZpZWxkcy5wcm90b3R5cGUuYWRkRGF0ZVRpbWUgPSBmdW5jdGlvbiAodGl0bGUsIGRpc3BsYXlGb3JtYXQsIGNhbGVuZGFyVHlwZSwgZnJpZW5kbHlEaXNwbGF5Rm9ybWF0LCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKGRpc3BsYXlGb3JtYXQgPT09IHZvaWQgMCkgeyBkaXNwbGF5Rm9ybWF0ID0gRGF0ZVRpbWVGaWVsZEZvcm1hdFR5cGUuRGF0ZU9ubHk7IH1cclxuICAgICAgICBpZiAoY2FsZW5kYXJUeXBlID09PSB2b2lkIDApIHsgY2FsZW5kYXJUeXBlID0gQ2FsZW5kYXJUeXBlLkdyZWdvcmlhbjsgfVxyXG4gICAgICAgIGlmIChmcmllbmRseURpc3BsYXlGb3JtYXQgPT09IHZvaWQgMCkgeyBmcmllbmRseURpc3BsYXlGb3JtYXQgPSAwOyB9XHJcbiAgICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgICAgICBEYXRlVGltZUNhbGVuZGFyVHlwZTogY2FsZW5kYXJUeXBlLFxyXG4gICAgICAgICAgICBEaXNwbGF5Rm9ybWF0OiBkaXNwbGF5Rm9ybWF0LFxyXG4gICAgICAgICAgICBGaWVsZFR5cGVLaW5kOiA0LFxyXG4gICAgICAgICAgICBGcmllbmRseURpc3BsYXlGb3JtYXQ6IGZyaWVuZGx5RGlzcGxheUZvcm1hdCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZCh0aXRsZSwgXCJTUC5GaWVsZERhdGVUaW1lXCIsIGV4dGVuZChwcm9wcywgcHJvcGVydGllcykpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBTUC5GaWVsZE51bWJlciB0byB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aXRsZSBUaGUgZmllbGQgdGl0bGVcclxuICAgICAqIEBwYXJhbSBtaW5WYWx1ZSBUaGUgZmllbGQncyBtaW5pbXVtIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gbWF4VmFsdWUgVGhlIGZpZWxkJ3MgbWF4aW11bSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXMgRGlmZmVyIGJ5IHR5cGUgb2YgZmllbGQgYmVpbmcgY3JlYXRlZCAoc2VlOiBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L29mZmljZS9kbjYwMDE4Mi5hc3B4KVxyXG4gICAgICovXHJcbiAgICBGaWVsZHMucHJvdG90eXBlLmFkZE51bWJlciA9IGZ1bmN0aW9uICh0aXRsZSwgbWluVmFsdWUsIG1heFZhbHVlLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0geyBGaWVsZFR5cGVLaW5kOiA5IH07XHJcbiAgICAgICAgaWYgKG1pblZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcHJvcHMgPSBleHRlbmQoeyBNaW5pbXVtVmFsdWU6IG1pblZhbHVlIH0sIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcHJvcHMgPSBleHRlbmQoeyBNYXhpbXVtVmFsdWU6IG1heFZhbHVlIH0sIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHRpdGxlLCBcIlNQLkZpZWxkTnVtYmVyXCIsIGV4dGVuZChwcm9wcywgcHJvcGVydGllcykpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBTUC5GaWVsZEN1cnJlbmN5IHRvIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSBmaWVsZCB0aXRsZVxyXG4gICAgICogQHBhcmFtIG1pblZhbHVlIFRoZSBmaWVsZCdzIG1pbmltdW0gdmFsdWVcclxuICAgICAqIEBwYXJhbSBtYXhWYWx1ZSBUaGUgZmllbGQncyBtYXhpbXVtIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gY3VycmVuY3lMb2NhbElkIFNwZWNpZmllcyB0aGUgbGFuZ3VhZ2UgY29kZSBpZGVudGlmaWVyIChMQ0lEKSB1c2VkIHRvIGZvcm1hdCB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBEaWZmZXIgYnkgdHlwZSBvZiBmaWVsZCBiZWluZyBjcmVhdGVkIChzZWU6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvb2ZmaWNlL2RuNjAwMTgyLmFzcHgpXHJcbiAgICAgKi9cclxuICAgIEZpZWxkcy5wcm90b3R5cGUuYWRkQ3VycmVuY3kgPSBmdW5jdGlvbiAodGl0bGUsIG1pblZhbHVlLCBtYXhWYWx1ZSwgY3VycmVuY3lMb2NhbElkLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbmN5TG9jYWxJZCA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5TG9jYWxJZCA9IDEwMzM7IH1cclxuICAgICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgICAgIEN1cnJlbmN5TG9jYWxlSWQ6IGN1cnJlbmN5TG9jYWxJZCxcclxuICAgICAgICAgICAgRmllbGRUeXBlS2luZDogMTAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobWluVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwcm9wcyA9IGV4dGVuZCh7IE1pbmltdW1WYWx1ZTogbWluVmFsdWUgfSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4VmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwcm9wcyA9IGV4dGVuZCh7IE1heGltdW1WYWx1ZTogbWF4VmFsdWUgfSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQodGl0bGUsIFwiU1AuRmllbGRDdXJyZW5jeVwiLCBleHRlbmQocHJvcHMsIHByb3BlcnRpZXMpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgU1AuRmllbGRNdWx0aUxpbmVUZXh0IHRvIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSBmaWVsZCB0aXRsZVxyXG4gICAgICogQHBhcmFtIG51bWJlck9mTGluZXMgU3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgbGluZXMgb2YgdGV4dCB0byBkaXNwbGF5IGZvciB0aGUgZmllbGQuXHJcbiAgICAgKiBAcGFyYW0gcmljaFRleHQgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZpZWxkIHN1cHBvcnRzIHJpY2ggZm9ybWF0dGluZy5cclxuICAgICAqIEBwYXJhbSByZXN0cmljdGVkTW9kZSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZmllbGQgc3VwcG9ydHMgYSBzdWJzZXQgb2YgcmljaCBmb3JtYXR0aW5nLlxyXG4gICAgICogQHBhcmFtIGFwcGVuZE9ubHkgU3BlY2lmaWVzIHdoZXRoZXIgYWxsIGNoYW5nZXMgdG8gdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBhcmUgZGlzcGxheWVkIGluIGxpc3QgZm9ybXMuXHJcbiAgICAgKiBAcGFyYW0gYWxsb3dIeXBlcmxpbmsgU3BlY2lmaWVzIHdoZXRoZXIgYSBoeXBlcmxpbmsgaXMgYWxsb3dlZCBhcyBhIHZhbHVlIG9mIHRoZSBmaWVsZC5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIERpZmZlciBieSB0eXBlIG9mIGZpZWxkIGJlaW5nIGNyZWF0ZWQgKHNlZTogaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9vZmZpY2UvZG42MDAxODIuYXNweClcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIEZpZWxkcy5wcm90b3R5cGUuYWRkTXVsdGlsaW5lVGV4dCA9IGZ1bmN0aW9uICh0aXRsZSwgbnVtYmVyT2ZMaW5lcywgcmljaFRleHQsIHJlc3RyaWN0ZWRNb2RlLCBhcHBlbmRPbmx5LCBhbGxvd0h5cGVybGluaywgcHJvcGVydGllcykge1xyXG4gICAgICAgIGlmIChudW1iZXJPZkxpbmVzID09PSB2b2lkIDApIHsgbnVtYmVyT2ZMaW5lcyA9IDY7IH1cclxuICAgICAgICBpZiAocmljaFRleHQgPT09IHZvaWQgMCkgeyByaWNoVGV4dCA9IHRydWU7IH1cclxuICAgICAgICBpZiAocmVzdHJpY3RlZE1vZGUgPT09IHZvaWQgMCkgeyByZXN0cmljdGVkTW9kZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGFwcGVuZE9ubHkgPT09IHZvaWQgMCkgeyBhcHBlbmRPbmx5ID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAoYWxsb3dIeXBlcmxpbmsgPT09IHZvaWQgMCkgeyBhbGxvd0h5cGVybGluayA9IHRydWU7IH1cclxuICAgICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgICAgIEFsbG93SHlwZXJsaW5rOiBhbGxvd0h5cGVybGluayxcclxuICAgICAgICAgICAgQXBwZW5kT25seTogYXBwZW5kT25seSxcclxuICAgICAgICAgICAgRmllbGRUeXBlS2luZDogMyxcclxuICAgICAgICAgICAgTnVtYmVyT2ZMaW5lczogbnVtYmVyT2ZMaW5lcyxcclxuICAgICAgICAgICAgUmVzdHJpY3RlZE1vZGU6IHJlc3RyaWN0ZWRNb2RlLFxyXG4gICAgICAgICAgICBSaWNoVGV4dDogcmljaFRleHQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQodGl0bGUsIFwiU1AuRmllbGRNdWx0aUxpbmVUZXh0XCIsIGV4dGVuZChwcm9wcywgcHJvcGVydGllcykpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBTUC5GaWVsZFVybCB0byB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aXRsZSBUaGUgZmllbGQgdGl0bGVcclxuICAgICAqL1xyXG4gICAgRmllbGRzLnByb3RvdHlwZS5hZGRVcmwgPSBmdW5jdGlvbiAodGl0bGUsIGRpc3BsYXlGb3JtYXQsIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBpZiAoZGlzcGxheUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRpc3BsYXlGb3JtYXQgPSBVcmxGaWVsZEZvcm1hdFR5cGUuSHlwZXJsaW5rOyB9XHJcbiAgICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgICAgICBEaXNwbGF5Rm9ybWF0OiBkaXNwbGF5Rm9ybWF0LFxyXG4gICAgICAgICAgICBGaWVsZFR5cGVLaW5kOiAxMSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZCh0aXRsZSwgXCJTUC5GaWVsZFVybFwiLCBleHRlbmQocHJvcHMsIHByb3BlcnRpZXMpKTtcclxuICAgIH07XHJcbiAgICAvKiogQWRkcyBhIHVzZXIgZmllbGQgdG8gdGhlIGNvbGxlY2l0b25cclxuICAgICpcclxuICAgICogQHBhcmFtIHRpdGxlIFRoZSBuZXcgZmllbGQncyB0aXRsZVxyXG4gICAgKiBAcGFyYW0gc2VsZWN0aW9uTW9kZSBUaGUgc2VsZWN0aW9uIG1vZGUgb2YgdGhlIGZpZWxkXHJcbiAgICAqIEBwYXJhbSBzZWxlY3Rpb25Hcm91cCBWYWx1ZSB0aGF0IHNwZWNpZmllcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgU2hhcmVQb2ludCBncm91cCB3aG9zZSBtZW1iZXJzIGNhbiBiZSBzZWxlY3RlZCBhcyB2YWx1ZXMgb2YgdGhlIGZpZWxkXHJcbiAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzXHJcbiAgICAqL1xyXG4gICAgRmllbGRzLnByb3RvdHlwZS5hZGRVc2VyID0gZnVuY3Rpb24gKHRpdGxlLCBzZWxlY3Rpb25Nb2RlLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgICAgICBGaWVsZFR5cGVLaW5kOiAyMCxcclxuICAgICAgICAgICAgU2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZCh0aXRsZSwgXCJTUC5GaWVsZFVzZXJcIiwgZXh0ZW5kKHByb3BzLCBwcm9wZXJ0aWVzKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgU1AuRmllbGRMb29rdXAgdG8gdGhlIGNvbGxlY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGl0bGUgVGhlIG5ldyBmaWVsZCdzIHRpdGxlXHJcbiAgICAgKiBAcGFyYW0gbG9va3VwTGlzdElkIFRoZSBndWlkIGlkIG9mIHRoZSBsaXN0IHdoZXJlIHRoZSBzb3VyY2Ugb2YgdGhlIGxvb2t1cCBpcyBmb3VuZFxyXG4gICAgICogQHBhcmFtIGxvb2t1cEZpZWxkTmFtZSBUaGUgaW50ZXJuYWwgbmFtZSBvZiB0aGUgZmllbGQgaW4gdGhlIHNvdXJjZSBsaXN0XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBTZXQgb2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIHNldCBvbiB0aGUgbmV3IGZpZWxkXHJcbiAgICAgKi9cclxuICAgIEZpZWxkcy5wcm90b3R5cGUuYWRkTG9va3VwID0gZnVuY3Rpb24gKHRpdGxlLCBsb29rdXBMaXN0SWQsIGxvb2t1cEZpZWxkTmFtZSwgcHJvcGVydGllcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb3BzID0gZXh0ZW5kKHtcclxuICAgICAgICAgICAgRmllbGRUeXBlS2luZDogNyxcclxuICAgICAgICAgICAgTG9va3VwRmllbGROYW1lOiBsb29rdXBGaWVsZE5hbWUsXHJcbiAgICAgICAgICAgIExvb2t1cExpc3RJZDogbG9va3VwTGlzdElkLFxyXG4gICAgICAgICAgICBUaXRsZTogdGl0bGUsXHJcbiAgICAgICAgfSwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKHtcclxuICAgICAgICAgICAgXCJwYXJhbWV0ZXJzXCI6IGV4dGVuZChtZXRhZGF0YShcIlNQLkZpZWxkQ3JlYXRpb25JbmZvcm1hdGlvblwiKSwgcHJvcHMpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpZWxkc18xLCBcImFkZGZpZWxkXCIpLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHkgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgIGZpZWxkOiBfdGhpcy5nZXRCeUlkKGRhdGEuSWQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBTUC5GaWVsZENob2ljZSB0byB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aXRsZSBUaGUgZmllbGQgdGl0bGUuXHJcbiAgICAgKiBAcGFyYW0gY2hvaWNlcyBUaGUgY2hvaWNlcyBmb3IgdGhlIGZpZWxkLlxyXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZGlzcGxheSBmb3JtYXQgb2YgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGUgZmllbGQuXHJcbiAgICAgKiBAcGFyYW0gZmlsbEluIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmaWVsZCBhbGxvd3MgZmlsbC1pbiB2YWx1ZXMuXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBEaWZmZXIgYnkgdHlwZSBvZiBmaWVsZCBiZWluZyBjcmVhdGVkIChzZWU6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvb2ZmaWNlL2RuNjAwMTgyLmFzcHgpXHJcbiAgICAgKi9cclxuICAgIEZpZWxkcy5wcm90b3R5cGUuYWRkQ2hvaWNlID0gZnVuY3Rpb24gKHRpdGxlLCBjaG9pY2VzLCBmb3JtYXQsIGZpbGxJbiwgcHJvcGVydGllcykge1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHZvaWQgMCkgeyBmb3JtYXQgPSBDaG9pY2VGaWVsZEZvcm1hdFR5cGUuRHJvcGRvd247IH1cclxuICAgICAgICB2YXIgcHJvcHMgPSB7XHJcbiAgICAgICAgICAgIENob2ljZXM6IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHM6IGNob2ljZXMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIEVkaXRGb3JtYXQ6IGZvcm1hdCxcclxuICAgICAgICAgICAgRmllbGRUeXBlS2luZDogNixcclxuICAgICAgICAgICAgRmlsbEluQ2hvaWNlOiBmaWxsSW4sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQodGl0bGUsIFwiU1AuRmllbGRDaG9pY2VcIiwgZXh0ZW5kKHByb3BzLCBwcm9wZXJ0aWVzKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IFNQLkZpZWxkTXVsdGlDaG9pY2UgdG8gdGhlIGNvbGxlY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGl0bGUgVGhlIGZpZWxkIHRpdGxlLlxyXG4gICAgICogQHBhcmFtIGNob2ljZXMgVGhlIGNob2ljZXMgZm9yIHRoZSBmaWVsZC5cclxuICAgICAqIEBwYXJhbSBmaWxsSW4gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZpZWxkIGFsbG93cyBmaWxsLWluIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIERpZmZlciBieSB0eXBlIG9mIGZpZWxkIGJlaW5nIGNyZWF0ZWQgKHNlZTogaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9vZmZpY2UvZG42MDAxODIuYXNweClcclxuICAgICAqL1xyXG4gICAgRmllbGRzLnByb3RvdHlwZS5hZGRNdWx0aUNob2ljZSA9IGZ1bmN0aW9uICh0aXRsZSwgY2hvaWNlcywgZmlsbEluLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgICAgICBDaG9pY2VzOiB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBjaG9pY2VzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBGaWVsZFR5cGVLaW5kOiAxNSxcclxuICAgICAgICAgICAgRmlsbEluQ2hvaWNlOiBmaWxsSW4sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQodGl0bGUsIFwiU1AuRmllbGRNdWx0aUNob2ljZVwiLCBleHRlbmQocHJvcHMsIHByb3BlcnRpZXMpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgU1AuRmllbGRCb29sZWFuIHRvIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSBmaWVsZCB0aXRsZS5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIERpZmZlciBieSB0eXBlIG9mIGZpZWxkIGJlaW5nIGNyZWF0ZWQgKHNlZTogaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9vZmZpY2UvZG42MDAxODIuYXNweClcclxuICAgICAqL1xyXG4gICAgRmllbGRzLnByb3RvdHlwZS5hZGRCb29sZWFuID0gZnVuY3Rpb24gKHRpdGxlLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgICAgICBGaWVsZFR5cGVLaW5kOiA4LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHRpdGxlLCBcIlNQLkZpZWxkXCIsIGV4dGVuZChwcm9wcywgcHJvcGVydGllcykpO1xyXG4gICAgfTtcclxuICAgIHZhciBGaWVsZHNfMTtcclxuICAgIEZpZWxkcyA9IEZpZWxkc18xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJmaWVsZHNcIilcclxuICAgIF0sIEZpZWxkcyk7XHJcbiAgICByZXR1cm4gRmllbGRzO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgb2YgRmllbGQgaW5zdGFuY2VcclxuICpcclxuICovXHJcbnZhciBGaWVsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGaWVsZCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZpZWxkKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZSB0aGlzIGZpZWxkc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZGVsZXRlID0gX3RoaXMuX2RlbGV0ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhpcyBmaWVsZCBpbnRhbmNlIHdpdGggdGhlIHN1cHBsaWVkIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBBIHBsYWluIG9iamVjdCBoYXNoIG9mIHZhbHVlcyB0byB1cGRhdGUgZm9yIHRoZSBsaXN0XHJcbiAgICAgKiBAcGFyYW0gZmllbGRUeXBlIFRoZSB0eXBlIHZhbHVlLCByZXF1aXJlZCB0byB1cGRhdGUgY2hpbGQgZmllbGQgdHlwZSBwcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIEZpZWxkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocHJvcGVydGllcywgZmllbGRUeXBlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZmllbGRUeXBlID09PSB2b2lkIDApIHsgZmllbGRUeXBlID0gXCJTUC5GaWVsZFwiOyB9XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKGV4dGVuZChtZXRhZGF0YShmaWVsZFR5cGUpLCBwcm9wZXJ0aWVzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBwb3N0Qm9keSxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgXCJYLUhUVFAtTWV0aG9kXCI6IFwiTUVSR0VcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZmllbGQ6IF90aGlzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIFNob3dJbkRpc3BsYXlGb3JtIHByb3BlcnR5IGZvciB0aGlzIGZpZWxkLlxyXG4gICAgICovXHJcbiAgICBGaWVsZC5wcm90b3R5cGUuc2V0U2hvd0luRGlzcGxheUZvcm0gPSBmdW5jdGlvbiAoc2hvdykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpZWxkLCBcInNldHNob3dpbmRpc3BsYXlmb3JtKFwiICsgc2hvdyArIFwiKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIFNob3dJbkVkaXRGb3JtIHByb3BlcnR5IGZvciB0aGlzIGZpZWxkLlxyXG4gICAgICovXHJcbiAgICBGaWVsZC5wcm90b3R5cGUuc2V0U2hvd0luRWRpdEZvcm0gPSBmdW5jdGlvbiAoc2hvdykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpZWxkLCBcInNldHNob3dpbmVkaXRmb3JtKFwiICsgc2hvdyArIFwiKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIFNob3dJbk5ld0Zvcm0gcHJvcGVydHkgZm9yIHRoaXMgZmllbGQuXHJcbiAgICAgKi9cclxuICAgIEZpZWxkLnByb3RvdHlwZS5zZXRTaG93SW5OZXdGb3JtID0gZnVuY3Rpb24gKHNob3cpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGaWVsZCwgXCJzZXRzaG93aW5uZXdmb3JtKFwiICsgc2hvdyArIFwiKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGaWVsZDtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UpKTtcblxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIGNvbGxlY3Rpb24gb2YgRmllbGQgb2JqZWN0c1xyXG4gKlxyXG4gKi9cclxudmFyIEZvcm1zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZvcm1zLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRm9ybXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgZm9ybSBieSBpZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCBUaGUgZ3VpZCBpZCBvZiB0aGUgaXRlbSB0byByZXRyaWV2ZVxyXG4gICAgICovXHJcbiAgICBGb3Jtcy5wcm90b3R5cGUuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBpID0gbmV3IEZvcm0odGhpcyk7XHJcbiAgICAgICAgaS5jb25jYXQoXCIoJ1wiICsgaWQgKyBcIicpXCIpO1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfTtcclxuICAgIEZvcm1zID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJmb3Jtc1wiKVxyXG4gICAgXSwgRm9ybXMpO1xyXG4gICAgcmV0dXJuIEZvcm1zO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgb2YgRm9ybSBpbnN0YW5jZVxyXG4gKlxyXG4gKi9cclxudmFyIEZvcm0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRm9ybSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZvcm0oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEZvcm07XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XG5cbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBjb2xsZWN0aW9uIG9mIHdlYmhvb2sgc3Vic2NyaXB0aW9uc1xyXG4gKlxyXG4gKi9cclxudmFyIFN1YnNjcmlwdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU3Vic2NyaXB0aW9ucywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgd2ViaG9vayBzdWJzY3JpcHRpb25zIG9yIHRoZSBzcGVjaWZpZWQgd2ViaG9vayBzdWJzY3JpcHRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uSWQgVGhlIGlkIG9mIGEgc3BlY2lmaWMgd2ViaG9vayBzdWJzY3JpcHRpb24gdG8gcmV0cmlldmUsIG9taXQgdG8gcmV0cmlldmUgYWxsIHRoZSB3ZWJob29rIHN1YnNjcmlwdGlvbnNcclxuICAgICAqL1xyXG4gICAgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuZ2V0QnlJZCA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb25JZCkge1xyXG4gICAgICAgIHZhciBzID0gbmV3IFN1YnNjcmlwdGlvbih0aGlzKTtcclxuICAgICAgICBzLmNvbmNhdChcIignXCIgKyBzdWJzY3JpcHRpb25JZCArIFwiJylcIik7XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHdlYmhvb2sgc3Vic2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5vdGlmaWNhdGlvblVybCBUaGUgdXJsIHRvIHJlY2VpdmUgdGhlIG5vdGlmaWNhdGlvbnNcclxuICAgICAqIEBwYXJhbSBleHBpcmF0aW9uRGF0ZSBUaGUgZGF0ZSBhbmQgdGltZSB0byBleHBpcmUgdGhlIHN1YnNjcmlwdGlvbiBpbiB0aGUgZm9ybSBZWVlZLU1NLWRkVEhIOm1tOnNzKzAwOjAwIChtYXhpbXVtIG9mIDYgbW9udGhzKVxyXG4gICAgICogQHBhcmFtIGNsaWVudFN0YXRlIEEgY2xpZW50IHNwZWNpZmljIHN0cmluZyAoZGVmYXVsdHMgdG8gcG5wLWpzLWNvcmUtc3Vic2NyaXB0aW9uIHdoZW4gb21pdHRlZClcclxuICAgICAqL1xyXG4gICAgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5vdGlmaWNhdGlvblVybCwgZXhwaXJhdGlvbkRhdGUsIGNsaWVudFN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcG9zdEJvZHkgPSBqc1Moe1xyXG4gICAgICAgICAgICBcImNsaWVudFN0YXRlXCI6IGNsaWVudFN0YXRlIHx8IFwicG5wLWpzLWNvcmUtc3Vic2NyaXB0aW9uXCIsXHJcbiAgICAgICAgICAgIFwiZXhwaXJhdGlvbkRhdGVUaW1lXCI6IGV4cGlyYXRpb25EYXRlLFxyXG4gICAgICAgICAgICBcIm5vdGlmaWNhdGlvblVybFwiOiBub3RpZmljYXRpb25VcmwsXHJcbiAgICAgICAgICAgIFwicmVzb3VyY2VcIjogdGhpcy50b1VybCgpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHksIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVzdWx0LCBzdWJzY3JpcHRpb246IF90aGlzLmdldEJ5SWQocmVzdWx0LmlkKSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN1YnNjcmlwdGlvbnMgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcInN1YnNjcmlwdGlvbnNcIilcclxuICAgIF0sIFN1YnNjcmlwdGlvbnMpO1xyXG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbnM7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIHNpbmdsZSB3ZWJob29rIHN1YnNjcmlwdGlvbiBpbnN0YW5jZVxyXG4gKlxyXG4gKi9cclxudmFyIFN1YnNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdWJzY3JpcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5ld3MgdGhpcyB3ZWJob29rIHN1YnNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBleHBpcmF0aW9uRGF0ZSBUaGUgZGF0ZSBhbmQgdGltZSB0byBleHBpcmUgdGhlIHN1YnNjcmlwdGlvbiBpbiB0aGUgZm9ybSBZWVlZLU1NLWRkVEhIOm1tOnNzKzAwOjAwIChtYXhpbXVtIG9mIDYgbW9udGhzKVxyXG4gICAgICovXHJcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChleHBpcmF0aW9uRGF0ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKHtcclxuICAgICAgICAgICAgXCJleHBpcmF0aW9uRGF0ZVRpbWVcIjogZXhwaXJhdGlvbkRhdGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0Y2hDb3JlKHsgYm9keTogcG9zdEJvZHksIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHN1YnNjcmlwdGlvbjogX3RoaXMgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhpcyB3ZWJob29rIHN1YnNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGVsZXRlQ29yZS5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdWJzY3JpcHRpb247XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XG5cbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBjb2xsZWN0aW9uIG9mIHVzZXIgY3VzdG9tIGFjdGlvbnNcclxuICpcclxuICovXHJcbnZhciBVc2VyQ3VzdG9tQWN0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhVc2VyQ3VzdG9tQWN0aW9ucywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFVzZXJDdXN0b21BY3Rpb25zKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFVzZXJDdXN0b21BY3Rpb25zXzEgPSBVc2VyQ3VzdG9tQWN0aW9ucztcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdXNlciBjdXN0b20gYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBpZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCBUaGUgR1VJRCBpZCBvZiB0aGUgdXNlciBjdXN0b20gYWN0aW9uIHRvIHJldHJpZXZlXHJcbiAgICAgKi9cclxuICAgIFVzZXJDdXN0b21BY3Rpb25zLnByb3RvdHlwZS5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIHVjYSA9IG5ldyBVc2VyQ3VzdG9tQWN0aW9uKHRoaXMpO1xyXG4gICAgICAgIHVjYS5jb25jYXQoXCIoJ1wiICsgaWQgKyBcIicpXCIpO1xyXG4gICAgICAgIHJldHVybiB1Y2E7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgdXNlciBjdXN0b20gYWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXMgVGhlIGluZm9ybWF0aW9uIG9iamVjdCBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgdmFsdWVzIHdoaWNoIGRlZmluZSB0aGUgbmV3IHVzZXIgY3VzdG9tIGFjdGlvblxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgVXNlckN1c3RvbUFjdGlvbnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcG9zdEJvZHkgPSBqc1MoZXh0ZW5kKHsgX19tZXRhZGF0YTogeyBcInR5cGVcIjogXCJTUC5Vc2VyQ3VzdG9tQWN0aW9uXCIgfSB9LCBwcm9wZXJ0aWVzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdENvcmUoeyBib2R5OiBwb3N0Qm9keSB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IF90aGlzLmdldEJ5SWQoZGF0YS5JZCksXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhbGwgdXNlciBjdXN0b20gYWN0aW9ucyBpbiB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgVXNlckN1c3RvbUFjdGlvbnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFVzZXJDdXN0b21BY3Rpb25zXzEsIFwiY2xlYXJcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICB2YXIgVXNlckN1c3RvbUFjdGlvbnNfMTtcclxuICAgIFVzZXJDdXN0b21BY3Rpb25zID0gVXNlckN1c3RvbUFjdGlvbnNfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwidXNlcmN1c3RvbWFjdGlvbnNcIilcclxuICAgIF0sIFVzZXJDdXN0b21BY3Rpb25zKTtcclxuICAgIHJldHVybiBVc2VyQ3VzdG9tQWN0aW9ucztcclxufShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbikpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIGEgc2luZ2xlIHVzZXIgY3VzdG9tIGFjdGlvblxyXG4gKlxyXG4gKi9cclxudmFyIFVzZXJDdXN0b21BY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVXNlckN1c3RvbUFjdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFVzZXJDdXN0b21BY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBVcGRhdGVzIHRoaXMgdXNlciBjdXN0b20gYWN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIHByb3BlcnRpZXNcclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBBbiBpbmZvcm1hdGlvbiBvYmplY3Qgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcyB0byB1cGRhdGUgZm9yIHRoaXMgdXNlciBjdXN0b20gYWN0aW9uXHJcbiAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy51cGRhdGUgPSBfdGhpcy5fdXBkYXRlKFwiU1AuVXNlckN1c3RvbUFjdGlvblwiLCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKHsgZGF0YTogZGF0YSwgYWN0aW9uOiBfdGhpcyB9KTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAqIFJlbW92ZXMgdGhpcyB1c2VyIGN1c3RvbSBhY3Rpb25cclxuICAgICpcclxuICAgICovXHJcbiAgICBVc2VyQ3VzdG9tQWN0aW9uLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGVsZXRlQ29yZS5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBVc2VyQ3VzdG9tQWN0aW9uO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xuXG4vKipcclxuICogRGVzY3JpYmVzIGEgY29sbGVjdGlvbiBvZiBMaXN0IG9iamVjdHNcclxuICpcclxuICovXHJcbnZhciBMaXN0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhMaXN0cywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RzKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIExpc3RzXzEgPSBMaXN0cztcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGxpc3QgZnJvbSB0aGUgY29sbGVjdGlvbiBieSBndWlkIGlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIFRoZSBJZCBvZiB0aGUgbGlzdCAoR1VJRClcclxuICAgICAqL1xyXG4gICAgTGlzdHMucHJvdG90eXBlLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgbGlzdCA9IG5ldyBMaXN0KHRoaXMpO1xyXG4gICAgICAgIGxpc3QuY29uY2F0KFwiKCdcIiArIGlkICsgXCInKVwiKTtcclxuICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBsaXN0IGZyb20gdGhlIGNvbGxlY3Rpb24gYnkgdGl0bGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGl0bGUgVGhlIHRpdGxlIG9mIHRoZSBsaXN0XHJcbiAgICAgKi9cclxuICAgIExpc3RzLnByb3RvdHlwZS5nZXRCeVRpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0KHRoaXMsIFwiZ2V0QnlUaXRsZSgnXCIgKyB0aXRsZSArIFwiJylcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGxpc3QgdG8gdGhlIGNvbGxlY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGl0bGUgVGhlIG5ldyBsaXN0J3MgdGl0bGVcclxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBUaGUgbmV3IGxpc3QncyBkZXNjcmlwdGlvblxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIFRoZSBsaXN0IHRlbXBsYXRlIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gZW5hYmxlQ29udGVudFR5cGVzIElmIHRydWUgY29udGVudCB0eXBlcyB3aWxsIGJlIGFsbG93ZWQgYW5kIGVuYWJsZWQsIG90aGVyd2lzZSB0aGV5IHdpbGwgYmUgZGlzYWxsb3dlZCBhbmQgbm90IGVuYWJsZWRcclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsU2V0dGluZ3MgV2lsbCBiZSBwYXNzZWQgYXMgcGFydCBvZiB0aGUgbGlzdCBjcmVhdGlvbiBib2R5XHJcbiAgICAgKi9cclxuICAgIExpc3RzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGl0bGUsIGRlc2NyaXB0aW9uLCB0ZW1wbGF0ZSwgZW5hYmxlQ29udGVudFR5cGVzLCBhZGRpdGlvbmFsU2V0dGluZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gdm9pZCAwKSB7IGRlc2NyaXB0aW9uID0gXCJcIjsgfVxyXG4gICAgICAgIGlmICh0ZW1wbGF0ZSA9PT0gdm9pZCAwKSB7IHRlbXBsYXRlID0gMTAwOyB9XHJcbiAgICAgICAgaWYgKGVuYWJsZUNvbnRlbnRUeXBlcyA9PT0gdm9pZCAwKSB7IGVuYWJsZUNvbnRlbnRUeXBlcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxTZXR0aW5ncyA9PT0gdm9pZCAwKSB7IGFkZGl0aW9uYWxTZXR0aW5ncyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIGFkZFNldHRpbmdzID0gZXh0ZW5kKHtcclxuICAgICAgICAgICAgXCJBbGxvd0NvbnRlbnRUeXBlc1wiOiBlbmFibGVDb250ZW50VHlwZXMsXHJcbiAgICAgICAgICAgIFwiQmFzZVRlbXBsYXRlXCI6IHRlbXBsYXRlLFxyXG4gICAgICAgICAgICBcIkNvbnRlbnRUeXBlc0VuYWJsZWRcIjogZW5hYmxlQ29udGVudFR5cGVzLFxyXG4gICAgICAgICAgICBcIkRlc2NyaXB0aW9uXCI6IGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICBcIlRpdGxlXCI6IHRpdGxlLFxyXG4gICAgICAgICAgICBcIl9fbWV0YWRhdGFcIjogeyBcInR5cGVcIjogXCJTUC5MaXN0XCIgfSxcclxuICAgICAgICB9LCBhZGRpdGlvbmFsU2V0dGluZ3MpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc3RDb3JlKHsgYm9keToganNTKGFkZFNldHRpbmdzKSB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIGxpc3Q6IF90aGlzLmdldEJ5VGl0bGUoYWRkU2V0dGluZ3MuVGl0bGUpIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIHNwZWNpZmllZCBsaXN0IGV4aXN0cyBpbiB0aGUgY29sbGVjdGlvbiAobm90ZTogdGhpcyBtZXRob2Qgbm90IHN1cHBvcnRlZCBmb3IgYmF0Y2hpbmcpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSBuZXcgbGlzdCdzIHRpdGxlXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gVGhlIG5ldyBsaXN0J3MgZGVzY3JpcHRpb25cclxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSBUaGUgbGlzdCB0ZW1wbGF0ZSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIGVuYWJsZUNvbnRlbnRUeXBlcyBJZiB0cnVlIGNvbnRlbnQgdHlwZXMgd2lsbCBiZSBhbGxvd2VkIGFuZCBlbmFibGVkLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGRpc2FsbG93ZWQgYW5kIG5vdCBlbmFibGVkXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbFNldHRpbmdzIFdpbGwgYmUgcGFzc2VkIGFzIHBhcnQgb2YgdGhlIGxpc3QgY3JlYXRpb24gYm9keSBvciB1c2VkIHRvIHVwZGF0ZSBhbiBleGlzdGluZyBsaXN0XHJcbiAgICAgKi9cclxuICAgIExpc3RzLnByb3RvdHlwZS5lbnN1cmUgPSBmdW5jdGlvbiAodGl0bGUsIGRlc2NyaXB0aW9uLCB0ZW1wbGF0ZSwgZW5hYmxlQ29udGVudFR5cGVzLCBhZGRpdGlvbmFsU2V0dGluZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gdm9pZCAwKSB7IGRlc2NyaXB0aW9uID0gXCJcIjsgfVxyXG4gICAgICAgIGlmICh0ZW1wbGF0ZSA9PT0gdm9pZCAwKSB7IHRlbXBsYXRlID0gMTAwOyB9XHJcbiAgICAgICAgaWYgKGVuYWJsZUNvbnRlbnRUeXBlcyA9PT0gdm9pZCAwKSB7IGVuYWJsZUNvbnRlbnRUeXBlcyA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxTZXR0aW5ncyA9PT0gdm9pZCAwKSB7IGFkZGl0aW9uYWxTZXR0aW5ncyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzQmF0Y2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgZW5zdXJlIGxpc3QgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHVzZSBpbiBhIGJhdGNoLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFkZE9yVXBkYXRlU2V0dGluZ3MgPSBleHRlbmQoYWRkaXRpb25hbFNldHRpbmdzLCB7IFRpdGxlOiB0aXRsZSwgRGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBDb250ZW50VHlwZXNFbmFibGVkOiBlbmFibGVDb250ZW50VHlwZXMgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gX3RoaXMuZ2V0QnlUaXRsZShhZGRPclVwZGF0ZVNldHRpbmdzLlRpdGxlKTtcclxuICAgICAgICAgICAgbGlzdC5nZXQoKS50aGVuKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnVwZGF0ZShhZGRPclVwZGF0ZVNldHRpbmdzKS50aGVuKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGNyZWF0ZWQ6IGZhbHNlLCBkYXRhOiBkLCBsaXN0OiBfdGhpcy5nZXRCeVRpdGxlKGFkZE9yVXBkYXRlU2V0dGluZ3MuVGl0bGUpIH0pO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHJlamVjdChlKTsgfSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGQodGl0bGUsIGRlc2NyaXB0aW9uLCB0ZW1wbGF0ZSwgZW5hYmxlQ29udGVudFR5cGVzLCBhZGRPclVwZGF0ZVNldHRpbmdzKS50aGVuKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGNyZWF0ZWQ6IHRydWUsIGRhdGE6IHIuZGF0YSwgbGlzdDogX3RoaXMuZ2V0QnlUaXRsZShhZGRPclVwZGF0ZVNldHRpbmdzLlRpdGxlKSB9KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiByZWplY3QoZSk7IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBsaXN0IHRoYXQgaXMgdGhlIGRlZmF1bHQgYXNzZXQgbG9jYXRpb24gZm9yIGltYWdlcyBvciBvdGhlciBmaWxlcywgd2hpY2ggdGhlIHVzZXJzIHVwbG9hZCB0byB0aGVpciB3aWtpIHBhZ2VzLlxyXG4gICAgICovXHJcbiAgICBMaXN0cy5wcm90b3R5cGUuZW5zdXJlU2l0ZUFzc2V0c0xpYnJhcnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoTGlzdHNfMSwgXCJlbnN1cmVzaXRlYXNzZXRzbGlicmFyeVwiKS5wb3N0Q29yZSgpLnRoZW4oZnVuY3Rpb24gKGpzb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0KG9kYXRhVXJsRnJvbShqc29uKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgbGlzdCB0aGF0IGlzIHRoZSBkZWZhdWx0IGxvY2F0aW9uIGZvciB3aWtpIHBhZ2VzLlxyXG4gICAgICovXHJcbiAgICBMaXN0cy5wcm90b3R5cGUuZW5zdXJlU2l0ZVBhZ2VzTGlicmFyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShMaXN0c18xLCBcImVuc3VyZXNpdGVwYWdlc2xpYnJhcnlcIikucG9zdENvcmUoKS50aGVuKGZ1bmN0aW9uIChqc29uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdChvZGF0YVVybEZyb20oanNvbikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBMaXN0c18xO1xyXG4gICAgTGlzdHMgPSBMaXN0c18xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJsaXN0c1wiKVxyXG4gICAgXSwgTGlzdHMpO1xyXG4gICAgcmV0dXJuIExpc3RzO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgTGlzdCBpbnN0YW5jZVxyXG4gKlxyXG4gKi9cclxudmFyIExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTGlzdCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3QucHJvdG90eXBlLCBcImNvbnRlbnRUeXBlc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY29udGVudCB0eXBlcyBpbiB0aGlzIGxpc3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnRlbnRUeXBlcyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0LnByb3RvdHlwZSwgXCJpdGVtc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgaXRlbXMgaW4gdGhpcyBsaXN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVtcyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0LnByb3RvdHlwZSwgXCJ2aWV3c1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdmlld3MgaW4gdGhpcyBsaXN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3cyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0LnByb3RvdHlwZSwgXCJmaWVsZHNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGZpZWxkcyBpbiB0aGlzIGxpc3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpZWxkcyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0LnByb3RvdHlwZSwgXCJmb3Jtc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZm9ybXMgaW4gdGhpcyBsaXN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3Jtcyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0LnByb3RvdHlwZSwgXCJkZWZhdWx0Vmlld1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB2aWV3IG9mIHRoaXMgbGlzdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmlldyh0aGlzLCBcIkRlZmF1bHRWaWV3XCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3QucHJvdG90eXBlLCBcInVzZXJDdXN0b21BY3Rpb25zXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYWxsIGN1c3RvbSBhY3Rpb25zIG9uIGEgc2l0ZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2VyQ3VzdG9tQWN0aW9ucyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0LnByb3RvdHlwZSwgXCJlZmZlY3RpdmVCYXNlUGVybWlzc2lvbnNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGVmZmVjdGl2ZSBiYXNlIHBlcm1pc3Npb25zIG9mIHRoaXMgbGlzdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZSh0aGlzLCBcIkVmZmVjdGl2ZUJhc2VQZXJtaXNzaW9uc1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0LnByb3RvdHlwZSwgXCJldmVudFJlY2VpdmVyc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZXZlbnQgcmVjZWl2ZXJzIGF0dGFjaGVkIHRvIHRoaXMgbGlzdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24odGhpcywgXCJFdmVudFJlY2VpdmVyc1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0LnByb3RvdHlwZSwgXCJyZWxhdGVkRmllbGRzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSByZWxhdGVkIGZpZWxkcyBvZiB0aGlzIGxpc3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGUodGhpcywgXCJnZXRSZWxhdGVkRmllbGRzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3QucHJvdG90eXBlLCBcImluZm9ybWF0aW9uUmlnaHRzTWFuYWdlbWVudFNldHRpbmdzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBJUk0gc2V0dGluZ3MgZm9yIHRoaXMgbGlzdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZSh0aGlzLCBcIkluZm9ybWF0aW9uUmlnaHRzTWFuYWdlbWVudFNldHRpbmdzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3QucHJvdG90eXBlLCBcInN1YnNjcmlwdGlvbnNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHdlYmhvb2sgc3Vic2NyaXB0aW9ucyBvZiB0aGlzIGxpc3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbnModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdC5wcm90b3R5cGUsIFwicm9vdEZvbGRlclwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJvb3QgZm9sZGVyIG9mIHRoZSBsaXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9sZGVyKHRoaXMsIFwicm9vdEZvbGRlclwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHZpZXcgYnkgdmlldyBndWlkIGlkXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBMaXN0LnByb3RvdHlwZS5nZXRWaWV3ID0gZnVuY3Rpb24gKHZpZXdJZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmlldyh0aGlzLCBcImdldFZpZXcoJ1wiICsgdmlld0lkICsgXCInKVwiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhpcyBsaXN0IGludGFuY2Ugd2l0aCB0aGUgc3VwcGxpZWQgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIEEgcGxhaW4gb2JqZWN0IGhhc2ggb2YgdmFsdWVzIHRvIHVwZGF0ZSBmb3IgdGhlIGxpc3RcclxuICAgICAqIEBwYXJhbSBlVGFnIFZhbHVlIHVzZWQgaW4gdGhlIElGLU1hdGNoIGhlYWRlciwgYnkgZGVmYXVsdCBcIipcIlxyXG4gICAgICovXHJcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZSBuby1zdHJpbmctbGl0ZXJhbCAqL1xyXG4gICAgTGlzdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHByb3BlcnRpZXMsIGVUYWcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChlVGFnID09PSB2b2lkIDApIHsgZVRhZyA9IFwiKlwiOyB9XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKGV4dGVuZCh7XHJcbiAgICAgICAgICAgIFwiX19tZXRhZGF0YVwiOiB7IFwidHlwZVwiOiBcIlNQLkxpc3RcIiB9LFxyXG4gICAgICAgIH0sIHByb3BlcnRpZXMpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IHBvc3RCb2R5LFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBcIklGLU1hdGNoXCI6IGVUYWcsXHJcbiAgICAgICAgICAgICAgICBcIlgtSFRUUC1NZXRob2RcIjogXCJNRVJHRVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHJldExpc3QgPSBfdGhpcztcclxuICAgICAgICAgICAgaWYgKGhPUChwcm9wZXJ0aWVzLCBcIlRpdGxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXRMaXN0ID0gX3RoaXMuZ2V0UGFyZW50KExpc3QsIF90aGlzLnBhcmVudFVybCwgXCJnZXRCeVRpdGxlKCdcIiArIHByb3BlcnRpZXNbXCJUaXRsZVwiXSArIFwiJylcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBsaXN0OiByZXRMaXN0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIHRzbGludDplbmFibGUgKi9cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIHRoaXMgbGlzdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlVGFnIFZhbHVlIHVzZWQgaW4gdGhlIElGLU1hdGNoIGhlYWRlciwgYnkgZGVmYXVsdCBcIipcIlxyXG4gICAgICovXHJcbiAgICBMaXN0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoZVRhZykge1xyXG4gICAgICAgIGlmIChlVGFnID09PSB2b2lkIDApIHsgZVRhZyA9IFwiKlwiOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBcIklGLU1hdGNoXCI6IGVUYWcsXHJcbiAgICAgICAgICAgICAgICBcIlgtSFRUUC1NZXRob2RcIjogXCJERUxFVEVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbGxlY3Rpb24gb2YgY2hhbmdlcyBmcm9tIHRoZSBjaGFuZ2UgbG9nIHRoYXQgaGF2ZSBvY2N1cnJlZCB3aXRoaW4gdGhlIGxpc3QsIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAgICAgKi9cclxuICAgIExpc3QucHJvdG90eXBlLmdldENoYW5nZXMgPSBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShMaXN0LCBcImdldGNoYW5nZXNcIikucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1MoeyBcInF1ZXJ5XCI6IGV4dGVuZCh7IFwiX19tZXRhZGF0YVwiOiB7IFwidHlwZVwiOiBcIlNQLkNoYW5nZVF1ZXJ5XCIgfSB9LCBxdWVyeSkgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29sbGVjdGlvbiBvZiBpdGVtcyBmcm9tIHRoZSBsaXN0IGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIENhbWxRdWVyeSBUaGUgUXVlcnkgc2NoZW1hIG9mIENvbGxhYm9yYXRpdmUgQXBwbGljYXRpb24gTWFya3VwXHJcbiAgICAgKiBMYW5ndWFnZSAoQ0FNTCkgaXMgdXNlZCBpbiB2YXJpb3VzIHdheXMgd2l0aGluIHRoZSBjb250ZXh0IG9mIE1pY3Jvc29mdCBTaGFyZVBvaW50IEZvdW5kYXRpb25cclxuICAgICAqIHRvIGRlZmluZSBxdWVyaWVzIGFnYWluc3QgbGlzdCBkYXRhLlxyXG4gICAgICogc2VlOlxyXG4gICAgICpcclxuICAgICAqIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvb2ZmaWNlL21zNDY3NTIxLmFzcHhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXhwYW5kcyBBIFVSSSB3aXRoIGEgJGV4cGFuZCBTeXN0ZW0gUXVlcnkgT3B0aW9uIGluZGljYXRlcyB0aGF0IEVudHJpZXMgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgKiB0aGUgRW50cnkgb3IgQ29sbGVjdGlvbiBvZiBFbnRyaWVzIGlkZW50aWZpZWQgYnkgdGhlIFJlc291cmNlIFBhdGhcclxuICAgICAqIHNlY3Rpb24gb2YgdGhlIFVSSSBtdXN0IGJlIHJlcHJlc2VudGVkIGlubGluZSAoaS5lLiBlYWdlcmx5IGxvYWRlZCkuXHJcbiAgICAgKiBzZWU6XHJcbiAgICAgKlxyXG4gICAgICogaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9vZmZpY2UvZnAxNDIzODUuYXNweFxyXG4gICAgICpcclxuICAgICAqIGh0dHA6Ly93d3cub2RhdGEub3JnL2RvY3VtZW50YXRpb24vb2RhdGEtdmVyc2lvbi0yLTAvdXJpLWNvbnZlbnRpb25zLyNFeHBhbmRTeXN0ZW1RdWVyeU9wdGlvblxyXG4gICAgICovXHJcbiAgICBMaXN0LnByb3RvdHlwZS5nZXRJdGVtc0J5Q0FNTFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGV4cGFuZHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBleHBhbmRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcSA9IHRoaXMuY2xvbmUoTGlzdCwgXCJnZXRpdGVtc1wiKTtcclxuICAgICAgICByZXR1cm4gcS5leHBhbmQuYXBwbHkocSwgZXhwYW5kcykucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1MoeyBcInF1ZXJ5XCI6IGV4dGVuZCh7IFwiX19tZXRhZGF0YVwiOiB7IFwidHlwZVwiOiBcIlNQLkNhbWxRdWVyeVwiIH0gfSwgcXVlcnkpIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2VlOiBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L29mZmljZS9kbjI5MjU1NC5hc3B4XHJcbiAgICAgKi9cclxuICAgIExpc3QucHJvdG90eXBlLmdldExpc3RJdGVtQ2hhbmdlc1NpbmNlVG9rZW4gPSBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShMaXN0LCBcImdldGxpc3RpdGVtY2hhbmdlc3NpbmNldG9rZW5cIikucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1MoeyBcInF1ZXJ5XCI6IGV4dGVuZCh7IFwiX19tZXRhZGF0YVwiOiB7IFwidHlwZVwiOiBcIlNQLkNoYW5nZUxvZ0l0ZW1RdWVyeVwiIH0gfSwgcXVlcnkpIH0pLFxyXG4gICAgICAgIH0sIHsgcGFyc2U6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRleHQoKTsgfSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBsaXN0IHRvIHRoZSBSZWN5Y2xlIEJpbiBhbmQgcmV0dXJucyB0aGUgaWRlbnRpZmllciBvZiB0aGUgbmV3IFJlY3ljbGUgQmluIGl0ZW0uXHJcbiAgICAgKi9cclxuICAgIExpc3QucHJvdG90eXBlLnJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoTGlzdCwgXCJyZWN5Y2xlXCIpLnBvc3RDb3JlKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoaE9QKGRhdGEsIFwiUmVjeWNsZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuUmVjeWNsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGxpc3QgZGF0YSBiYXNlZCBvbiB0aGUgdmlldyB4bWwgcHJvdmlkZWRcclxuICAgICAqL1xyXG4gICAgTGlzdC5wcm90b3R5cGUucmVuZGVyTGlzdERhdGEgPSBmdW5jdGlvbiAodmlld1htbCkge1xyXG4gICAgICAgIHZhciBxID0gdGhpcy5jbG9uZShMaXN0LCBcInJlbmRlcmxpc3RkYXRhKEB2aWV3WG1sKVwiKTtcclxuICAgICAgICBxLnF1ZXJ5LnNldChcIkB2aWV3WG1sXCIsIFwiJ1wiICsgdmlld1htbCArIFwiJ1wiKTtcclxuICAgICAgICByZXR1cm4gcS5wb3N0Q29yZSgpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gZGF0YSB3aWxsIGJlIGEgc3RyaW5nLCBzbyB3ZSBwYXJzZSBpdCBhZ2FpblxyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShoT1AoZGF0YSwgXCJSZW5kZXJMaXN0RGF0YVwiKSA/IGRhdGEuUmVuZGVyTGlzdERhdGEgOiBkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkgdmlld1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIHRvIGJlIHVzZWQgdG8gcmVuZGVyIGxpc3QgZGF0YSBhcyBKU09OIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSBvdmVycmlkZVBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgdGhhdCBhcmUgdXNlZCB0byBvdmVycmlkZSBhbmQgZXh0ZW5kIHRoZSByZWd1bGFyIFNQUmVuZGVyTGlzdERhdGFQYXJhbWV0ZXJzLlxyXG4gICAgICovXHJcbiAgICBMaXN0LnByb3RvdHlwZS5yZW5kZXJMaXN0RGF0YUFzU3RyZWFtID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMsIG92ZXJyaWRlUGFyYW1ldGVycykge1xyXG4gICAgICAgIGlmIChvdmVycmlkZVBhcmFtZXRlcnMgPT09IHZvaWQgMCkgeyBvdmVycmlkZVBhcmFtZXRlcnMgPSBudWxsOyB9XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ge1xyXG4gICAgICAgICAgICBvdmVycmlkZVBhcmFtZXRlcnM6IGV4dGVuZChtZXRhZGF0YShcIlNQLlJlbmRlckxpc3REYXRhT3ZlcnJpZGVQYXJhbWV0ZXJzXCIpLCBvdmVycmlkZVBhcmFtZXRlcnMpLFxyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBleHRlbmQobWV0YWRhdGEoXCJTUC5SZW5kZXJMaXN0RGF0YVBhcmFtZXRlcnNcIiksIHBhcmFtZXRlcnMpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoTGlzdCwgXCJSZW5kZXJMaXN0RGF0YUFzU3RyZWFtXCIsIHRydWUpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHBvc3RCb2R5KSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGZpZWxkIHZhbHVlcyBhbmQgZmllbGQgc2NoZW1hIGF0dHJpYnV0ZXMgZm9yIGEgbGlzdCBpdGVtLlxyXG4gICAgICovXHJcbiAgICBMaXN0LnByb3RvdHlwZS5yZW5kZXJMaXN0Rm9ybURhdGEgPSBmdW5jdGlvbiAoaXRlbUlkLCBmb3JtSWQsIG1vZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShMaXN0LCBcInJlbmRlcmxpc3Rmb3JtZGF0YShpdGVtaWQ9XCIgKyBpdGVtSWQgKyBcIiwgZm9ybWlkPSdcIiArIGZvcm1JZCArIFwiJywgbW9kZT0nXCIgKyBtb2RlICsgXCInKVwiKS5wb3N0Q29yZSgpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gZGF0YSB3aWxsIGJlIGEgc3RyaW5nLCBzbyB3ZSBwYXJzZSBpdCBhZ2FpblxyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShoT1AoZGF0YSwgXCJSZW5kZXJMaXN0Rm9ybURhdGFcIikgPyBkYXRhLlJlbmRlckxpc3RGb3JtRGF0YSA6IGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXJ2ZXMgYSBsaXN0IGl0ZW0gSUQgZm9yIGlkZW1wb3RlbnQgbGlzdCBpdGVtIGNyZWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBMaXN0LnByb3RvdHlwZS5yZXNlcnZlTGlzdEl0ZW1JZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShMaXN0LCBcInJlc2VydmVsaXN0aXRlbWlkXCIpLnBvc3RDb3JlKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoaE9QKGRhdGEsIFwiUmVzZXJ2ZUxpc3RJdGVtSWRcIikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLlJlc2VydmVMaXN0SXRlbUlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIExpc3RJdGVtRW50aXR5VHlwZUZ1bGxOYW1lIGZvciB0aGlzIGxpc3QsIHVzZWQgd2hlbiBhZGRpbmcvdXBkYXRpbmcgbGlzdCBpdGVtcy4gRG9lcyBub3Qgc3VwcG9ydCBiYXRjaGluZy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIExpc3QucHJvdG90eXBlLmdldExpc3RJdGVtRW50aXR5VHlwZUZ1bGxOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKExpc3QsIG51bGwsIGZhbHNlKS5zZWxlY3QoXCJMaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZVwiKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvLkxpc3RJdGVtRW50aXR5VHlwZUZ1bGxOYW1lOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaXRlbSB1c2luZyBwYXRoIChpbiBhIGZvbGRlciksIHZhbGlkYXRlcyBhbmQgc2V0cyBpdHMgZmllbGQgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmb3JtVmFsdWVzIFRoZSBmaWVsZHMgdG8gY2hhbmdlIGFuZCB0aGVpciBuZXcgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIGRlY29kZWRVcmwgUGF0aCBkZWNvZGVkIHVybDsgZm9sZGVyJ3Mgc2VydmVyIHJlbGF0aXZlIHBhdGguXHJcbiAgICAgKiBAcGFyYW0gYk5ld0RvY3VtZW50VXBkYXRlIHRydWUgaWYgdGhlIGxpc3QgaXRlbSBpcyBhIGRvY3VtZW50IGJlaW5nIHVwZGF0ZWQgYWZ0ZXIgdXBsb2FkOyBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAgKiBAcGFyYW0gY2hlY2tJbkNvbW1lbnQgT3B0aW9uYWwgY2hlY2sgaW4gY29tbWVudC5cclxuICAgICAqL1xyXG4gICAgTGlzdC5wcm90b3R5cGUuYWRkVmFsaWRhdGVVcGRhdGVJdGVtVXNpbmdQYXRoID0gZnVuY3Rpb24gKGZvcm1WYWx1ZXMsIGRlY29kZWRVcmwsIGJOZXdEb2N1bWVudFVwZGF0ZSwgY2hlY2tJbkNvbW1lbnQpIHtcclxuICAgICAgICBpZiAoYk5ld0RvY3VtZW50VXBkYXRlID09PSB2b2lkIDApIHsgYk5ld0RvY3VtZW50VXBkYXRlID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShMaXN0LCBcIkFkZFZhbGlkYXRlVXBkYXRlSXRlbVVzaW5nUGF0aCgpXCIpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHtcclxuICAgICAgICAgICAgICAgIGJOZXdEb2N1bWVudFVwZGF0ZTogYk5ld0RvY3VtZW50VXBkYXRlLFxyXG4gICAgICAgICAgICAgICAgY2hlY2tJbkNvbW1lbnQ6IGNoZWNrSW5Db21tZW50LFxyXG4gICAgICAgICAgICAgICAgZm9ybVZhbHVlczogZm9ybVZhbHVlcyxcclxuICAgICAgICAgICAgICAgIGxpc3RJdGVtQ3JlYXRlSW5mbzoge1xyXG4gICAgICAgICAgICAgICAgICAgIEZvbGRlclBhdGg6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZFVybDogZGVjb2RlZFVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX19tZXRhZGF0YTogeyB0eXBlOiBcIlNQLlJlc291cmNlUGF0aFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBfX21ldGFkYXRhOiB7IHR5cGU6IFwiU1AuTGlzdEl0ZW1DcmVhdGlvbkluZm9ybWF0aW9uVXNpbmdQYXRoXCIgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5BZGRWYWxpZGF0ZVVwZGF0ZUl0ZW1Vc2luZ1BhdGggIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuQWRkVmFsaWRhdGVVcGRhdGVJdGVtVXNpbmdQYXRoLnJlc3VsdHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlzdDtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlU2VjdXJhYmxlKSk7XG5cbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgQ29sbGVjdGlvbiBvZiBjb21tZW50c1xyXG4gKi9cclxudmFyIENvbW1lbnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbW1lbnRzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tbWVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQ29tbWVudHNfMSA9IENvbW1lbnRzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGNvbW1lbnQgdG8gdGhpcyBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZm8gQ29tbWVudCBpbmZvcm1hdGlvbiB0byBhZGRcclxuICAgICAqL1xyXG4gICAgQ29tbWVudHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodHlwZW9mIGluZm8gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgaW5mbyA9IHsgdGV4dDogaW5mbyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9zdEJvZHkgPSBqc1MoZXh0ZW5kKG1ldGFkYXRhKFwiTWljcm9zb2Z0LlNoYXJlUG9pbnQuQ29tbWVudHMuY29tbWVudFwiKSwgaW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKENvbW1lbnRzXzEsIG51bGwpLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHkgfSkudGhlbihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKF90aGlzLmdldEJ5SWQoZC5pZCksIGQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGNvbW1lbnQgYnkgaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgSWQgb2YgdGhlIGNvbW1lbnQgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBDb21tZW50cy5wcm90b3R5cGUuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBjID0gbmV3IENvbW1lbnQodGhpcyk7XHJcbiAgICAgICAgYy5jb25jYXQoXCIoXCIgKyBpZCArIFwiKVwiKTtcclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgYWxsIHRoZSBjb21tZW50cyBpbiB0aGlzIGNvbGxlY3Rpb25cclxuICAgICAqL1xyXG4gICAgQ29tbWVudHMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKENvbW1lbnRzXzEsIFwiRGVsZXRlQWxsXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIENvbW1lbnRzXzE7XHJcbiAgICBDb21tZW50cyA9IENvbW1lbnRzXzEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcImNvbW1lbnRzXCIpXHJcbiAgICBdLCBDb21tZW50cyk7XHJcbiAgICByZXR1cm4gQ29tbWVudHM7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24pKTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjb21tZW50XHJcbiAqL1xyXG52YXIgQ29tbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb21tZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tbWVudCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tbWVudC5wcm90b3R5cGUsIFwicmVwbGllc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGllcyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogTGlrZXMgdGhlIGNvbW1lbnQgYXMgdGhlIGN1cnJlbnQgdXNlclxyXG4gICAgICovXHJcbiAgICBDb21tZW50LnByb3RvdHlwZS5saWtlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKENvbW1lbnQsIFwiTGlrZVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVW5saWtlcyB0aGUgY29tbWVudCBhcyB0aGUgY3VycmVudCB1c2VyXHJcbiAgICAgKi9cclxuICAgIENvbW1lbnQucHJvdG90eXBlLnVubGlrZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShDb21tZW50LCBcIlVubGlrZVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGlzIGNvbW1lbnRcclxuICAgICAqL1xyXG4gICAgQ29tbWVudC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKENvbW1lbnQsIFwiRGVsZXRlQ29tbWVudFwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21tZW50O1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIENvbGxlY3Rpb24gb2YgY29tbWVudHNcclxuICovXHJcbnZhciBSZXBsaWVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJlcGxpZXMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZXBsaWVzKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFJlcGxpZXNfMSA9IFJlcGxpZXM7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgcmVwbHkgdG8gdGhpcyBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZm8gQ29tbWVudCBpbmZvcm1hdGlvbiB0byBhZGRcclxuICAgICAqL1xyXG4gICAgUmVwbGllcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICBpZiAodHlwZW9mIGluZm8gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgaW5mbyA9IHsgdGV4dDogaW5mbyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9zdEJvZHkgPSBqc1MoZXh0ZW5kKG1ldGFkYXRhKFwiTWljcm9zb2Z0LlNoYXJlUG9pbnQuQ29tbWVudHMuY29tbWVudFwiKSwgaW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFJlcGxpZXNfMSwgbnVsbCkucG9zdENvcmUoeyBib2R5OiBwb3N0Qm9keSB9KS50aGVuKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQobmV3IENvbW1lbnQob2RhdGFVcmxGcm9tKGQpKSwgZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIFJlcGxpZXNfMTtcclxuICAgIFJlcGxpZXMgPSBSZXBsaWVzXzEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcInJlcGxpZXNcIilcclxuICAgIF0sIFJlcGxpZXMpO1xyXG4gICAgcmV0dXJuIFJlcGxpZXM7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24pKTtcblxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIGNvbGxlY3Rpb24gb2YgSXRlbSBvYmplY3RzXHJcbiAqXHJcbiAqL1xyXG52YXIgSXRlbXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSXRlbXMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBJdGVtc18xID0gSXRlbXM7XHJcbiAgICAvKipcclxuICAgICogR2V0cyBhbiBJdGVtIGJ5IGlkXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSBpZCBUaGUgaW50ZWdlciBpZCBvZiB0aGUgaXRlbSB0byByZXRyaWV2ZVxyXG4gICAgKi9cclxuICAgIEl0ZW1zLnByb3RvdHlwZS5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIGkgPSBuZXcgSXRlbSh0aGlzKTtcclxuICAgICAgICBpLmNvbmNhdChcIihcIiArIGlkICsgXCIpXCIpO1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBCQ1MgSXRlbSBieSBzdHJpbmcgaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RyaW5nSWQgVGhlIHN0cmluZyBpZCBvZiB0aGUgQkNTIGl0ZW0gdG8gcmV0cmlldmVcclxuICAgICAqL1xyXG4gICAgSXRlbXMucHJvdG90eXBlLmdldEl0ZW1CeVN0cmluZ0lkID0gZnVuY3Rpb24gKHN0cmluZ0lkKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlcyBhbiBpdGVtIHdpdGggdGhlIHBhcmVudCBsaXN0IHBhdGggYW5kIGFwcGVuZCBvdXQgbWV0aG9kIGNhbGxcclxuICAgICAgICByZXR1cm4gbmV3IEl0ZW0odGhpcy5wYXJlbnRVcmwsIFwiZ2V0SXRlbUJ5U3RyaW5nSWQoJ1wiICsgc3RyaW5nSWQgKyBcIicpXCIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgaXRlbXMgKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvb2ZmaWNlL2ZwMTQyMzg1LmFzcHgjc2VjdGlvblNlY3Rpb242KVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBza2lwIFRoZSBzdGFydGluZyBpZCB3aGVyZSB0aGUgcGFnZSBzaG91bGQgc3RhcnQsIHVzZSB3aXRoIHRvcCB0byBzcGVjaWZ5IHBhZ2VzXHJcbiAgICAgKiBAcGFyYW0gcmV2ZXJzZSBJdCB0cnVlIHRoZSBQYWdlZFByZXY9dHJ1ZSBwYXJhbWV0ZXIgaXMgYWRkZWQgYWxsb3dpbmcgYmFja3dhcmRzIG5hdmlnYXRpb24gaW4gdGhlIGNvbGxlY3Rpb25cclxuICAgICAqL1xyXG4gICAgSXRlbXMucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoc2tpcCwgcmV2ZXJzZSkge1xyXG4gICAgICAgIGlmIChyZXZlcnNlID09PSB2b2lkIDApIHsgcmV2ZXJzZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKHJldmVyc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeS5zZXQoXCIkc2tpcHRva2VuXCIsIGVuY29kZVVSSUNvbXBvbmVudChcIlBhZ2VkPVRSVUUmUGFnZWRQcmV2PVRSVUUmcF9JRD1cIiArIHNraXApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVlcnkuc2V0KFwiJHNraXB0b2tlblwiLCBlbmNvZGVVUklDb21wb25lbnQoXCJQYWdlZD1UUlVFJnBfSUQ9XCIgKyBza2lwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGNvbGxlY3Rpb24gZGVzaWduZWQgdG8gYWlkIGluIHBhZ2luZyB0aHJvdWdoIGRhdGFcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIEl0ZW1zLnByb3RvdHlwZS5nZXRQYWdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQobmV3IFBhZ2VkSXRlbUNvbGxlY3Rpb25QYXJzZXIodGhpcykpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgdGhlIGl0ZW1zIGluIGEgbGlzdCwgcmVnYXJkbGVzcyBvZiBjb3VudC4gRG9lcyBub3Qgc3VwcG9ydCBiYXRjaGluZyBvciBjYWNoaW5nXHJcbiAgICAgKlxyXG4gICAgICogIEBwYXJhbSByZXF1ZXN0U2l6ZSBOdW1iZXIgb2YgaXRlbXMgdG8gcmV0dXJuIGluIGVhY2ggcmVxdWVzdCAoRGVmYXVsdDogMjAwMClcclxuICAgICAqICBAcGFyYW0gYWNjZXB0SGVhZGVyIEFsbG93cyBmb3Igc2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIEFjY2VwdCBoZWFkZXIgZm9yIFNQIDIwMTMgc3VwcG9ydFxyXG4gICAgICovXHJcbiAgICBJdGVtcy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKHJlcXVlc3RTaXplLCBhY2NlcHRIZWFkZXIpIHtcclxuICAgICAgICBpZiAocmVxdWVzdFNpemUgPT09IHZvaWQgMCkgeyByZXF1ZXN0U2l6ZSA9IDIwMDA7IH1cclxuICAgICAgICBpZiAoYWNjZXB0SGVhZGVyID09PSB2b2lkIDApIHsgYWNjZXB0SGVhZGVyID0gXCJhcHBsaWNhdGlvbi9qc29uO29kYXRhPW5vbWV0YWRhdGFcIjsgfVxyXG4gICAgICAgIExvZ2dlci53cml0ZShcIkNhbGxpbmcgaXRlbXMuZ2V0QWxsIHNob3VsZCBiZSBkb25lIHNwYXJpbmdseS4gRW5zdXJlIHRoaXMgaXMgdGhlIGNvcnJlY3QgY2hvaWNlLiBJZiB5b3UgYXJlIHVuc3VyZSwgaXQgaXMgbm90LlwiLCAyIC8qIFdhcm5pbmcgKi8pO1xyXG4gICAgICAgIC8vIHRoaXMgd2lsbCBiZSB1c2VkIGZvciB0aGUgYWN0dWFsIHF1ZXJ5XHJcbiAgICAgICAgLy8gYW5kIHdlIHNldCBubyBtZXRhZGF0YSBoZXJlIHRvIHRyeSBhbmQgcmVkdWNlIHRyYWZmaWNcclxuICAgICAgICB2YXIgaXRlbXMgPSBuZXcgSXRlbXNfMSh0aGlzLCBcIlwiKS50b3AocmVxdWVzdFNpemUpLmNvbmZpZ3VyZSh7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgIFwiQWNjZXB0XCI6IGFjY2VwdEhlYWRlcixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBsZXQncyBjb3B5IG92ZXIgdGhlIG9kYXRhIHF1ZXJ5IHBhcmFtcyB0aGF0IGNhbiBiZSBhcHBsaWVkXHJcbiAgICAgICAgLy8gJHRvcCAtIGFsbG93IHNldHRpbmcgdGhlIHBhZ2Ugc2l6ZSB0aGlzIHdheSAob3ZlcnJpZGUgd2hhdCB3ZSBkaWQgYWJvdmUpXHJcbiAgICAgICAgLy8gJHNlbGVjdCAtIGFsbG93IHBpY2tpbmcgdGhlIHJldHVybiBmaWVsZHMgKGdvb2QgYmVoYXZpb3IpXHJcbiAgICAgICAgLy8gJGZpbHRlciAtIGFsbG93IHNldHRpbmcgYSBmaWx0ZXIsIHRob3VnaCB0aGlzIG1heSBmYWlsIGR1ZSBmb3IgbGFyZ2UgbGlzdHNcclxuICAgICAgICB0aGlzLnF1ZXJ5LmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcclxuICAgICAgICAgICAgaWYgKC9eXFwkc2VsZWN0fGZpbHRlcnx0b3B8ZXhwYW5kJC9pLnRlc3QoaykpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1zLnF1ZXJ5LnNldChrLCB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGdpdmUgYmFjayB0aGUgcHJvbWlzZVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBldmVudHVhbGx5IGhvbGQgdGhlIGl0ZW1zIHdlIHJldHVyblxyXG4gICAgICAgICAgICB2YXIgaXRlbXNDb2xsZWN0b3IgPSBbXTtcclxuICAgICAgICAgICAgLy8gYWN0aW9uIHRoYXQgd2lsbCBnYXRoZXIgdXAgb3VyIHJlc3VsdHMgcmVjdXJzaXZlbHlcclxuICAgICAgICAgICAgdmFyIGdhdGhlcmVyID0gZnVuY3Rpb24gKGxhc3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhhdCBzZXQgb2YgcmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgW10ucHVzaC5hcHBseShpdGVtc0NvbGxlY3RvciwgbGFzdC5yZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbW9yZSwgcmVwZWF0IC0gb3RoZXJ3aXNlIHJlc29sdmUgd2l0aCB0aGUgY29sbGVjdGVkIGl0ZW1zXHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdC5oYXNOZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5nZXROZXh0KCkudGhlbihnYXRoZXJlcikuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXRlbXNDb2xsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBzdGFydCB0aGUgY3ljbGVcclxuICAgICAgICAgICAgaXRlbXMuZ2V0UGFnZWQoKS50aGVuKGdhdGhlcmVyKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3BlcnRpZXMgVGhlIG5ldyBpdGVtcydzIHByb3BlcnRpZXNcclxuICAgICAqIEBwYXJhbSBsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSBUaGUgdHlwZSBuYW1lIG9mIHRoZSBsaXN0J3MgZW50aXRpZXNcclxuICAgICAqL1xyXG4gICAgSXRlbXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMgPT09IHZvaWQgMCkgeyBwcm9wZXJ0aWVzID0ge307IH1cclxuICAgICAgICBpZiAobGlzdEl0ZW1FbnRpdHlUeXBlRnVsbE5hbWUgPT09IHZvaWQgMCkgeyBsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSA9IG51bGw7IH1cclxuICAgICAgICB2YXIgcmVtb3ZlRGVwZW5kZW5jeSA9IHRoaXMuYWRkQmF0Y2hEZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTGlzdEl0ZW1FbnRpdHlUeXBlTmFtZShsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSkudGhlbihmdW5jdGlvbiAobGlzdEl0ZW1FbnRpdHlUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3N0Qm9keSA9IGpzUyhleHRlbmQobWV0YWRhdGEobGlzdEl0ZW1FbnRpdHlUeXBlKSwgcHJvcGVydGllcykpO1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IF90aGlzLmNsb25lKEl0ZW1zXzEsIFwiXCIpLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHkgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IF90aGlzLmdldEJ5SWQoZGF0YS5JZCksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVtb3ZlRGVwZW5kZW5jeSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgd2UgaGF2ZSB0aGUgcHJvcGVyIGxpc3QgaXRlbSBlbnRpdHkgdHlwZSBuYW1lLCBlaXRoZXIgZnJvbSB0aGUgdmFsdWUgcHJvdmlkZWQgb3IgZnJvbSB0aGUgbGlzdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYW5kaWRhdGVsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSBUaGUgcG90ZW50aWFsIHR5cGUgbmFtZVxyXG4gICAgICovXHJcbiAgICBJdGVtcy5wcm90b3R5cGUuZW5zdXJlTGlzdEl0ZW1FbnRpdHlUeXBlTmFtZSA9IGZ1bmN0aW9uIChjYW5kaWRhdGVsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSA/XHJcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShjYW5kaWRhdGVsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSkgOlxyXG4gICAgICAgICAgICB0aGlzLmdldFBhcmVudChMaXN0KS5nZXRMaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSgpO1xyXG4gICAgfTtcclxuICAgIHZhciBJdGVtc18xO1xyXG4gICAgSXRlbXMgPSBJdGVtc18xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJpdGVtc1wiKVxyXG4gICAgXSwgSXRlbXMpO1xyXG4gICAgcmV0dXJuIEl0ZW1zO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmluZXMgYSBzaW5nbGUgSXRlbSBpbnN0YW5jZVxyXG4gKlxyXG4gKi9cclxudmFyIEl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSXRlbSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEl0ZW0oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlIHRoaXMgaXRlbVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGVUYWcgVmFsdWUgdXNlZCBpbiB0aGUgSUYtTWF0Y2ggaGVhZGVyLCBieSBkZWZhdWx0IFwiKlwiXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3RoaXMuZGVsZXRlID0gX3RoaXMuX2RlbGV0ZVdpdGhFVGFnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJdGVtLnByb3RvdHlwZSwgXCJhdHRhY2htZW50RmlsZXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHNldCBvZiBhdHRhY2htZW50cyBmb3IgdGhpcyBpdGVtXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdHRhY2htZW50RmlsZXModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXRlbS5wcm90b3R5cGUsIFwiY29udGVudFR5cGVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNvbnRlbnQgdHlwZSBmb3IgdGhpcyBpdGVtXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250ZW50VHlwZSh0aGlzLCBcIkNvbnRlbnRUeXBlXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEl0ZW0ucHJvdG90eXBlLCBcImNvbW1lbnRzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjb2xsZWN0aW9uIG9mIGNvbW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxpc3QgaXRlbVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbW1lbnRzKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEl0ZW0ucHJvdG90eXBlLCBcImVmZmVjdGl2ZUJhc2VQZXJtaXNzaW9uc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZWZmZWN0aXZlIGJhc2UgcGVybWlzc2lvbnMgZm9yIHRoZSBpdGVtXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlKHRoaXMsIFwiRWZmZWN0aXZlQmFzZVBlcm1pc3Npb25zXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEl0ZW0ucHJvdG90eXBlLCBcImVmZmVjdGl2ZUJhc2VQZXJtaXNzaW9uc0ZvclVJXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBlZmZlY3RpdmUgYmFzZSBwZXJtaXNzaW9ucyBmb3IgdGhlIGl0ZW0gaW4gYSBVSSBjb250ZXh0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlKHRoaXMsIFwiRWZmZWN0aXZlQmFzZVBlcm1pc3Npb25zRm9yVUlcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXRlbS5wcm90b3R5cGUsIFwiZmllbGRWYWx1ZXNBc0hUTUxcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGZpZWxkIHZhbHVlcyBmb3IgdGhpcyBsaXN0IGl0ZW0gaW4gdGhlaXIgSFRNTCByZXByZXNlbnRhdGlvblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKHRoaXMsIFwiRmllbGRWYWx1ZXNBc0hUTUxcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXRlbS5wcm90b3R5cGUsIFwiZmllbGRWYWx1ZXNBc1RleHRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGZpZWxkIHZhbHVlcyBmb3IgdGhpcyBsaXN0IGl0ZW0gaW4gdGhlaXIgdGV4dCByZXByZXNlbnRhdGlvblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKHRoaXMsIFwiRmllbGRWYWx1ZXNBc1RleHRcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXRlbS5wcm90b3R5cGUsIFwiZmllbGRWYWx1ZXNGb3JFZGl0XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBmaWVsZCB2YWx1ZXMgZm9yIHRoaXMgbGlzdCBpdGVtIGZvciB1c2UgaW4gZWRpdGluZyBjb250cm9sc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKHRoaXMsIFwiRmllbGRWYWx1ZXNGb3JFZGl0XCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEl0ZW0ucHJvdG90eXBlLCBcImZvbGRlclwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZm9sZGVyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxpc3QgaXRlbSAoaWYgdGhpcyBpdGVtIHJlcHJlc2VudHMgYSBmb2xkZXIpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb2xkZXIodGhpcywgXCJmb2xkZXJcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSXRlbS5wcm90b3R5cGUsIFwiZmlsZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZm9sZGVyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxpc3QgaXRlbSAoaWYgdGhpcyBpdGVtIHJlcHJlc2VudHMgYSBmb2xkZXIpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWxlKHRoaXMsIFwiZmlsZVwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJdGVtLnByb3RvdHlwZSwgXCJ2ZXJzaW9uc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY29sbGVjdGlvbiBvZiB2ZXJzaW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBpdGVtXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSXRlbVZlcnNpb25zKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoaXMgbGlzdCBpbnRhbmNlIHdpdGggdGhlIHN1cHBsaWVkIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBBIHBsYWluIG9iamVjdCBoYXNoIG9mIHZhbHVlcyB0byB1cGRhdGUgZm9yIHRoZSBsaXN0XHJcbiAgICAgKiBAcGFyYW0gZVRhZyBWYWx1ZSB1c2VkIGluIHRoZSBJRi1NYXRjaCBoZWFkZXIsIGJ5IGRlZmF1bHQgXCIqXCJcclxuICAgICAqIEBwYXJhbSBsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSBUaGUgdHlwZSBuYW1lIG9mIHRoZSBsaXN0J3MgZW50aXRpZXNcclxuICAgICAqL1xyXG4gICAgSXRlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHByb3BlcnRpZXMsIGVUYWcsIGxpc3RJdGVtRW50aXR5VHlwZUZ1bGxOYW1lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZVRhZyA9PT0gdm9pZCAwKSB7IGVUYWcgPSBcIipcIjsgfVxyXG4gICAgICAgIGlmIChsaXN0SXRlbUVudGl0eVR5cGVGdWxsTmFtZSA9PT0gdm9pZCAwKSB7IGxpc3RJdGVtRW50aXR5VHlwZUZ1bGxOYW1lID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVEZXBlbmRlbmN5ID0gX3RoaXMuYWRkQmF0Y2hEZXBlbmRlbmN5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbnN1cmVMaXN0SXRlbUVudGl0eVR5cGVOYW1lKGxpc3RJdGVtRW50aXR5VHlwZUZ1bGxOYW1lKS50aGVuKGZ1bmN0aW9uIChsaXN0SXRlbUVudGl0eVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3N0Qm9keSA9IGpzUyhleHRlbmQobWV0YWRhdGEobGlzdEl0ZW1FbnRpdHlUeXBlKSwgcHJvcGVydGllcykpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlRGVwZW5kZW5jeSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5OiBwb3N0Qm9keSxcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSUYtTWF0Y2hcIjogZVRhZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJYLUhUVFAtTWV0aG9kXCI6IFwiTUVSR0VcIixcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSwgbmV3IEl0ZW1VcGRhdGVkUGFyc2VyKCkpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogX3RoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHJlamVjdChlKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjb2xsZWN0aW9uIG9mIHBlb3BsZSB3aG8gaGF2ZSBsaWtlZCB0aGlzIGl0ZW1cclxuICAgICAqL1xyXG4gICAgSXRlbS5wcm90b3R5cGUuZ2V0TGlrZWRCeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShJdGVtLCBcImxpa2VkQnlcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExpa2VzIHRoaXMgaXRlbSBhcyB0aGUgY3VycmVudCB1c2VyXHJcbiAgICAgKi9cclxuICAgIEl0ZW0ucHJvdG90eXBlLmxpa2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoSXRlbSwgXCJsaWtlXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpa2VzIHRoaXMgaXRlbSBhcyB0aGUgY3VycmVudCB1c2VyXHJcbiAgICAgKi9cclxuICAgIEl0ZW0ucHJvdG90eXBlLnVubGlrZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShJdGVtLCBcInVubGlrZVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIGxpc3QgaXRlbSB0byB0aGUgUmVjeWNsZSBCaW4gYW5kIHJldHVybnMgdGhlIGlkZW50aWZpZXIgb2YgdGhlIG5ldyBSZWN5Y2xlIEJpbiBpdGVtLlxyXG4gICAgICovXHJcbiAgICBJdGVtLnByb3RvdHlwZS5yZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEl0ZW0sIFwicmVjeWNsZVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnVsbCBVUkwgdG8gdGhlIFdPUEkgZnJhbWUuXHJcbiAgICAgKiBJZiB0aGVyZSBpcyBubyBhc3NvY2lhdGVkIFdPUEkgYXBwbGljYXRpb24sIG9yIG5vIGFzc29jaWF0ZWQgYWN0aW9uLCBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiBEaXNwbGF5IG1vZGU6IDA6IHZpZXcsIDE6IGVkaXQsIDI6IG1vYmlsZVZpZXcsIDM6IGludGVyYWN0aXZlUHJldmlld1xyXG4gICAgICovXHJcbiAgICBJdGVtLnByb3RvdHlwZS5nZXRXb3BpRnJhbWVVcmwgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gdm9pZCAwKSB7IGFjdGlvbiA9IDA7IH1cclxuICAgICAgICB2YXIgaSA9IHRoaXMuY2xvbmUoSXRlbSwgXCJnZXRXT1BJRnJhbWVVcmwoQGFjdGlvbilcIik7XHJcbiAgICAgICAgaS5xdWVyeS5zZXQoXCJAYWN0aW9uXCIsIGFjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGkucG9zdENvcmUoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSB2ZXJib3NlIG1vZGVcclxuICAgICAgICAgICAgaWYgKGhPUChkYXRhLCBcIkdldFdPUElGcmFtZVVybFwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuR2V0V09QSUZyYW1lVXJsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGVzIGFuZCBzZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uIG9mIGZpZWxkcyBmb3IgdGhlIGxpc3QgaXRlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm9ybVZhbHVlcyBUaGUgZmllbGRzIHRvIGNoYW5nZSBhbmQgdGhlaXIgbmV3IHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBuZXdEb2N1bWVudFVwZGF0ZSB0cnVlIGlmIHRoZSBsaXN0IGl0ZW0gaXMgYSBkb2N1bWVudCBiZWluZyB1cGRhdGVkIGFmdGVyIHVwbG9hZDsgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBJdGVtLnByb3RvdHlwZS52YWxpZGF0ZVVwZGF0ZUxpc3RJdGVtID0gZnVuY3Rpb24gKGZvcm1WYWx1ZXMsIG5ld0RvY3VtZW50VXBkYXRlKSB7XHJcbiAgICAgICAgaWYgKG5ld0RvY3VtZW50VXBkYXRlID09PSB2b2lkIDApIHsgbmV3RG9jdW1lbnRVcGRhdGUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEl0ZW0sIFwidmFsaWRhdGV1cGRhdGVsaXN0aXRlbVwiKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyh7IFwiZm9ybVZhbHVlc1wiOiBmb3JtVmFsdWVzLCBiTmV3RG9jdW1lbnRVcGRhdGU6IG5ld0RvY3VtZW50VXBkYXRlIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB3ZSBoYXZlIHRoZSBwcm9wZXIgbGlzdCBpdGVtIGVudGl0eSB0eXBlIG5hbWUsIGVpdGhlciBmcm9tIHRoZSB2YWx1ZSBwcm92aWRlZCBvciBmcm9tIHRoZSBsaXN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbmRpZGF0ZWxpc3RJdGVtRW50aXR5VHlwZUZ1bGxOYW1lIFRoZSBwb3RlbnRpYWwgdHlwZSBuYW1lXHJcbiAgICAgKi9cclxuICAgIEl0ZW0ucHJvdG90eXBlLmVuc3VyZUxpc3RJdGVtRW50aXR5VHlwZU5hbWUgPSBmdW5jdGlvbiAoY2FuZGlkYXRlbGlzdEl0ZW1FbnRpdHlUeXBlRnVsbE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlbGlzdEl0ZW1FbnRpdHlUeXBlRnVsbE5hbWUgP1xyXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoY2FuZGlkYXRlbGlzdEl0ZW1FbnRpdHlUeXBlRnVsbE5hbWUpIDpcclxuICAgICAgICAgICAgdGhpcy5nZXRQYXJlbnQoTGlzdCwgdGhpcy5wYXJlbnRVcmwuc3Vic3RyKDAsIHRoaXMucGFyZW50VXJsLmxhc3RJbmRleE9mKFwiL1wiKSkpLmdldExpc3RJdGVtRW50aXR5VHlwZUZ1bGxOYW1lKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEl0ZW07XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZUl0ZW0pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIGNvbGxlY3Rpb24gb2YgVmVyc2lvbiBvYmplY3RzXHJcbiAqXHJcbiAqL1xyXG52YXIgSXRlbVZlcnNpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEl0ZW1WZXJzaW9ucywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEl0ZW1WZXJzaW9ucygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2ZXJzaW9uIGJ5IGlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnNpb25JZCBUaGUgaWQgb2YgdGhlIHZlcnNpb24gdG8gcmV0cmlldmVcclxuICAgICAqL1xyXG4gICAgSXRlbVZlcnNpb25zLnByb3RvdHlwZS5nZXRCeUlkID0gZnVuY3Rpb24gKHZlcnNpb25JZCkge1xyXG4gICAgICAgIHZhciB2ID0gbmV3IEl0ZW1WZXJzaW9uKHRoaXMpO1xyXG4gICAgICAgIHYuY29uY2F0KFwiKFwiICsgdmVyc2lvbklkICsgXCIpXCIpO1xyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfTtcclxuICAgIEl0ZW1WZXJzaW9ucyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwidmVyc2lvbnNcIilcclxuICAgIF0sIEl0ZW1WZXJzaW9ucyk7XHJcbiAgICByZXR1cm4gSXRlbVZlcnNpb25zO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgVmVyc2lvbiBpbnN0YW5jZVxyXG4gKlxyXG4gKi9cclxudmFyIEl0ZW1WZXJzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEl0ZW1WZXJzaW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSXRlbVZlcnNpb24oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBEZWxldGUgYSBzcGVjaWZpYyB2ZXJzaW9uIG9mIGEgZmlsZS5cclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAcGFyYW0gZVRhZyBWYWx1ZSB1c2VkIGluIHRoZSBJRi1NYXRjaCBoZWFkZXIsIGJ5IGRlZmF1bHQgXCIqXCJcclxuICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmRlbGV0ZSA9IF90aGlzLl9kZWxldGVXaXRoRVRhZztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSXRlbVZlcnNpb247XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBwYWdpbmcgZnVuY3Rpb25hbGl0eSBmb3IgbGlzdCBpdGVtc1xyXG4gKi9cclxudmFyIFBhZ2VkSXRlbUNvbGxlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYWdlZEl0ZW1Db2xsZWN0aW9uKHBhcmVudCwgbmV4dFVybCwgcmVzdWx0cykge1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMubmV4dFVybCA9IG5leHRVcmw7XHJcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gcmVzdWx0cztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlZEl0ZW1Db2xsZWN0aW9uLnByb3RvdHlwZSwgXCJoYXNOZXh0XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0cnVlIHRoZXJlIGFyZSBtb3JlIHJlc3VsdHMgYXZhaWxhYmxlIGluIHRoZSBzZXQsIG90aGVyd2lzZSB0aGVyZSBhcmUgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5uZXh0VXJsID09PSBcInN0cmluZ1wiICYmIHRoaXMubmV4dFVybC5sZW5ndGggPiAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHNldCBvZiByZXN1bHRzLCBvciByZXNvbHZlcyB0byBudWxsIGlmIG5vIHJlc3VsdHMgYXJlIGF2YWlsYWJsZVxyXG4gICAgICovXHJcbiAgICBQYWdlZEl0ZW1Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc05leHQpIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gbmV3IEl0ZW1zKHRoaXMubmV4dFVybCwgbnVsbCkuY29uZmlndXJlRnJvbSh0aGlzLnBhcmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5nZXRQYWdlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIobnVsbCk7IH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQYWdlZEl0ZW1Db2xsZWN0aW9uO1xyXG59KCkpO1xyXG52YXIgUGFnZWRJdGVtQ29sbGVjdGlvblBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQYWdlZEl0ZW1Db2xsZWN0aW9uUGFyc2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGFnZWRJdGVtQ29sbGVjdGlvblBhcnNlcihfcGFyZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBQYWdlZEl0ZW1Db2xsZWN0aW9uUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuaGFuZGxlRXJyb3IociwgcmVqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgci5qc29uKCkudGhlbihmdW5jdGlvbiAoanNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VXJsID0gaE9QKGpzb24sIFwiZFwiKSAmJiBoT1AoanNvbi5kLCBcIl9fbmV4dFwiKSA/IGpzb24uZC5fX25leHQgOiBqc29uW1wib2RhdGEubmV4dExpbmtcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgUGFnZWRJdGVtQ29sbGVjdGlvbihfdGhpcy5fcGFyZW50LCBuZXh0VXJsLCBfdGhpcy5wYXJzZU9EYXRhSlNPTihqc29uKSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGFnZWRJdGVtQ29sbGVjdGlvblBhcnNlcjtcclxufShPRGF0YVBhcnNlckJhc2UpKTtcclxudmFyIEl0ZW1VcGRhdGVkUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEl0ZW1VcGRhdGVkUGFyc2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSXRlbVVwZGF0ZWRQYXJzZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgSXRlbVVwZGF0ZWRQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5oYW5kbGVFcnJvcihyLCByZWplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICBcIm9kYXRhLmV0YWdcIjogci5oZWFkZXJzLmdldChcImV0YWdcIiksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJdGVtVXBkYXRlZFBhcnNlcjtcclxufShPRGF0YVBhcnNlckJhc2UpKTtcblxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIGNvbGxlY3Rpb24gb2YgRmlsZSBvYmplY3RzXHJcbiAqXHJcbiAqL1xyXG52YXIgRmlsZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmlsZXMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGaWxlcygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBGaWxlc18xID0gRmlsZXM7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBGaWxlIGJ5IGZpbGVuYW1lXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUsIGluY2x1ZGluZyBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIEZpbGVzLnByb3RvdHlwZS5nZXRCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBmID0gbmV3IEZpbGUodGhpcyk7XHJcbiAgICAgICAgZi5jb25jYXQoXCIoJ1wiICsgbmFtZSArIFwiJylcIik7XHJcbiAgICAgICAgcmV0dXJuIGY7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWRzIGEgZmlsZS4gTm90IHN1cHBvcnRlZCBmb3IgYmF0Y2hpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBmb2xkZXItcmVsYXRpdmUgdXJsIG9mIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGZpbGUgY29udGVudHMgYmxvYi5cclxuICAgICAqIEBwYXJhbSBzaG91bGRPdmVyV3JpdGUgU2hvdWxkIGEgZmlsZSB3aXRoIHRoZSBzYW1lIG5hbWUgaW4gdGhlIHNhbWUgbG9jYXRpb24gYmUgb3ZlcndyaXR0ZW4/IChkZWZhdWx0OiB0cnVlKVxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBGaWxlIGFuZCB0aGUgcmF3IHJlc3BvbnNlLlxyXG4gICAgICovXHJcbiAgICBGaWxlcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHVybCwgY29udGVudCwgc2hvdWxkT3ZlcldyaXRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoc2hvdWxkT3ZlcldyaXRlID09PSB2b2lkIDApIHsgc2hvdWxkT3ZlcldyaXRlID0gdHJ1ZTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRmlsZXNfMSh0aGlzLCBcImFkZChvdmVyd3JpdGU9XCIgKyBzaG91bGRPdmVyV3JpdGUgKyBcIix1cmw9J1wiICsgdXJsICsgXCInKVwiKVxyXG4gICAgICAgICAgICAucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBjb250ZW50LFxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZSxcclxuICAgICAgICAgICAgICAgIGZpbGU6IF90aGlzLmdldEJ5TmFtZSh1cmwpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyBhIGZpbGUuIE5vdCBzdXBwb3J0ZWQgZm9yIGJhdGNoaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVybCBUaGUgZm9sZGVyLXJlbGF0aXZlIHVybCBvZiB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBCbG9iIGZpbGUgY29udGVudCB0byBhZGRcclxuICAgICAqIEBwYXJhbSBwcm9ncmVzcyBBIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHRyYWNrIHRoZSBwcm9ncmVzcyBvZiB0aGUgdXBsb2FkXHJcbiAgICAgKiBAcGFyYW0gc2hvdWxkT3ZlcldyaXRlIFNob3VsZCBhIGZpbGUgd2l0aCB0aGUgc2FtZSBuYW1lIGluIHRoZSBzYW1lIGxvY2F0aW9uIGJlIG92ZXJ3cml0dGVuPyAoZGVmYXVsdDogdHJ1ZSlcclxuICAgICAqIEBwYXJhbSBjaHVua1NpemUgVGhlIHNpemUgb2YgZWFjaCBmaWxlIHNsaWNlLCBpbiBieXRlcyAoZGVmYXVsdDogMTA0ODU3NjApXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IEZpbGUgYW5kIHRoZSByYXcgcmVzcG9uc2UuXHJcbiAgICAgKi9cclxuICAgIEZpbGVzLnByb3RvdHlwZS5hZGRDaHVua2VkID0gZnVuY3Rpb24gKHVybCwgY29udGVudCwgcHJvZ3Jlc3MsIHNob3VsZE92ZXJXcml0ZSwgY2h1bmtTaXplKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoc2hvdWxkT3ZlcldyaXRlID09PSB2b2lkIDApIHsgc2hvdWxkT3ZlcldyaXRlID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChjaHVua1NpemUgPT09IHZvaWQgMCkgeyBjaHVua1NpemUgPSAxMDQ4NTc2MDsgfVxyXG4gICAgICAgIHZhciBhZGRlciA9IHRoaXMuY2xvbmUoRmlsZXNfMSwgXCJhZGQob3ZlcndyaXRlPVwiICsgc2hvdWxkT3ZlcldyaXRlICsgXCIsdXJsPSdcIiArIHVybCArIFwiJylcIiwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBhZGRlci5wb3N0Q29yZSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdldEJ5TmFtZSh1cmwpOyB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gZmlsZS5zZXRDb250ZW50Q2h1bmtlZChjb250ZW50LCBwcm9ncmVzcywgY2h1bmtTaXplKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgZ2hvc3RlZCBmaWxlIHRvIGFuIGV4aXN0aW5nIGxpc3Qgb3IgZG9jdW1lbnQgbGlicmFyeS4gTm90IHN1cHBvcnRlZCBmb3IgYmF0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpbGVVcmwgVGhlIHNlcnZlci1yZWxhdGl2ZSB1cmwgd2hlcmUgeW91IHdhbnQgdG8gc2F2ZSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZUZpbGVUeXBlIFRoZSB0eXBlIG9mIHVzZSB0byBjcmVhdGUgdGhlIGZpbGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdGVtcGxhdGUgZmlsZSB0aGF0IHdhcyBhZGRlZCBhbmQgdGhlIHJhdyByZXNwb25zZS5cclxuICAgICAqL1xyXG4gICAgRmlsZXMucHJvdG90eXBlLmFkZFRlbXBsYXRlRmlsZSA9IGZ1bmN0aW9uIChmaWxlVXJsLCB0ZW1wbGF0ZUZpbGVUeXBlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGaWxlc18xLCBcImFkZFRlbXBsYXRlRmlsZSh1cmxvZmZpbGU9J1wiICsgZmlsZVVybCArIFwiJyx0ZW1wbGF0ZWZpbGV0eXBlPVwiICsgdGVtcGxhdGVGaWxlVHlwZSArIFwiKVwiLCBmYWxzZSlcclxuICAgICAgICAgICAgLnBvc3RDb3JlKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgZmlsZTogX3RoaXMuZ2V0QnlOYW1lKGZpbGVVcmwpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBGaWxlc18xO1xyXG4gICAgRmlsZXMgPSBGaWxlc18xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJmaWxlc1wiKVxyXG4gICAgXSwgRmlsZXMpO1xyXG4gICAgcmV0dXJuIEZpbGVzO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSBzaW5nbGUgRmlsZSBpbnN0YW5jZVxyXG4gKlxyXG4gKi9cclxudmFyIEZpbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRmlsZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZpbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpbGUucHJvdG90eXBlLCBcImxpc3RJdGVtQWxsRmllbGRzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgdmFsdWUgdGhhdCBzcGVjaWZpZXMgdGhlIGxpc3QgaXRlbSBmaWVsZCB2YWx1ZXMgZm9yIHRoZSBsaXN0IGl0ZW0gY29ycmVzcG9uZGluZyB0byB0aGUgZmlsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSh0aGlzLCBcImxpc3RJdGVtQWxsRmllbGRzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpbGUucHJvdG90eXBlLCBcInZlcnNpb25zXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgY29sbGVjdGlvbiBvZiB2ZXJzaW9uc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVyc2lvbnModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFwcHJvdmVzIHRoZSBmaWxlIHN1Ym1pdHRlZCBmb3IgY29udGVudCBhcHByb3ZhbCB3aXRoIHRoZSBzcGVjaWZpZWQgY29tbWVudC5cclxuICAgICAqIE9ubHkgZG9jdW1lbnRzIGluIGxpc3RzIHRoYXQgYXJlIGVuYWJsZWQgZm9yIGNvbnRlbnQgYXBwcm92YWwgY2FuIGJlIGFwcHJvdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb21tZW50IFRoZSBjb21tZW50IGZvciB0aGUgYXBwcm92YWwuXHJcbiAgICAgKi9cclxuICAgIEZpbGUucHJvdG90eXBlLmFwcHJvdmUgPSBmdW5jdGlvbiAoY29tbWVudCkge1xyXG4gICAgICAgIGlmIChjb21tZW50ID09PSB2b2lkIDApIHsgY29tbWVudCA9IFwiXCI7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGaWxlLCBcImFwcHJvdmUoY29tbWVudD0nXCIgKyBjb21tZW50ICsgXCInKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIGNodW5rIHVwbG9hZCBzZXNzaW9uIHdpdGhvdXQgc2F2aW5nIHRoZSB1cGxvYWRlZCBkYXRhLiBEb2VzIG5vdCBzdXBwb3J0IGJhdGNoaW5nLlxyXG4gICAgICogSWYgdGhlIGZpbGUgZG9lc27igJl0IGFscmVhZHkgZXhpc3QgaW4gdGhlIGxpYnJhcnksIHRoZSBwYXJ0aWFsbHkgdXBsb2FkZWQgZmlsZSB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAgICAgKiBVc2UgdGhpcyBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbiAoYXMgaW4gYSByZXF1ZXN0IHRvIGNhbmNlbCBhbiB1cGxvYWQpIG9yIGFuIGVycm9yIG9yIGV4Y2VwdGlvbi5cclxuICAgICAqIFVzZSB0aGUgdXBsb2FkSWQgdmFsdWUgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBTdGFydFVwbG9hZCBtZXRob2QgdGhhdCBzdGFydGVkIHRoZSB1cGxvYWQgc2Vzc2lvbi5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGN1cnJlbnRseSBhdmFpbGFibGUgb25seSBvbiBPZmZpY2UgMzY1LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cGxvYWRJZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHVwbG9hZCBzZXNzaW9uLlxyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS5jYW5jZWxVcGxvYWQgPSBmdW5jdGlvbiAodXBsb2FkSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGaWxlLCBcImNhbmNlbFVwbG9hZCh1cGxvYWRJZD1ndWlkJ1wiICsgdXBsb2FkSWQgKyBcIicpXCIsIGZhbHNlKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRoZSBmaWxlIGluIHRvIGEgZG9jdW1lbnQgbGlicmFyeSBiYXNlZCBvbiB0aGUgY2hlY2staW4gdHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29tbWVudCBBIGNvbW1lbnQgZm9yIHRoZSBjaGVjay1pbi4gSXRzIGxlbmd0aCBtdXN0IGJlIDw9IDEwMjMuXHJcbiAgICAgKiBAcGFyYW0gY2hlY2tpblR5cGUgVGhlIGNoZWNrLWluIHR5cGUgZm9yIHRoZSBmaWxlLlxyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS5jaGVja2luID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNoZWNraW5UeXBlKSB7XHJcbiAgICAgICAgaWYgKGNvbW1lbnQgPT09IHZvaWQgMCkgeyBjb21tZW50ID0gXCJcIjsgfVxyXG4gICAgICAgIGlmIChjaGVja2luVHlwZSA9PT0gdm9pZCAwKSB7IGNoZWNraW5UeXBlID0gQ2hlY2tpblR5cGUuTWFqb3I7IH1cclxuICAgICAgICBpZiAoY29tbWVudC5sZW5ndGggPiAxMDIzKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIG1heGltdW0gY29tbWVudCBsZW5ndGggaXMgMTAyMyBjaGFyYWN0ZXJzLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoRmlsZSwgXCJjaGVja2luKGNvbW1lbnQ9J1wiICsgY29tbWVudCArIFwiJyxjaGVja2ludHlwZT1cIiArIGNoZWNraW5UeXBlICsgXCIpXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgb3V0IHRoZSBmaWxlIGZyb20gYSBkb2N1bWVudCBsaWJyYXJ5LlxyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS5jaGVja291dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGaWxlLCBcImNoZWNrb3V0XCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhlIGZpbGUgdG8gdGhlIGRlc3RpbmF0aW9uIHVybC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBhYnNvbHV0ZSB1cmwgb3Igc2VydmVyIHJlbGF0aXZlIHVybCBvZiB0aGUgZGVzdGluYXRpb24gZmlsZSBwYXRoIHRvIGNvcHkgdG8uXHJcbiAgICAgKiBAcGFyYW0gc2hvdWxkT3ZlcldyaXRlIFNob3VsZCBhIGZpbGUgd2l0aCB0aGUgc2FtZSBuYW1lIGluIHRoZSBzYW1lIGxvY2F0aW9uIGJlIG92ZXJ3cml0dGVuP1xyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS5jb3B5VG8gPSBmdW5jdGlvbiAodXJsLCBzaG91bGRPdmVyV3JpdGUpIHtcclxuICAgICAgICBpZiAoc2hvdWxkT3ZlcldyaXRlID09PSB2b2lkIDApIHsgc2hvdWxkT3ZlcldyaXRlID0gdHJ1ZTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpbGUsIFwiY29weVRvKHN0cm5ld3VybD0nXCIgKyB1cmwgKyBcIicsYm92ZXJ3cml0ZT1cIiArIHNob3VsZE92ZXJXcml0ZSArIFwiKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIHRoaXMgZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZVRhZyBWYWx1ZSB1c2VkIGluIHRoZSBJRi1NYXRjaCBoZWFkZXIsIGJ5IGRlZmF1bHQgXCIqXCJcclxuICAgICAqL1xyXG4gICAgRmlsZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGVUYWcpIHtcclxuICAgICAgICBpZiAoZVRhZyA9PT0gdm9pZCAwKSB7IGVUYWcgPSBcIipcIjsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpbGUsIG51bGwpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgXCJJRi1NYXRjaFwiOiBlVGFnLFxyXG4gICAgICAgICAgICAgICAgXCJYLUhUVFAtTWV0aG9kXCI6IFwiREVMRVRFXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZW5pZXMgYXBwcm92YWwgZm9yIGEgZmlsZSB0aGF0IHdhcyBzdWJtaXR0ZWQgZm9yIGNvbnRlbnQgYXBwcm92YWwuXHJcbiAgICAgKiBPbmx5IGRvY3VtZW50cyBpbiBsaXN0cyB0aGF0IGFyZSBlbmFibGVkIGZvciBjb250ZW50IGFwcHJvdmFsIGNhbiBiZSBkZW5pZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbW1lbnQgVGhlIGNvbW1lbnQgZm9yIHRoZSBkZW5pYWwuXHJcbiAgICAgKi9cclxuICAgIEZpbGUucHJvdG90eXBlLmRlbnkgPSBmdW5jdGlvbiAoY29tbWVudCkge1xyXG4gICAgICAgIGlmIChjb21tZW50ID09PSB2b2lkIDApIHsgY29tbWVudCA9IFwiXCI7IH1cclxuICAgICAgICBpZiAoY29tbWVudC5sZW5ndGggPiAxMDIzKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIG1heGltdW0gY29tbWVudCBsZW5ndGggaXMgMTAyMyBjaGFyYWN0ZXJzLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoRmlsZSwgXCJkZW55KGNvbW1lbnQ9J1wiICsgY29tbWVudCArIFwiJylcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyB0aGUgY29udHJvbCBzZXQgdXNlZCB0byBhY2Nlc3MsIG1vZGlmeSwgb3IgYWRkIFdlYiBQYXJ0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBXZWIgUGFydCBQYWdlIGFuZCB2aWV3LlxyXG4gICAgICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgZmlsZSBpcyBub3QgYW4gQVNQWCBwYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzY29wZSBUaGUgV2ViUGFydHNQZXJzb25hbGl6YXRpb25TY29wZSB2aWV3IG9uIHRoZSBXZWIgUGFydHMgcGFnZS5cclxuICAgICAqL1xyXG4gICAgRmlsZS5wcm90b3R5cGUuZ2V0TGltaXRlZFdlYlBhcnRNYW5hZ2VyID0gZnVuY3Rpb24gKHNjb3BlKSB7XHJcbiAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSBXZWJQYXJ0c1BlcnNvbmFsaXphdGlvblNjb3BlLlNoYXJlZDsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTGltaXRlZFdlYlBhcnRNYW5hZ2VyKHRoaXMsIFwiZ2V0TGltaXRlZFdlYlBhcnRNYW5hZ2VyKHNjb3BlPVwiICsgc2NvcGUgKyBcIilcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgZmlsZSB0byB0aGUgc3BlY2lmaWVkIGRlc3RpbmF0aW9uIHVybC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBhYnNvbHV0ZSB1cmwgb3Igc2VydmVyIHJlbGF0aXZlIHVybCBvZiB0aGUgZGVzdGluYXRpb24gZmlsZSBwYXRoIHRvIG1vdmUgdG8uXHJcbiAgICAgKiBAcGFyYW0gbW92ZU9wZXJhdGlvbnMgVGhlIGJpdHdpc2UgTW92ZU9wZXJhdGlvbnMgdmFsdWUgZm9yIGhvdyB0byBtb3ZlIHRoZSBmaWxlLlxyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAodXJsLCBtb3ZlT3BlcmF0aW9ucykge1xyXG4gICAgICAgIGlmIChtb3ZlT3BlcmF0aW9ucyA9PT0gdm9pZCAwKSB7IG1vdmVPcGVyYXRpb25zID0gTW92ZU9wZXJhdGlvbnMuT3ZlcndyaXRlOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoRmlsZSwgXCJtb3ZlVG8obmV3dXJsPSdcIiArIHVybCArIFwiJyxmbGFncz1cIiArIG1vdmVPcGVyYXRpb25zICsgXCIpXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJtaXRzIHRoZSBmaWxlIGZvciBjb250ZW50IGFwcHJvdmFsIHdpdGggdGhlIHNwZWNpZmllZCBjb21tZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb21tZW50IFRoZSBjb21tZW50IGZvciB0aGUgcHVibGlzaGVkIGZpbGUuIEl0cyBsZW5ndGggbXVzdCBiZSA8PSAxMDIzLlxyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKGNvbW1lbnQpIHtcclxuICAgICAgICBpZiAoY29tbWVudCA9PT0gdm9pZCAwKSB7IGNvbW1lbnQgPSBcIlwiOyB9XHJcbiAgICAgICAgaWYgKGNvbW1lbnQubGVuZ3RoID4gMTAyMykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBtYXhpbXVtIGNvbW1lbnQgbGVuZ3RoIGlzIDEwMjMgY2hhcmFjdGVycy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpbGUsIFwicHVibGlzaChjb21tZW50PSdcIiArIGNvbW1lbnQgKyBcIicpXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgZmlsZSB0byB0aGUgUmVjeWNsZSBCaW4gYW5kIHJldHVybnMgdGhlIGlkZW50aWZpZXIgb2YgdGhlIG5ldyBSZWN5Y2xlIEJpbiBpdGVtLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBHVUlEIG9mIHRoZSByZWN5Y2xlZCBmaWxlLlxyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS5yZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpbGUsIFwicmVjeWNsZVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV2ZXJ0cyBhbiBleGlzdGluZyBjaGVja291dCBmb3IgdGhlIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS51bmRvQ2hlY2tvdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoRmlsZSwgXCJ1bmRvQ2hlY2tvdXRcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGZpbGUgZnJvbSBjb250ZW50IGFwcHJvdmFsIG9yIHVucHVibGlzaCBhIG1ham9yIHZlcnNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbW1lbnQgVGhlIGNvbW1lbnQgZm9yIHRoZSB1bnB1Ymxpc2ggb3BlcmF0aW9uLiBJdHMgbGVuZ3RoIG11c3QgYmUgPD0gMTAyMy5cclxuICAgICAqL1xyXG4gICAgRmlsZS5wcm90b3R5cGUudW5wdWJsaXNoID0gZnVuY3Rpb24gKGNvbW1lbnQpIHtcclxuICAgICAgICBpZiAoY29tbWVudCA9PT0gdm9pZCAwKSB7IGNvbW1lbnQgPSBcIlwiOyB9XHJcbiAgICAgICAgaWYgKGNvbW1lbnQubGVuZ3RoID4gMTAyMykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBtYXhpbXVtIGNvbW1lbnQgbGVuZ3RoIGlzIDEwMjMgY2hhcmFjdGVycy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpbGUsIFwidW5wdWJsaXNoKGNvbW1lbnQ9J1wiICsgY29tbWVudCArIFwiJylcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIGFzIHRleHQuIE5vdCBzdXBwb3J0ZWQgaW4gYmF0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpbGUsIFwiJHZhbHVlXCIsIGZhbHNlKS5nZXQobmV3IFRleHRQYXJzZXIoKSwgeyBoZWFkZXJzOiB7IFwiYmluYXJ5U3RyaW5nUmVzcG9uc2VCb2R5XCI6IFwidHJ1ZVwiIH0gfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBhcyBhIGJsb2IsIGRvZXMgbm90IHdvcmsgaW4gTm9kZS5qcy4gTm90IHN1cHBvcnRlZCBpbiBiYXRjaGluZy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIEZpbGUucHJvdG90eXBlLmdldEJsb2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoRmlsZSwgXCIkdmFsdWVcIiwgZmFsc2UpLmdldChuZXcgQmxvYlBhcnNlcigpLCB7IGhlYWRlcnM6IHsgXCJiaW5hcnlTdHJpbmdSZXNwb25zZUJvZHlcIjogXCJ0cnVlXCIgfSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgZmlsZSBhcyBhbiBBcnJheUJ1ZmZlciwgd29ya3MgaW4gTm9kZS5qcy4gTm90IHN1cHBvcnRlZCBpbiBiYXRjaGluZy5cclxuICAgICAqL1xyXG4gICAgRmlsZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEZpbGUsIFwiJHZhbHVlXCIsIGZhbHNlKS5nZXQobmV3IEJ1ZmZlclBhcnNlcigpLCB7IGhlYWRlcnM6IHsgXCJiaW5hcnlTdHJpbmdSZXNwb25zZUJvZHlcIjogXCJ0cnVlXCIgfSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgZmlsZSBhcyBhbiBBcnJheUJ1ZmZlciwgd29ya3MgaW4gTm9kZS5qcy4gTm90IHN1cHBvcnRlZCBpbiBiYXRjaGluZy5cclxuICAgICAqL1xyXG4gICAgRmlsZS5wcm90b3R5cGUuZ2V0SlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGaWxlLCBcIiR2YWx1ZVwiLCBmYWxzZSkuZ2V0KG5ldyBKU09OUGFyc2VyKCksIHsgaGVhZGVyczogeyBcImJpbmFyeVN0cmluZ1Jlc3BvbnNlQm9keVwiOiBcInRydWVcIiB9IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29udGVudCBvZiBhIGZpbGUsIGZvciBsYXJnZSBmaWxlcyB1c2Ugc2V0Q29udGVudENodW5rZWQuIE5vdCBzdXBwb3J0ZWQgaW4gYmF0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGZpbGUgY29udGVudFxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgRmlsZS5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGaWxlLCBcIiR2YWx1ZVwiLCBmYWxzZSkucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBjb250ZW50LFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBcIlgtSFRUUC1NZXRob2RcIjogXCJQVVRcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBuZXcgRmlsZShfdGhpcyk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYXNzb2NpYXRlZCBsaXN0IGl0ZW0gZm9yIHRoaXMgZm9sZGVyLCBsb2FkaW5nIHRoZSBkZWZhdWx0IHByb3BlcnRpZXNcclxuICAgICAqL1xyXG4gICAgRmlsZS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VsZWN0cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdHNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLmxpc3RJdGVtQWxsRmllbGRzO1xyXG4gICAgICAgIHJldHVybiBxLnNlbGVjdC5hcHBseShxLCBzZWxlY3RzKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQobmV3IEl0ZW0ob2RhdGFVcmxGcm9tKGQpKSwgZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjb250ZW50cyBvZiBhIGZpbGUgdXNpbmcgYSBjaHVua2VkIHVwbG9hZCBhcHByb2FjaC4gTm90IHN1cHBvcnRlZCBpbiBiYXRjaGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgZmlsZSB0byB1cGxvYWRcclxuICAgICAqIEBwYXJhbSBwcm9ncmVzcyBBIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHRyYWNrIHRoZSBwcm9ncmVzcyBvZiB0aGUgdXBsb2FkXHJcbiAgICAgKiBAcGFyYW0gY2h1bmtTaXplIFRoZSBzaXplIG9mIGVhY2ggZmlsZSBzbGljZSwgaW4gYnl0ZXMgKGRlZmF1bHQ6IDEwNDg1NzYwKVxyXG4gICAgICovXHJcbiAgICBGaWxlLnByb3RvdHlwZS5zZXRDb250ZW50Q2h1bmtlZCA9IGZ1bmN0aW9uIChmaWxlLCBwcm9ncmVzcywgY2h1bmtTaXplKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoY2h1bmtTaXplID09PSB2b2lkIDApIHsgY2h1bmtTaXplID0gMTA0ODU3NjA7IH1cclxuICAgICAgICBpZiAocHJvZ3Jlc3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaWxlU2l6ZSA9IGZpbGUuc2l6ZTtcclxuICAgICAgICB2YXIgYmxvY2tDb3VudCA9IHBhcnNlSW50KChmaWxlLnNpemUgLyBjaHVua1NpemUpLnRvU3RyaW5nKCksIDEwKSArICgoZmlsZS5zaXplICUgY2h1bmtTaXplID09PSAwKSA/IDEgOiAwKTtcclxuICAgICAgICB2YXIgdXBsb2FkSWQgPSBnZXRHVUlEKCk7XHJcbiAgICAgICAgLy8gc3RhcnQgdGhlIGNoYWluIHdpdGggdGhlIGZpcnN0IGZyYWdtZW50XHJcbiAgICAgICAgcHJvZ3Jlc3MoeyB1cGxvYWRJZDogdXBsb2FkSWQsIGJsb2NrTnVtYmVyOiAxLCBjaHVua1NpemU6IGNodW5rU2l6ZSwgY3VycmVudFBvaW50ZXI6IDAsIGZpbGVTaXplOiBmaWxlU2l6ZSwgc3RhZ2U6IFwic3RhcnRpbmdcIiwgdG90YWxCbG9ja3M6IGJsb2NrQ291bnQgfSk7XHJcbiAgICAgICAgdmFyIGNoYWluID0gdGhpcy5zdGFydFVwbG9hZCh1cGxvYWRJZCwgZmlsZS5zbGljZSgwLCBjaHVua1NpemUpKTtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIGNoYWluID0gY2hhaW4udGhlbihmdW5jdGlvbiAocG9pbnRlcikge1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MoeyB1cGxvYWRJZDogdXBsb2FkSWQsIGJsb2NrTnVtYmVyOiBpLCBjaHVua1NpemU6IGNodW5rU2l6ZSwgY3VycmVudFBvaW50ZXI6IHBvaW50ZXIsIGZpbGVTaXplOiBmaWxlU2l6ZSwgc3RhZ2U6IFwiY29udGludWVcIiwgdG90YWxCbG9ja3M6IGJsb2NrQ291bnQgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29udGludWVVcGxvYWQodXBsb2FkSWQsIHBvaW50ZXIsIGZpbGUuc2xpY2UocG9pbnRlciwgcG9pbnRlciArIGNodW5rU2l6ZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHNraXAgdGhlIGZpcnN0IGFuZCBsYXN0IGJsb2Nrc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYmxvY2tDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGFpbi50aGVuKGZ1bmN0aW9uIChwb2ludGVyKSB7XHJcbiAgICAgICAgICAgIHByb2dyZXNzKHsgdXBsb2FkSWQ6IHVwbG9hZElkLCBibG9ja051bWJlcjogYmxvY2tDb3VudCwgY2h1bmtTaXplOiBjaHVua1NpemUsIGN1cnJlbnRQb2ludGVyOiBwb2ludGVyLCBmaWxlU2l6ZTogZmlsZVNpemUsIHN0YWdlOiBcImZpbmlzaGluZ1wiLCB0b3RhbEJsb2NrczogYmxvY2tDb3VudCB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbmlzaFVwbG9hZCh1cGxvYWRJZCwgcG9pbnRlciwgZmlsZS5zbGljZShwb2ludGVyKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBuZXcgY2h1bmsgdXBsb2FkIHNlc3Npb24gYW5kIHVwbG9hZHMgdGhlIGZpcnN0IGZyYWdtZW50LlxyXG4gICAgICogVGhlIGN1cnJlbnQgZmlsZSBjb250ZW50IGlzIG5vdCBjaGFuZ2VkIHdoZW4gdGhpcyBtZXRob2QgY29tcGxldGVzLlxyXG4gICAgICogVGhlIG1ldGhvZCBpcyBpZGVtcG90ZW50IChhbmQgdGhlcmVmb3JlIGRvZXMgbm90IGNoYW5nZSB0aGUgcmVzdWx0KSBhcyBsb25nIGFzIHlvdSB1c2UgdGhlIHNhbWUgdmFsdWVzIGZvciB1cGxvYWRJZCBhbmQgc3RyZWFtLlxyXG4gICAgICogVGhlIHVwbG9hZCBzZXNzaW9uIGVuZHMgZWl0aGVyIHdoZW4geW91IHVzZSB0aGUgQ2FuY2VsVXBsb2FkIG1ldGhvZCBvciB3aGVuIHlvdSBzdWNjZXNzZnVsbHlcclxuICAgICAqIGNvbXBsZXRlIHRoZSB1cGxvYWQgc2Vzc2lvbiBieSBwYXNzaW5nIHRoZSByZXN0IG9mIHRoZSBmaWxlIGNvbnRlbnRzIHRocm91Z2ggdGhlIENvbnRpbnVlVXBsb2FkIGFuZCBGaW5pc2hVcGxvYWQgbWV0aG9kcy5cclxuICAgICAqIFRoZSBTdGFydFVwbG9hZCBhbmQgQ29udGludWVVcGxvYWQgbWV0aG9kcyByZXR1cm4gdGhlIHNpemUgb2YgdGhlIHJ1bm5pbmcgdG90YWwgb2YgdXBsb2FkZWQgZGF0YSBpbiBieXRlcyxcclxuICAgICAqIHNvIHlvdSBjYW4gcGFzcyB0aG9zZSByZXR1cm4gdmFsdWVzIHRvIHN1YnNlcXVlbnQgdXNlcyBvZiBDb250aW51ZVVwbG9hZCBhbmQgRmluaXNoVXBsb2FkLlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY3VycmVudGx5IGF2YWlsYWJsZSBvbmx5IG9uIE9mZmljZSAzNjUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVwbG9hZElkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdXBsb2FkIHNlc3Npb24uXHJcbiAgICAgKiBAcGFyYW0gZnJhZ21lbnQgVGhlIGZpbGUgY29udGVudHMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUgdG90YWwgdXBsb2FkZWQgZGF0YSBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgRmlsZS5wcm90b3R5cGUuc3RhcnRVcGxvYWQgPSBmdW5jdGlvbiAodXBsb2FkSWQsIGZyYWdtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoRmlsZSwgXCJzdGFydFVwbG9hZCh1cGxvYWRJZD1ndWlkJ1wiICsgdXBsb2FkSWQgKyBcIicpXCIsIGZhbHNlKVxyXG4gICAgICAgICAgICAucG9zdENvcmUoeyBib2R5OiBmcmFnbWVudCB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICAvLyBXaGVuIE9EYXRhPXZlcmJvc2UgdGhlIHBheWxvYWQgaGFzIHRoZSBmb2xsb3dpbmcgc2hhcGU6XHJcbiAgICAgICAgICAgIC8vIHsgU3RhcnRVcGxvYWQ6IFwiMTA0ODU3NjBcIiB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbiA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4uU3RhcnRVcGxvYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb250aW51ZXMgdGhlIGNodW5rIHVwbG9hZCBzZXNzaW9uIHdpdGggYW4gYWRkaXRpb25hbCBmcmFnbWVudC5cclxuICAgICAqIFRoZSBjdXJyZW50IGZpbGUgY29udGVudCBpcyBub3QgY2hhbmdlZC5cclxuICAgICAqIFVzZSB0aGUgdXBsb2FkSWQgdmFsdWUgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBTdGFydFVwbG9hZCBtZXRob2QgdGhhdCBzdGFydGVkIHRoZSB1cGxvYWQgc2Vzc2lvbi5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGN1cnJlbnRseSBhdmFpbGFibGUgb25seSBvbiBPZmZpY2UgMzY1LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cGxvYWRJZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHVwbG9hZCBzZXNzaW9uLlxyXG4gICAgICogQHBhcmFtIGZpbGVPZmZzZXQgVGhlIHNpemUgb2YgdGhlIG9mZnNldCBpbnRvIHRoZSBmaWxlIHdoZXJlIHRoZSBmcmFnbWVudCBzdGFydHMuXHJcbiAgICAgKiBAcGFyYW0gZnJhZ21lbnQgVGhlIGZpbGUgY29udGVudHMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUgdG90YWwgdXBsb2FkZWQgZGF0YSBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgRmlsZS5wcm90b3R5cGUuY29udGludWVVcGxvYWQgPSBmdW5jdGlvbiAodXBsb2FkSWQsIGZpbGVPZmZzZXQsIGZyYWdtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoRmlsZSwgXCJjb250aW51ZVVwbG9hZCh1cGxvYWRJZD1ndWlkJ1wiICsgdXBsb2FkSWQgKyBcIicsZmlsZU9mZnNldD1cIiArIGZpbGVPZmZzZXQgKyBcIilcIiwgZmFsc2UpXHJcbiAgICAgICAgICAgIC5wb3N0Q29yZSh7IGJvZHk6IGZyYWdtZW50IH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gT0RhdGE9dmVyYm9zZSB0aGUgcGF5bG9hZCBoYXMgdGhlIGZvbGxvd2luZyBzaGFwZTpcclxuICAgICAgICAgICAgLy8geyBDb250aW51ZVVwbG9hZDogXCIyMDk3MTUyMFwiIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5Db250aW51ZVVwbG9hZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChuKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZHMgdGhlIGxhc3QgZmlsZSBmcmFnbWVudCBhbmQgY29tbWl0cyB0aGUgZmlsZS4gVGhlIGN1cnJlbnQgZmlsZSBjb250ZW50IGlzIGNoYW5nZWQgd2hlbiB0aGlzIG1ldGhvZCBjb21wbGV0ZXMuXHJcbiAgICAgKiBVc2UgdGhlIHVwbG9hZElkIHZhbHVlIHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgU3RhcnRVcGxvYWQgbWV0aG9kIHRoYXQgc3RhcnRlZCB0aGUgdXBsb2FkIHNlc3Npb24uXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjdXJyZW50bHkgYXZhaWxhYmxlIG9ubHkgb24gT2ZmaWNlIDM2NS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXBsb2FkSWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB1cGxvYWQgc2Vzc2lvbi5cclxuICAgICAqIEBwYXJhbSBmaWxlT2Zmc2V0IFRoZSBzaXplIG9mIHRoZSBvZmZzZXQgaW50byB0aGUgZmlsZSB3aGVyZSB0aGUgZnJhZ21lbnQgc3RhcnRzLlxyXG4gICAgICogQHBhcmFtIGZyYWdtZW50IFRoZSBmaWxlIGNvbnRlbnRzLlxyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IHVwbG9hZGVkIGZpbGUuXHJcbiAgICAgKi9cclxuICAgIEZpbGUucHJvdG90eXBlLmZpbmlzaFVwbG9hZCA9IGZ1bmN0aW9uICh1cGxvYWRJZCwgZmlsZU9mZnNldCwgZnJhZ21lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGaWxlLCBcImZpbmlzaFVwbG9hZCh1cGxvYWRJZD1ndWlkJ1wiICsgdXBsb2FkSWQgKyBcIicsZmlsZU9mZnNldD1cIiArIGZpbGVPZmZzZXQgKyBcIilcIiwgZmFsc2UpXHJcbiAgICAgICAgICAgIC5wb3N0Q29yZSh7IGJvZHk6IGZyYWdtZW50IH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICBmaWxlOiBuZXcgRmlsZShvZGF0YVVybEZyb20ocmVzcG9uc2UpKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmlsZTtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlRmlsZSkpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIGEgY29sbGVjdGlvbiBvZiBWZXJzaW9uIG9iamVjdHNcclxuICpcclxuICovXHJcbnZhciBWZXJzaW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWZXJzaW9ucywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZlcnNpb25zKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFZlcnNpb25zXzEgPSBWZXJzaW9ucztcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHZlcnNpb24gYnkgaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmVyc2lvbklkIFRoZSBpZCBvZiB0aGUgdmVyc2lvbiB0byByZXRyaWV2ZVxyXG4gICAgICovXHJcbiAgICBWZXJzaW9ucy5wcm90b3R5cGUuZ2V0QnlJZCA9IGZ1bmN0aW9uICh2ZXJzaW9uSWQpIHtcclxuICAgICAgICB2YXIgdiA9IG5ldyBWZXJzaW9uKHRoaXMpO1xyXG4gICAgICAgIHYuY29uY2F0KFwiKFwiICsgdmVyc2lvbklkICsgXCIpXCIpO1xyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhbGwgdGhlIGZpbGUgdmVyc2lvbiBvYmplY3RzIGluIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgVmVyc2lvbnMucHJvdG90eXBlLmRlbGV0ZUFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlcnNpb25zXzEodGhpcywgXCJkZWxldGVBbGxcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCB2ZXJzaW9uIG9mIHRoZSBmaWxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2ZXJzaW9uSWQgVGhlIElEIG9mIHRoZSBmaWxlIHZlcnNpb24gdG8gZGVsZXRlLlxyXG4gICAgICovXHJcbiAgICBWZXJzaW9ucy5wcm90b3R5cGUuZGVsZXRlQnlJZCA9IGZ1bmN0aW9uICh2ZXJzaW9uSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShWZXJzaW9uc18xLCBcImRlbGV0ZUJ5SWQodmlkPVwiICsgdmVyc2lvbklkICsgXCIpXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN5Y2xlcyB0aGUgc3BlY2lmaWVkIHZlcnNpb24gb2YgdGhlIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnNpb25JZCBUaGUgSUQgb2YgdGhlIGZpbGUgdmVyc2lvbiB0byBkZWxldGUuXHJcbiAgICAgKi9cclxuICAgIFZlcnNpb25zLnByb3RvdHlwZS5yZWN5Y2xlQnlJRCA9IGZ1bmN0aW9uICh2ZXJzaW9uSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShWZXJzaW9uc18xLCBcInJlY3ljbGVCeUlEKHZpZD1cIiArIHZlcnNpb25JZCArIFwiKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgZmlsZSB2ZXJzaW9uIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgdmVyc2lvbiBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIHZlcnNpb24gbGFiZWwgb2YgdGhlIGZpbGUgdmVyc2lvbiB0byBkZWxldGUsIGZvciBleGFtcGxlOiAxLjJcclxuICAgICAqL1xyXG4gICAgVmVyc2lvbnMucHJvdG90eXBlLmRlbGV0ZUJ5TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShWZXJzaW9uc18xLCBcImRlbGV0ZUJ5TGFiZWwodmVyc2lvbmxhYmVsPSdcIiArIGxhYmVsICsgXCInKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVjeWNsZXMgdGhlIGZpbGUgdmVyc2lvbiBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIHZlcnNpb24gbGFiZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSB2ZXJzaW9uIGxhYmVsIG9mIHRoZSBmaWxlIHZlcnNpb24gdG8gZGVsZXRlLCBmb3IgZXhhbXBsZTogMS4yXHJcbiAgICAgKi9cclxuICAgIFZlcnNpb25zLnByb3RvdHlwZS5yZWN5Y2xlQnlMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFZlcnNpb25zXzEsIFwicmVjeWNsZUJ5TGFiZWwodmVyc2lvbmxhYmVsPSdcIiArIGxhYmVsICsgXCInKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmaWxlIHZlcnNpb24gZnJvbSB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIHZlcnNpb24gbGFiZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSB2ZXJzaW9uIGxhYmVsIG9mIHRoZSBmaWxlIHZlcnNpb24gdG8gcmVzdG9yZSwgZm9yIGV4YW1wbGU6IDEuMlxyXG4gICAgICovXHJcbiAgICBWZXJzaW9ucy5wcm90b3R5cGUucmVzdG9yZUJ5TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShWZXJzaW9uc18xLCBcInJlc3RvcmVCeUxhYmVsKHZlcnNpb25sYWJlbD0nXCIgKyBsYWJlbCArIFwiJylcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICB2YXIgVmVyc2lvbnNfMTtcclxuICAgIFZlcnNpb25zID0gVmVyc2lvbnNfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwidmVyc2lvbnNcIilcclxuICAgIF0sIFZlcnNpb25zKTtcclxuICAgIHJldHVybiBWZXJzaW9ucztcclxufShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbikpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIGEgc2luZ2xlIFZlcnNpb24gaW5zdGFuY2VcclxuICpcclxuICovXHJcbnZhciBWZXJzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZlcnNpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWZXJzaW9uKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogRGVsZXRlIGEgc3BlY2lmaWMgdmVyc2lvbiBvZiBhIGZpbGUuXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogQHBhcmFtIGVUYWcgVmFsdWUgdXNlZCBpbiB0aGUgSUYtTWF0Y2ggaGVhZGVyLCBieSBkZWZhdWx0IFwiKlwiXHJcbiAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5kZWxldGUgPSBfdGhpcy5fZGVsZXRlV2l0aEVUYWc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIC8vIC8qKlxyXG4gICAgICAgIC8vICogRGVsZXRlIGEgc3BlY2lmaWMgdmVyc2lvbiBvZiBhIGZpbGUuXHJcbiAgICAgICAgLy8gKlxyXG4gICAgICAgIC8vICogQHBhcmFtIGVUYWcgVmFsdWUgdXNlZCBpbiB0aGUgSUYtTWF0Y2ggaGVhZGVyLCBieSBkZWZhdWx0IFwiKlwiXHJcbiAgICAgICAgLy8gKi9cclxuICAgICAgICAvLyBwdWJsaWMgZGVsZXRlKGVUYWcgPSBcIipcIik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5wb3N0Q29yZSh7XHJcbiAgICAgICAgLy8gICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgXCJJRi1NYXRjaFwiOiBlVGFnLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIFwiWC1IVFRQLU1ldGhvZFwiOiBcIkRFTEVURVwiLFxyXG4gICAgICAgIC8vICAgICAgICAgfSxcclxuICAgICAgICAvLyAgICAgfSk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFZlcnNpb247XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XHJcbnZhciBDaGVja2luVHlwZTtcclxuKGZ1bmN0aW9uIChDaGVja2luVHlwZSkge1xyXG4gICAgQ2hlY2tpblR5cGVbQ2hlY2tpblR5cGVbXCJNaW5vclwiXSA9IDBdID0gXCJNaW5vclwiO1xyXG4gICAgQ2hlY2tpblR5cGVbQ2hlY2tpblR5cGVbXCJNYWpvclwiXSA9IDFdID0gXCJNYWpvclwiO1xyXG4gICAgQ2hlY2tpblR5cGVbQ2hlY2tpblR5cGVbXCJPdmVyd3JpdGVcIl0gPSAyXSA9IFwiT3ZlcndyaXRlXCI7XHJcbn0pKENoZWNraW5UeXBlIHx8IChDaGVja2luVHlwZSA9IHt9KSk7XHJcbnZhciBXZWJQYXJ0c1BlcnNvbmFsaXphdGlvblNjb3BlO1xyXG4oZnVuY3Rpb24gKFdlYlBhcnRzUGVyc29uYWxpemF0aW9uU2NvcGUpIHtcclxuICAgIFdlYlBhcnRzUGVyc29uYWxpemF0aW9uU2NvcGVbV2ViUGFydHNQZXJzb25hbGl6YXRpb25TY29wZVtcIlVzZXJcIl0gPSAwXSA9IFwiVXNlclwiO1xyXG4gICAgV2ViUGFydHNQZXJzb25hbGl6YXRpb25TY29wZVtXZWJQYXJ0c1BlcnNvbmFsaXphdGlvblNjb3BlW1wiU2hhcmVkXCJdID0gMV0gPSBcIlNoYXJlZFwiO1xyXG59KShXZWJQYXJ0c1BlcnNvbmFsaXphdGlvblNjb3BlIHx8IChXZWJQYXJ0c1BlcnNvbmFsaXphdGlvblNjb3BlID0ge30pKTtcclxudmFyIE1vdmVPcGVyYXRpb25zO1xyXG4oZnVuY3Rpb24gKE1vdmVPcGVyYXRpb25zKSB7XHJcbiAgICBNb3ZlT3BlcmF0aW9uc1tNb3ZlT3BlcmF0aW9uc1tcIk92ZXJ3cml0ZVwiXSA9IDFdID0gXCJPdmVyd3JpdGVcIjtcclxuICAgIE1vdmVPcGVyYXRpb25zW01vdmVPcGVyYXRpb25zW1wiQWxsb3dCcm9rZW5UaGlja2V0c1wiXSA9IDhdID0gXCJBbGxvd0Jyb2tlblRoaWNrZXRzXCI7XHJcbn0pKE1vdmVPcGVyYXRpb25zIHx8IChNb3ZlT3BlcmF0aW9ucyA9IHt9KSk7XHJcbnZhciBUZW1wbGF0ZUZpbGVUeXBlO1xyXG4oZnVuY3Rpb24gKFRlbXBsYXRlRmlsZVR5cGUpIHtcclxuICAgIFRlbXBsYXRlRmlsZVR5cGVbVGVtcGxhdGVGaWxlVHlwZVtcIlN0YW5kYXJkUGFnZVwiXSA9IDBdID0gXCJTdGFuZGFyZFBhZ2VcIjtcclxuICAgIFRlbXBsYXRlRmlsZVR5cGVbVGVtcGxhdGVGaWxlVHlwZVtcIldpa2lQYWdlXCJdID0gMV0gPSBcIldpa2lQYWdlXCI7XHJcbiAgICBUZW1wbGF0ZUZpbGVUeXBlW1RlbXBsYXRlRmlsZVR5cGVbXCJGb3JtUGFnZVwiXSA9IDJdID0gXCJGb3JtUGFnZVwiO1xyXG4gICAgVGVtcGxhdGVGaWxlVHlwZVtUZW1wbGF0ZUZpbGVUeXBlW1wiQ2xpZW50U2lkZVBhZ2VcIl0gPSAzXSA9IFwiQ2xpZW50U2lkZVBhZ2VcIjtcclxufSkoVGVtcGxhdGVGaWxlVHlwZSB8fCAoVGVtcGxhdGVGaWxlVHlwZSA9IHt9KSk7XG5cbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFwcCBjYXRhbG9nXHJcbiAqL1xyXG52YXIgQXBwQ2F0YWxvZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBcHBDYXRhbG9nLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXBwQ2F0YWxvZyhiYXNlVXJsLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJfYXBpL3dlYi90ZW5hbnRhcHBjYXRhbG9nL0F2YWlsYWJsZUFwcHNcIjsgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBleHRyYWN0V2ViVXJsKHR5cGVvZiBiYXNlVXJsID09PSBcInN0cmluZ1wiID8gYmFzZVVybCA6IGJhc2VVcmwudG9VcmwoKSksIHBhdGgpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBkZXRhaWxzIG9mIHNwZWNpZmljIGFwcCBmcm9tIHRoZSBhcHAgY2F0YWxvZ1xyXG4gICAgICogQHBhcmFtIGlkIC0gU3BlY2lmeSB0aGUgZ3VpZCBvZiB0aGUgYXBwXHJcbiAgICAgKi9cclxuICAgIEFwcENhdGFsb2cucHJvdG90eXBlLmdldEFwcEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFwcCh0aGlzLCBcImdldEJ5SWQoJ1wiICsgaWQgKyBcIicpXCIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyBhbiBhcHAgcGFja2FnZS4gTm90IHN1cHBvcnRlZCBmb3IgYmF0Y2hpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgRmlsZW5hbWUgdG8gY3JlYXRlLlxyXG4gICAgICogQHBhcmFtIGNvbnRlbnQgYXBwIHBhY2thZ2UgZGF0YSAoZWc6IHRoZSAuYXBwIG9yIC5zcHBrZyBmaWxlKS5cclxuICAgICAqIEBwYXJhbSBzaG91bGRPdmVyV3JpdGUgU2hvdWxkIGFuIGFwcCB3aXRoIHRoZSBzYW1lIG5hbWUgaW4gdGhlIHNhbWUgbG9jYXRpb24gYmUgb3ZlcndyaXR0ZW4/IChkZWZhdWx0OiB0cnVlKVxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZTxBcHBBZGRSZXN1bHQ+XHJcbiAgICAgKi9cclxuICAgIEFwcENhdGFsb2cucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY29udGVudCwgc2hvdWxkT3ZlcldyaXRlKSB7XHJcbiAgICAgICAgaWYgKHNob3VsZE92ZXJXcml0ZSA9PT0gdm9pZCAwKSB7IHNob3VsZE92ZXJXcml0ZSA9IHRydWU7IH1cclxuICAgICAgICAvLyB5b3UgZG9uJ3QgYWRkIHRvIHRoZSBhdmFpbGFibGVhcHBzIGNvbGxlY3Rpb25cclxuICAgICAgICB2YXIgYWRkZXIgPSBuZXcgQXBwQ2F0YWxvZyhleHRyYWN0V2ViVXJsKHRoaXMudG9VcmwoKSksIFwiX2FwaS93ZWIvdGVuYW50YXBwY2F0YWxvZy9hZGQob3ZlcndyaXRlPVwiICsgc2hvdWxkT3ZlcldyaXRlICsgXCIsdXJsPSdcIiArIGZpbGVuYW1lICsgXCInKVwiKTtcclxuICAgICAgICByZXR1cm4gYWRkZXIucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBjb250ZW50LFxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHIsXHJcbiAgICAgICAgICAgICAgICBmaWxlOiBuZXcgRmlsZShvZGF0YVVybEZyb20ocikpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBcHBDYXRhbG9nO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBhY3Rpb25zIHlvdSBjYW4gcHJlZm9ybSBvbiBhIGdpdmVuIGFwcCB3aXRoaW4gdGhlIGNhdGFsb2dcclxuICovXHJcbnZhciBBcHAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXBwLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXBwKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgZGVwbG95cyBhbiBhcHAgb24gdGhlIGFwcCBjYXRhbG9nLiAgSXQgbXVzdCBiZSBjYWxsZWQgaW4gdGhlIGNvbnRleHRcclxuICAgICAqIG9mIHRoZSB0ZW5hbnQgYXBwIGNhdGFsb2cgd2ViIG9yIGl0IHdpbGwgZmFpbC5cclxuICAgICAqL1xyXG4gICAgQXBwLnByb3RvdHlwZS5kZXBsb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoQXBwLCBcIkRlcGxveVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmV0cmFjdHMgYSBkZXBsb3llZCBhcHAgb24gdGhlIGFwcCBjYXRhbG9nLiAgSXQgbXVzdCBiZSBjYWxsZWQgaW4gdGhlIGNvbnRleHRcclxuICAgICAqIG9mIHRoZSB0ZW5hbnQgYXBwIGNhdGFsb2cgd2ViIG9yIGl0IHdpbGwgZmFpbC5cclxuICAgICAqL1xyXG4gICAgQXBwLnByb3RvdHlwZS5yZXRyYWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKEFwcCwgXCJSZXRyYWN0XCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgYW4gYXBwIHdoaWNoIGlzIGFscmVhZHkgZGVwbG95ZWQgdG8gYmUgaW5zdGFsbGVkIG9uIGEgd2ViXHJcbiAgICAgKi9cclxuICAgIEFwcC5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShBcHAsIFwiSW5zdGFsbFwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGFuIGFwcCB3aGljaCBpcyBhbHJlYWR5IGluc2F0bGxlZCB0byBiZSB1bmluc3RhbGxlZCBvbiBhIHdlYlxyXG4gICAgICovXHJcbiAgICBBcHAucHJvdG90eXBlLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShBcHAsIFwiVW5pbnN0YWxsXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgYW4gYXBwIHdoaWNoIGlzIGFscmVhZHkgaW5zYXRsbGVkIHRvIGJlIHVwZ3JhZGVkIG9uIGEgd2ViXHJcbiAgICAgKi9cclxuICAgIEFwcC5wcm90b3R5cGUudXBncmFkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShBcHAsIFwiVXBncmFkZVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyBhbiBhcHAgZnJvbSB0aGUgYXBwIGNhdGFsb2cuICBJdCBtdXN0IGJlIGNhbGxlZCBpbiB0aGUgY29udGV4dFxyXG4gICAgICogb2YgdGhlIHRlbmFudCBhcHAgY2F0YWxvZyB3ZWIgb3IgaXQgd2lsbCBmYWlsLlxyXG4gICAgICovXHJcbiAgICBBcHAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShBcHAsIFwiUmVtb3ZlXCIpLnBvc3RDb3JlKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFwcDtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UpKTtcblxuLyoqXHJcbiAqIE1hbmFnZXMgYSBiYXRjaCBvZiBPRGF0YSBvcGVyYXRpb25zXHJcbiAqL1xyXG52YXIgU1BCYXRjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTUEJhdGNoLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU1BCYXRjaChiYXNlVXJsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyB0aGUgcmVzcG9uc2UgZnJvbSBhIGJhdGNoIHJlcXVlc3QgaW50byBhbiBhcnJheSBvZiBSZXNwb25zZSBpbnN0YW5jZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYm9keSBUZXh0IGJvZHkgb2YgdGhlIHJlc3BvbnNlIGZyb20gdGhlIGJhdGNoIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgU1BCYXRjaC5QYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VzID0gW107XHJcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBcIi0tYmF0Y2hyZXNwb25zZV9cIjtcclxuICAgICAgICAgICAgLy8gRXguIFwiSFRUUC8xLjEgNTAwIEludGVybmFsIFNlcnZlciBFcnJvclwiXHJcbiAgICAgICAgICAgIHZhciBzdGF0dXNSZWdFeHAgPSBuZXcgUmVnRXhwKFwiXkhUVFAvWzAtOS5dKyArKFswLTldKykgKyguKilcIiwgXCJpXCIpO1xyXG4gICAgICAgICAgICB2YXIgbGluZXMgPSBib2R5LnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBcImJhdGNoXCI7XHJcbiAgICAgICAgICAgIHZhciBzdGF0dXM7XHJcbiAgICAgICAgICAgIHZhciBzdGF0dXNUZXh0O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJiYXRjaFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5zdWJzdHIoMCwgaGVhZGVyLmxlbmd0aCkgPT09IGhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBcImJhdGNoSGVhZGVyc1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudHJpbSgpICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlLCBsaW5lIFwiICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJhdGNoSGVhZGVyc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS50cmltKCkgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gXCJzdGF0dXNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RhdHVzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHN0YXR1c1JlZ0V4cC5leGVjKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgc3RhdHVzLCBsaW5lIFwiICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHBhcnRzWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFwic3RhdHVzSGVhZGVyc1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RhdHVzSGVhZGVyc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS50cmltKCkgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gXCJib2R5XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzLnB1c2goKHN0YXR1cyA9PT0gMjA0KSA/IG5ldyBSZXNwb25zZSgpIDogbmV3IFJlc3BvbnNlKGxpbmUsIHsgc3RhdHVzOiBzdGF0dXMsIHN0YXR1c1RleHQ6IHN0YXR1c1RleHQgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFwiYmF0Y2hcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBcInN0YXR1c1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dFwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFNQQmF0Y2gucHJvdG90eXBlLmV4ZWN1dGVJbXBsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgTG9nZ2VyLndyaXRlKFwiW1wiICsgdGhpcy5iYXRjaElkICsgXCJdIChcIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKyBcIikgRXhlY3V0aW5nIGJhdGNoIHdpdGggXCIgKyB0aGlzLnJlcXVlc3RzLmxlbmd0aCArIFwiIHJlcXVlc3RzLlwiLCAxIC8qIEluZm8gKi8pO1xyXG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IHJlcXVlc3RzLCBkb24ndCBib3RoZXIgc2VuZGluZyBhbnl0aGluZ1xyXG4gICAgICAgIC8vIHRoaXMgY291bGQgYmUgZHVlIHRvIGNhY2hpbmcgZnVydGhlciB1cHN0cmVhbSwgb3IganVzdCBhbiBlbXB0eSBiYXRjaFxyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RzLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLndyaXRlKFwiUmVzb2x2aW5nIGVtcHR5IGJhdGNoLlwiLCAxIC8qIEluZm8gKi8pO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0aW5nIHRoZSBjbGllbnQgaGVyZSBhbGxvd3MgdGhlIHVybCB0byBiZSBwb3B1bGF0ZWQgZm9yIG5vZGVqcyBjbGllbnQgYXMgd2VsbCBhcyBwb3RlbnRpYWxseVxyXG4gICAgICAgIC8vIGFueSBvdGhlciBoYWNrcyBuZWVkZWQgZm9yIG90aGVyIHR5cGVzIG9mIGNsaWVudHMuIEVzc2VudGlhbGx5IGFsbG93cyB0aGUgYWJzb2x1dGVSZXF1ZXN0VXJsXHJcbiAgICAgICAgLy8gYmVsb3cgdG8gYmUgY29ycmVjdFxyXG4gICAgICAgIHZhciBjbGllbnQgPSBuZXcgU1BIdHRwQ2xpZW50KCk7XHJcbiAgICAgICAgLy8gZHVlIHRvIHRpbWluZyB3ZSBuZWVkIHRvIGdldCB0aGUgYWJzb2x1dGUgdXJsIGhlcmUgc28gd2UgY2FuIHVzZSBpdCBmb3IgYWxsIHRoZSBpbmRpdmlkdWFsIHJlcXVlc3RzXHJcbiAgICAgICAgLy8gYW5kIGZvciBzZW5kaW5nIHRoZSBlbnRpcmUgYmF0Y2hcclxuICAgICAgICByZXR1cm4gdG9BYnNvbHV0ZVVybCh0aGlzLmJhc2VVcmwpLnRoZW4oZnVuY3Rpb24gKGFic29sdXRlUmVxdWVzdFVybCkge1xyXG4gICAgICAgICAgICAvLyBidWlsZCBhbGwgdGhlIHJlcXVlc3RzLCBzZW5kIHRoZW0sIHBpcGUgcmVzdWx0cyBpbiBvcmRlciB0byBwYXJzZXJzXHJcbiAgICAgICAgICAgIHZhciBiYXRjaEJvZHkgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFuZ2VTZXRJZCA9IFwiXCI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMucmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXFJbmZvID0gX3RoaXMucmVxdWVzdHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocmVxSW5mby5tZXRob2QgPT09IFwiR0VUXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYW5nZVNldElkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kIGFuIGV4aXN0aW5nIGNoYW5nZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hCb2R5LnB1c2goXCItLWNoYW5nZXNldF9cIiArIGN1cnJlbnRDaGFuZ2VTZXRJZCArIFwiLS1cXG5cXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFuZ2VTZXRJZCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoQm9keS5wdXNoKFwiLS1iYXRjaF9cIiArIF90aGlzLmJhdGNoSWQgKyBcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhbmdlU2V0SWQubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBuZXcgY2hhbmdlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhbmdlU2V0SWQgPSBnZXRHVUlEKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoQm9keS5wdXNoKFwiLS1iYXRjaF9cIiArIF90aGlzLmJhdGNoSWQgKyBcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hCb2R5LnB1c2goXCJDb250ZW50LVR5cGU6IG11bHRpcGFydC9taXhlZDsgYm91bmRhcnk9XFxcImNoYW5nZXNldF9cIiArIGN1cnJlbnRDaGFuZ2VTZXRJZCArIFwiXFxcIlxcblxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hCb2R5LnB1c2goXCItLWNoYW5nZXNldF9cIiArIGN1cnJlbnRDaGFuZ2VTZXRJZCArIFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29tbW9uIGJhdGNoIHBhcnQgcHJlZml4XHJcbiAgICAgICAgICAgICAgICBiYXRjaEJvZHkucHVzaChcIkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vaHR0cFxcblwiKTtcclxuICAgICAgICAgICAgICAgIGJhdGNoQm9keS5wdXNoKFwiQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZzogYmluYXJ5XFxuXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgdXJsIG9mIHRoZSBpbmRpdmlkdWFsIHJlcXVlc3Qgd2l0aGluIHRoZSBiYXRjaFxyXG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IGlzVXJsQWJzb2x1dGUocmVxSW5mby51cmwpID8gcmVxSW5mby51cmwgOiBjb21iaW5lKGFic29sdXRlUmVxdWVzdFVybCwgcmVxSW5mby51cmwpO1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLndyaXRlKFwiW1wiICsgX3RoaXMuYmF0Y2hJZCArIFwiXSAoXCIgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgXCIpIEFkZGluZyByZXF1ZXN0IFwiICsgcmVxSW5mby5tZXRob2QgKyBcIiBcIiArIHVybCArIFwiIHRvIGJhdGNoLlwiLCAwIC8qIFZlcmJvc2UgKi8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcUluZm8ubWV0aG9kICE9PSBcIkdFVFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHJlcUluZm8ubWV0aG9kO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXN0SGVhZGVycyA9IHJlcUluZm8ub3B0aW9ucy5oZWFkZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoT1AocmVxSW5mbywgXCJvcHRpb25zXCIpICYmIGhPUChyZXFJbmZvLm9wdGlvbnMsIFwiaGVhZGVyc1wiKSAmJiBjYXN0SGVhZGVyc1tcIlgtSFRUUC1NZXRob2RcIl0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBjYXN0SGVhZGVyc1tcIlgtSFRUUC1NZXRob2RcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYXN0SGVhZGVyc1tcIlgtSFRUUC1NZXRob2RcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoQm9keS5wdXNoKG1ldGhvZCArIFwiIFwiICsgdXJsICsgXCIgSFRUUC8xLjFcXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uO29kYXRhPXZlcmJvc2U7Y2hhcnNldD11dGYtOFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoQm9keS5wdXNoKHJlcUluZm8ubWV0aG9kICsgXCIgXCIgKyB1cmwgKyBcIiBIVFRQLzEuMVxcblwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGdsb2JhbCBjb25maWcgaGVhZGVyc1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VIZWFkZXJzKGhlYWRlcnMsIFNQUnVudGltZUNvbmZpZy5oZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIHBlci1yZXF1ZXN0IGhlYWRlcnNcclxuICAgICAgICAgICAgICAgIGlmIChyZXFJbmZvLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZUhlYWRlcnMoaGVhZGVycywgcmVxSW5mby5vcHRpb25zLmhlYWRlcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbGFzdGx5IHdlIGFwcGx5IGFueSBkZWZhdWx0IGhlYWRlcnMgd2UgbmVlZCB0aGF0IG1heSBub3QgZXhpc3RcclxuICAgICAgICAgICAgICAgIGlmICghaGVhZGVycy5oYXMoXCJBY2NlcHRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uO29kYXRhPXZlcmJvc2U7Y2hhcnNldD11dGYtOFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaGVhZGVycy5oYXMoXCJYLUNsaWVudFNlcnZpY2UtQ2xpZW50VGFnXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoXCJYLUNsaWVudFNlcnZpY2UtQ2xpZW50VGFnXCIsIFwiUG5QQ29yZUpTOkBwbnAtMS4yLjNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBoZWFkZXJzIGludG8gYmF0Y2ggYm9keVxyXG4gICAgICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoQm9keS5wdXNoKG5hbWUgKyBcIjogXCIgKyB2YWx1ZSArIFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBiYXRjaEJvZHkucHVzaChcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXFJbmZvLm9wdGlvbnMuYm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoQm9keS5wdXNoKHJlcUluZm8ub3B0aW9ucy5ib2R5ICsgXCJcXG5cXG5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFuZ2VTZXRJZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSB0aGUgY2hhbmdlc2V0XHJcbiAgICAgICAgICAgICAgICBiYXRjaEJvZHkucHVzaChcIi0tY2hhbmdlc2V0X1wiICsgY3VycmVudENoYW5nZVNldElkICsgXCItLVxcblxcblwiKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFuZ2VTZXRJZCA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmF0Y2hCb2R5LnB1c2goXCItLWJhdGNoX1wiICsgX3RoaXMuYmF0Y2hJZCArIFwiLS1cXG5cIik7XHJcbiAgICAgICAgICAgIHZhciBiYXRjaE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBcImJvZHlcIjogYmF0Y2hCb2R5LmpvaW4oXCJcIiksXHJcbiAgICAgICAgICAgICAgICBcImhlYWRlcnNcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwibXVsdGlwYXJ0L21peGVkOyBib3VuZGFyeT1iYXRjaF9cIiArIF90aGlzLmJhdGNoSWQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIExvZ2dlci53cml0ZShcIltcIiArIF90aGlzLmJhdGNoSWQgKyBcIl0gKFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFwiKSBTZW5kaW5nIGJhdGNoIHJlcXVlc3QuXCIsIDEgLyogSW5mbyAqLyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjbGllbnQuZmV0Y2goY29tYmluZShhYnNvbHV0ZVJlcXVlc3RVcmwsIFwiL19hcGkvJGJhdGNoXCIpLCBiYXRjaE9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocikgeyByZXR1cm4gci50ZXh0KCk7IH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihTUEJhdGNoLlBhcnNlUmVzcG9uc2UpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VzLmxlbmd0aCAhPT0gX3RoaXMucmVxdWVzdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgcHJvcGVybHkgcGFyc2UgcmVzcG9uc2VzIHRvIG1hdGNoIHJlcXVlc3RzIGluIGJhdGNoLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIExvZ2dlci53cml0ZShcIltcIiArIF90aGlzLmJhdGNoSWQgKyBcIl0gKFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFwiKSBSZXNvbHZpbmcgYmF0Y2hlZCByZXF1ZXN0cy5cIiwgMSAvKiBJbmZvICovKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZXMucmVkdWNlKGZ1bmN0aW9uIChjaGFpbiwgcmVzcG9uc2UsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBfdGhpcy5yZXF1ZXN0c1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLndyaXRlKFwiW1wiICsgcmVxdWVzdC5pZCArIFwiXSAoXCIgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgXCIpIFJlc29sdmluZyByZXF1ZXN0IGluIGJhdGNoIFwiICsgX3RoaXMuYmF0Y2hJZCArIFwiLlwiLCAxIC8qIEluZm8gKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbi50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiByZXF1ZXN0LnBhcnNlci5wYXJzZShyZXNwb25zZSkudGhlbihyZXF1ZXN0LnJlc29sdmUpLmNhdGNoKHJlcXVlc3QucmVqZWN0KTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTUEJhdGNoO1xyXG59KE9EYXRhQmF0Y2gpKTtcblxuLyoqXHJcbiAqIFBhZ2UgcHJvbW90aW9uIHN0YXRlXHJcbiAqL1xyXG52YXIgUHJvbW90ZWRTdGF0ZTtcclxuKGZ1bmN0aW9uIChQcm9tb3RlZFN0YXRlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJlZ3VsYXIgY2xpZW50IHNpZGUgcGFnZVxyXG4gICAgICovXHJcbiAgICBQcm9tb3RlZFN0YXRlW1Byb21vdGVkU3RhdGVbXCJOb3RQcm9tb3RlZFwiXSA9IDBdID0gXCJOb3RQcm9tb3RlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYWdlIHRoYXQgd2lsbCBiZSBwcm9tb3RlZCBhcyBuZXdzIGFydGljbGUgYWZ0ZXIgcHVibGlzaGluZ1xyXG4gICAgICovXHJcbiAgICBQcm9tb3RlZFN0YXRlW1Byb21vdGVkU3RhdGVbXCJQcm9tb3RlT25QdWJsaXNoXCJdID0gMV0gPSBcIlByb21vdGVPblB1Ymxpc2hcIjtcclxuICAgIC8qKlxyXG4gICAgICogUGFnZSB0aGF0IGlzIHByb21vdGVkIGFzIG5ld3MgYXJ0aWNsZVxyXG4gICAgICovXHJcbiAgICBQcm9tb3RlZFN0YXRlW1Byb21vdGVkU3RhdGVbXCJQcm9tb3RlZFwiXSA9IDJdID0gXCJQcm9tb3RlZFwiO1xyXG59KShQcm9tb3RlZFN0YXRlIHx8IChQcm9tb3RlZFN0YXRlID0ge30pKTtcclxuLyoqXHJcbiAqIEdldHMgdGhlIG5leHQgb3JkZXIgdmFsdWUgMSBiYXNlZCBmb3IgdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gQ29sbGVjdGlvbiBvZiBvcmRlcmFibGUgdGhpbmdzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROZXh0T3JkZXIoY29sbGVjdGlvbikge1xyXG4gICAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGNvbGxlY3Rpb24ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLm9yZGVyOyB9KSkgKyAxO1xyXG59XHJcbi8qKlxyXG4gKiBBZnRlciBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzM3ODkvaXMtdGhlcmUtYS12ZXJzaW9uLW9mLWphdmFzY3JpcHRzLXN0cmluZy1pbmRleG9mLXRoYXQtYWxsb3dzLWZvci1yZWd1bGFyLWV4cHIvMjc0MDk0IzI3NDA5NFxyXG4gKlxyXG4gKiBAcGFyYW0gdGhpcyBUeXBlcyB0aGUgY2FsbGVkIGNvbnRleHQgdGhpcyB0byBhIHN0cmluZyBpbiB3aGljaCB0aGUgc2VhcmNoIHdpbGwgYmUgY29uZHVjdGVkXHJcbiAqIEBwYXJhbSByZWdleCBBIHJlZ2V4IG9yIHN0cmluZyB0byBtYXRjaFxyXG4gKiBAcGFyYW0gc3RhcnRwb3MgQSBzdGFydGluZyBwb3NpdGlvbiBmcm9tIHdoaWNoIHRoZSBzZWFyY2ggd2lsbCBiZWdpblxyXG4gKi9cclxuZnVuY3Rpb24gcmVnZXhJbmRleE9mKHJlZ2V4LCBzdGFydHBvcykge1xyXG4gICAgaWYgKHN0YXJ0cG9zID09PSB2b2lkIDApIHsgc3RhcnRwb3MgPSAwOyB9XHJcbiAgICB2YXIgaW5kZXhPZiA9IHRoaXMuc3Vic3RyaW5nKHN0YXJ0cG9zKS5zZWFyY2gocmVnZXgpO1xyXG4gICAgcmV0dXJuIChpbmRleE9mID49IDApID8gKGluZGV4T2YgKyAoc3RhcnRwb3MpKSA6IGluZGV4T2Y7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmRzIGJvdW5kZWQgYmxvY2tzIG9mIG1hcmt1cCBib3VuZGVkIGJ5IGRpdnMsIGVuc3VyaW5nIHRvIG1hdGNoIHRoZSBlbmRpbmcgZGl2IGV2ZW4gd2l0aCBuZXN0ZWQgZGl2cyBpbiB0aGUgaW50ZXJzdGl0aWFsIG1hcmt1cFxyXG4gKlxyXG4gKiBAcGFyYW0gaHRtbCBIVE1MIHRvIHNlYXJjaFxyXG4gKiBAcGFyYW0gYm91bmRhcnlTdGFydFBhdHRlcm4gVGhlIHN0YXJ0aW5nIHBhdHRlcm4gdG8gZmluZCwgdHlwaWNhbGx5IGEgZGl2IHdpdGggYXR0cmlidXRlXHJcbiAqIEBwYXJhbSBjb2xsZWN0b3IgQSBmdW5jIHRvIHRha2UgdGhlIGZvdW5kIGJsb2NrIGFuZCBwcm92aWRlIGEgd2F5IHRvIGZvcm0gaXQgaW50byBhIHVzZWZ1bCByZXR1cm4gdGhhdCBpcyBhZGRlZCBpbnRvIHRoZSByZXR1cm4gYXJyYXlcclxuICovXHJcbmZ1bmN0aW9uIGdldEJvdW5kZWREaXZNYXJrdXAoaHRtbCwgYm91bmRhcnlTdGFydFBhdHRlcm4sIGNvbGxlY3Rvcikge1xyXG4gICAgdmFyIGJsb2NrcyA9IFtdO1xyXG4gICAgaWYgKGh0bWwgPT09IHVuZGVmaW5lZCB8fCBodG1sID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrcztcclxuICAgIH1cclxuICAgIC8vIHJlbW92ZSBzb21lIGV4dHJhIHdoaXRlc3BhY2UgaWYgcHJlc2VudFxyXG4gICAgdmFyIGNsZWFuZWRIdG1sID0gaHRtbC5yZXBsYWNlKC9bXFx0XFxyXFxuXS9nLCBcIlwiKTtcclxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGRpdlxyXG4gICAgdmFyIHN0YXJ0SW5kZXggPSByZWdleEluZGV4T2YuY2FsbChjbGVhbmVkSHRtbCwgYm91bmRhcnlTdGFydFBhdHRlcm4pO1xyXG4gICAgaWYgKHN0YXJ0SW5kZXggPCAwKSB7XHJcbiAgICAgICAgLy8gd2UgZm91bmQgbm8gYmxvY2tzIGluIHRoZSBzdXBwbGllZCBodG1sXHJcbiAgICAgICAgcmV0dXJuIGJsb2NrcztcclxuICAgIH1cclxuICAgIC8vIHRoaXMgbG9vcCBmaW5kcyBlYWNoIG9mIHRoZSBibG9ja3NcclxuICAgIHdoaWxlIChzdGFydEluZGV4ID4gLTEpIHtcclxuICAgICAgICAvLyB3ZSBoYXZlIG9uZSBvcGVuIGRpdiBjb3VudGluZyBmcm9tIHRoZSBvbmUgZm91bmQgYWJvdmUgdXNpbmcgYm91bmRhcnlTdGFydFBhdHRlcm4gc28gd2UgbmVlZCB0byBlbnN1cmUgd2UgZmluZCBpdCdzIGNsb3NlXHJcbiAgICAgICAgdmFyIG9wZW5Db3VudGVyID0gMTtcclxuICAgICAgICB2YXIgc2VhcmNoSW5kZXggPSBzdGFydEluZGV4ICsgMTtcclxuICAgICAgICB2YXIgbmV4dERpdk9wZW4gPSAtMTtcclxuICAgICAgICB2YXIgbmV4dENsb3NlRGl2ID0gLTE7XHJcbiAgICAgICAgLy8gdGhpcyBsb29wIGZpbmRzIHRoZSA8L2Rpdj4gdGFnIHRoYXQgbWF0Y2hlcyB0aGUgb3BlbmluZyBvZiB0aGUgY29udHJvbFxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgYm90aCB0aGUgbmV4dCBvcGVuaW5nIGFuZCBjbG9zaW5nIGRpdiB0YWdzIGZyb20gb3VyIGN1cnJlbnQgc2VhcmNoaW5nIGluZGV4XHJcbiAgICAgICAgICAgIG5leHREaXZPcGVuID0gcmVnZXhJbmRleE9mLmNhbGwoY2xlYW5lZEh0bWwsIC88ZGl2W14+XSo+L2ksIHNlYXJjaEluZGV4KTtcclxuICAgICAgICAgICAgbmV4dENsb3NlRGl2ID0gcmVnZXhJbmRleE9mLmNhbGwoY2xlYW5lZEh0bWwsIC88XFwvZGl2Pi9pLCBzZWFyY2hJbmRleCk7XHJcbiAgICAgICAgICAgIGlmIChuZXh0RGl2T3BlbiA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgbm8gbW9yZSBvcGVuaW5nIGRpdnMsIGp1c3Qgc2V0IHRoaXMgdG8gc2ltcGxpZnkgY2hlY2tzIGJlbG93XHJcbiAgICAgICAgICAgICAgICBuZXh0RGl2T3BlbiA9IGNsZWFuZWRIdG1sLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHdlIGZvdW5kIGZpcnN0LCB0aGVuIGluY3JlbWVudCBvciBkZWNyZW1lbnQgb3VyIGNvdW50ZXJcclxuICAgICAgICAgICAgLy8gYW5kIHNldCB0aGUgbG9jYXRpb24gdG8gYmVnaW4gc2VhcmNoaW5nIGFnYWluXHJcbiAgICAgICAgICAgIGlmIChuZXh0RGl2T3BlbiA8IG5leHRDbG9zZURpdikge1xyXG4gICAgICAgICAgICAgICAgb3BlbkNvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgIHNlYXJjaEluZGV4ID0gbmV4dERpdk9wZW4gKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHRDbG9zZURpdiA8IG5leHREaXZPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICBvcGVuQ291bnRlci0tO1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoSW5kZXggPSBuZXh0Q2xvc2VEaXYgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBubyBvcGVuIGRpdnMgYmFjayB0byB0aGUgbGV2ZWwgb2YgdGhlIG9wZW5pbmcgY29udHJvbCBkaXZcclxuICAgICAgICAgICAgLy8gbWVhbmluZyB3ZSBoYXZlIGFsbCBvZiB0aGUgbWFya3VwIHdlIGludGVuZGVkIHRvIGZpbmRcclxuICAgICAgICAgICAgaWYgKG9wZW5Db3VudGVyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGJvdW5kZWQgbWFya3VwLCArNiBpcyB0aGUgc2l6ZSBvZiB0aGUgZW5kaW5nIDwvZGl2PiB0YWdcclxuICAgICAgICAgICAgICAgIHZhciBtYXJrdXAgPSBjbGVhbmVkSHRtbC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgbmV4dENsb3NlRGl2ICsgNikudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2F2ZSB0aGUgY29udHJvbCBkYXRhIHdlIGZvdW5kIHRvIHRoZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgYmxvY2tzLnB1c2goY29sbGVjdG9yKG1hcmt1cCkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IG91dCBvZiBvdXIgd2hpbGUgbG9vcFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wZW5Db3VudGVyID4gMTAwMCB8fCBvcGVuQ291bnRlciA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gYXJiaXRyYXJ5IGN1dC1vZmYgYnV0IGxpa2VseSB3ZSB3aWxsIG5vdCBoYXZlIDEwMDAgbmVzdGVkIGRpdnNcclxuICAgICAgICAgICAgICAgIC8vIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZyBhYm92ZSBhbmQgd2UgYXJlIHByb2JhYmx5IHN0dWNrIGluIG91ciB3aGlsZSBsb29wXHJcbiAgICAgICAgICAgICAgICAvLyBsZXQncyBnZXQgb3V0IG9mIG91ciB3aGlsZSBsb29wIGFuZCBub3QgaGFuZyBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImdldEJvdW5kZWREaXZNYXJrdXAgZXhjZWVkZWQgZGVwdGggcGFyYW1ldGVycy5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjb250cm9sXHJcbiAgICAgICAgc3RhcnRJbmRleCA9IHJlZ2V4SW5kZXhPZi5jYWxsKGNsZWFuZWRIdG1sLCBib3VuZGFyeVN0YXJ0UGF0dGVybiwgbmV4dENsb3NlRGl2KTtcclxuICAgIH1cclxuICAgIHJldHVybiBibG9ja3M7XHJcbn1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgdGhlIG9yZGVyIHZhbHVlIGZvciBhbGwgdGhlIHNlY3Rpb25zLCBjb2x1bW5zLCBhbmQgY29udHJvbHMgdG8gYmUgMSBiYXNlZCBhbmQgc3RlcHBlZCAoMSwgMiwgMy4uLilcclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gbm9ybWFsaXplXHJcbiAqL1xyXG5mdW5jdGlvbiByZWluZGV4KGNvbGxlY3Rpb24pIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbGxlY3Rpb25baV0ub3JkZXIgPSBpICsgMTtcclxuICAgICAgICBpZiAoaE9QKGNvbGxlY3Rpb25baV0sIFwiY29sdW1uc1wiKSkge1xyXG4gICAgICAgICAgICByZWluZGV4KGNvbGxlY3Rpb25baV0uY29sdW1ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhPUChjb2xsZWN0aW9uW2ldLCBcImNvbnRyb2xzXCIpKSB7XHJcbiAgICAgICAgICAgIHJlaW5kZXgoY29sbGVjdGlvbltpXS5jb250cm9scyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBkYXRhIGFuZCBtZXRob2RzIGFzc29jaWF0ZWQgd2l0aCBjbGllbnQgc2lkZSBcIm1vZGVyblwiIHBhZ2VzXHJcbiAqL1xyXG52YXIgQ2xpZW50U2lkZVBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2xpZW50U2lkZVBhZ2UsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENsaWVudFNpZGVQYWdlIGNsYXNzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJhc2VVcmwgVGhlIHVybCBvciBTaGFyZVBvaW50UXVlcnlhYmxlIHdoaWNoIGZvcm1zIHRoZSBwYXJlbnQgb2YgdGhpcyB3ZWIgY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIGNvbW1lbnRzRGlzYWJsZWQgSW5kaWNhdGVzIGlmIGNvbW1lbnRzIGFyZSBkaXNhYmxlZCwgbm90IHZhbGlkIHVudGlsIGxvYWQgaXMgY2FsbGVkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENsaWVudFNpZGVQYWdlKGZpbGUsIHNlY3Rpb25zLCBjb21tZW50c0Rpc2FibGVkKSB7XHJcbiAgICAgICAgaWYgKHNlY3Rpb25zID09PSB2b2lkIDApIHsgc2VjdGlvbnMgPSBbXTsgfVxyXG4gICAgICAgIGlmIChjb21tZW50c0Rpc2FibGVkID09PSB2b2lkIDApIHsgY29tbWVudHNEaXNhYmxlZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZmlsZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xyXG4gICAgICAgIF90aGlzLmNvbW1lbnRzRGlzYWJsZWQgPSBjb21tZW50c0Rpc2FibGVkO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBibGFuayBwYWdlIHdpdGhpbiB0aGUgc3VwcGxpZWQgbGlicmFyeVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsaWJyYXJ5IFRoZSBsaWJyYXJ5IGluIHdoaWNoIHRvIGNyZWF0ZSB0aGUgcGFnZVxyXG4gICAgICogQHBhcmFtIHBhZ2VOYW1lIEZpbGVuYW1lIG9mIHRoZSBwYWdlLCBzdWNoIGFzIFwicGFnZS5hc3B4XCJcclxuICAgICAqIEBwYXJhbSB0aXRsZSBUaGUgZGlzcGxheSB0aXRsZSBvZiB0aGUgcGFnZVxyXG4gICAgICogQHBhcmFtIHBhZ2VMYXlvdXRUeXBlIExheW91dCB0eXBlIG9mIHRoZSBwYWdlIHRvIHVzZVxyXG4gICAgICovXHJcbiAgICBDbGllbnRTaWRlUGFnZS5jcmVhdGUgPSBmdW5jdGlvbiAobGlicmFyeSwgcGFnZU5hbWUsIHRpdGxlLCBwYWdlTGF5b3V0VHlwZSkge1xyXG4gICAgICAgIGlmIChwYWdlTGF5b3V0VHlwZSA9PT0gdm9pZCAwKSB7IHBhZ2VMYXlvdXRUeXBlID0gXCJBcnRpY2xlXCI7IH1cclxuICAgICAgICAvLyBzZWUgaWYgZmlsZSBleGlzdHMsIGlmIG5vdCBjcmVhdGUgaXRcclxuICAgICAgICByZXR1cm4gbGlicmFyeS5yb290Rm9sZGVyLmZpbGVzLnNlbGVjdChcIk5hbWVcIikuZmlsdGVyKFwiTmFtZSBlcSAnXCIgKyBwYWdlTmFtZSArIFwiJ1wiKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChmcykge1xyXG4gICAgICAgICAgICBpZiAoZnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJBIGZpbGUgd2l0aCB0aGUgbmFtZSAnXCIgKyBwYWdlTmFtZSArIFwiJyBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbGlicmFyeSAnXCIgKyBsaWJyYXJ5LnRvVXJsKCkgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGdldCBvdXIgc2VydmVyIHJlbGF0aXZlIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIGxpYnJhcnkucm9vdEZvbGRlci5zZWxlY3QoXCJTZXJ2ZXJSZWxhdGl2ZVBhdGhcIikuZ2V0KCkudGhlbihmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VTZXJ2ZXJSZWxQYXRoID0gY29tYmluZShcIi9cIiwgcGF0aC5TZXJ2ZXJSZWxhdGl2ZVBhdGguRGVjb2RlZFVybCwgcGFnZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB0ZW1wbGF0ZSBmaWxlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlicmFyeS5yb290Rm9sZGVyLmZpbGVzLmFkZFRlbXBsYXRlRmlsZShwYWdlU2VydmVyUmVsUGF0aCwgVGVtcGxhdGVGaWxlVHlwZS5DbGllbnRTaWRlUGFnZSkudGhlbihmdW5jdGlvbiAoZmFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpdGVtIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYXIuZmlsZS5nZXRJdGVtKCkudGhlbihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGl0ZW0gdG8gaGF2ZSB0aGUgY29ycmVjdCB2YWx1ZXMgdG8gY3JlYXRlIHRoZSBjbGllbnQgc2lkZSBwYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpLnVwZGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCYW5uZXJJbWFnZVVybDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVybDogXCIvX2xheW91dHMvMTUvaW1hZ2VzL3NpdGVwYWdldGh1bWJuYWlsLnBuZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbnZhc0NvbnRlbnQxOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xpZW50U2lkZUFwcGxpY2F0aW9uSWQ6IFwiYjY5MTdjYjEtOTNhMC00Yjk3LWE4NGQtN2NmNDk5NzVkNGVjXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250ZW50VHlwZUlkOiBcIjB4MDEwMTAwOUQxQ0IyNTVEQTc2NDI0Rjg2MEQ5MUYyMEU2QzQxMThcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhZ2VMYXlvdXRUeXBlOiBwYWdlTGF5b3V0VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21vdGVkU3RhdGU6IDAgLyogTm90UHJvbW90ZWQgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaXRsZTogdGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGlhcikgeyByZXR1cm4gbmV3IENsaWVudFNpZGVQYWdlKGlhci5pdGVtLmZpbGUsIGlhci5pdGVtLkNvbW1lbnRzRGlzYWJsZWQpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ2xpZW50U2lkZVBhZ2UgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQgaHRtbCBjb250ZW50IHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBodG1sIEhUTUwgbWFya3VwIHJlcHJlc2VudGluZyB0aGUgcGFnZVxyXG4gICAgICovXHJcbiAgICBDbGllbnRTaWRlUGFnZS5mcm9tRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XHJcbiAgICAgICAgdmFyIHBhZ2UgPSBuZXcgQ2xpZW50U2lkZVBhZ2UoZmlsZSk7XHJcbiAgICAgICAgcmV0dXJuIHBhZ2UubG9hZCgpLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIHBhZ2U7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBqc29uIG9iamVjdCB0byBhbiBlc2NhcGVkIHN0cmluZyBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIGF0dHJpYnV0ZXMgd2hlbiBzdG9yaW5nIGNsaWVudC1zaWRlIGNvbnRyb2xzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGpzb24gb2JqZWN0IHRvIGVuY29kZSBpbnRvIGEgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIENsaWVudFNpZGVQYWdlLmpzb25Ub0VzY2FwZWRTdHJpbmcgPSBmdW5jdGlvbiAoanNvbikge1xyXG4gICAgICAgIHJldHVybiBqc1MoanNvbilcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC86L2csIFwiJiM1ODtcIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoL3svZywgXCImIzEyMztcIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoL30vZywgXCImIzEyNTtcIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcWy9nLCBcIlxcW1wiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxdL2csIFwiXFxdXCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC4vZywgXCJcXC5cIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhbiBlc2NhcGVkIHN0cmluZyBmcm9tIGEgY2xpZW50LXNpZGUgY29udHJvbCBhdHRyaWJ1dGUgdG8gYSBqc29uIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlc2NhcGVkU3RyaW5nXHJcbiAgICAgKi9cclxuICAgIENsaWVudFNpZGVQYWdlLmVzY2FwZWRTdHJpbmdUb0pzb24gPSBmdW5jdGlvbiAoZXNjYXBlZFN0cmluZykge1xyXG4gICAgICAgIHZhciB1bmVzcGFjZSA9IGZ1bmN0aW9uIChlc2NhcGVkKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXBEaWN0ID0gW1xyXG4gICAgICAgICAgICAgICAgWy8mcXVvdDsvZywgXCJcXFwiXCJdLCBbLyYjNTg7L2csIFwiOlwiXSwgWy8mIzEyMzsvZywgXCJ7XCJdLCBbLyYjMTI1Oy9nLCBcIn1cIl0sXHJcbiAgICAgICAgICAgICAgICBbL1xcXFxcXFxcL2csIFwiXFxcXFwiXSwgWy9cXFxcXFw/L2csIFwiP1wiXSwgWy9cXFxcXFwuL2csIFwiLlwiXSwgWy9cXFxcXFxbL2csIFwiW1wiXSwgWy9cXFxcXFxdL2csIFwiXVwiXSxcclxuICAgICAgICAgICAgICAgIFsvXFxcXFxcKC9nLCBcIihcIl0sIFsvXFxcXFxcKS9nLCBcIilcIl0sIFsvXFxcXFxcfC9nLCBcInxcIl0sIFsvXFxcXFxcKy9nLCBcIitcIl0sXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHJldHVybiBtYXBEaWN0LnJlZHVjZShmdW5jdGlvbiAociwgbSkgeyByZXR1cm4gci5yZXBsYWNlKG1bMF0sIG1bMV0pOyB9LCBlc2NhcGVkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHVuZXNwYWNlKGVzY2FwZWRTdHJpbmcpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNlY3Rpb24gdG8gdGhpcyBwYWdlXHJcbiAgICAgKi9cclxuICAgIENsaWVudFNpZGVQYWdlLnByb3RvdHlwZS5hZGRTZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzZWN0aW9uID0gbmV3IENhbnZhc1NlY3Rpb24odGhpcywgZ2V0TmV4dE9yZGVyKHRoaXMuc2VjdGlvbnMpKTtcclxuICAgICAgICB0aGlzLnNlY3Rpb25zLnB1c2goc2VjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHNlY3Rpb247XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIHBhZ2UncyBjb250ZW50IHRvIGh0bWwgbWFya3VwXHJcbiAgICAgKi9cclxuICAgIENsaWVudFNpZGVQYWdlLnByb3RvdHlwZS50b0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdHJpZ2dlciByZWluZGV4IG9mIHRoZSBlbnRpcmUgdHJlZVxyXG4gICAgICAgIHJlaW5kZXgodGhpcy5zZWN0aW9ucyk7XHJcbiAgICAgICAgdmFyIGh0bWwgPSBbXTtcclxuICAgICAgICBodG1sLnB1c2goXCI8ZGl2PlwiKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaHRtbC5wdXNoKHRoaXMuc2VjdGlvbnNbaV0udG9IdG1sKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBodG1sLnB1c2goXCI8L2Rpdj5cIik7XHJcbiAgICAgICAgcmV0dXJuIGh0bWwuam9pbihcIlwiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoaXMgcGFnZSBpbnN0YW5jZSdzIGNvbnRlbnQgZnJvbSB0aGUgc3VwcGxpZWQgaHRtbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBodG1sIGh0bWwgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcGFnZSdzIGNvbnRlbnRcclxuICAgICAqL1xyXG4gICAgQ2xpZW50U2lkZVBhZ2UucHJvdG90eXBlLmZyb21IdG1sID0gZnVuY3Rpb24gKGh0bWwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIHJlc2V0IHNlY3Rpb25zXHJcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIC8vIGdhdGhlciBvdXIgY29udHJvbHMgZnJvbSB0aGUgc3VwcGxpZWQgaHRtbFxyXG4gICAgICAgIGdldEJvdW5kZWREaXZNYXJrdXAoaHRtbCwgLzxkaXZcXGJbXj5dKmRhdGEtc3AtY2FudmFzY29udHJvbFtePl0qPz4vaSwgZnVuY3Rpb24gKG1hcmt1cCkge1xyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGNvbnRyb2wgdHlwZVxyXG4gICAgICAgICAgICB2YXIgY3QgPSAvY29udHJvbFR5cGUmcXVvdDsmIzU4OyhcXGQqPyksL2kuZXhlYyhtYXJrdXApO1xyXG4gICAgICAgICAgICAvLyBpZiBubyBjb250cm9sIHR5cGUgaXMgcHJlc2VudCB0aGlzIGlzIGEgY29sdW1uIHdoaWNoIHdlIGdpdmUgdHlwZSAwIHRvIGxldCB1cyBwcm9jZXNzIGl0XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sVHlwZSA9IGN0ID09IG51bGwgfHwgY3QubGVuZ3RoIDwgMiA/IDAgOiBwYXJzZUludChjdFsxXSwgMTApO1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY29udHJvbFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSBjYW52YXMgY29sdW1uXHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IG5ldyBDYW52YXNDb2x1bW4obnVsbCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5mcm9tSHRtbChtYXJrdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1lcmdlQ29sdW1uVG9UcmVlKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudCBzaWRlIHdlYnBhcnRcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gbmV3IENsaWVudFNpZGVXZWJwYXJ0KFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuZnJvbUh0bWwobWFya3VwKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXJnZVBhcnRUb1RyZWUoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50IHNpZGUgdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBuZXcgQ2xpZW50U2lkZVRleHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmZyb21IdG1sKG1hcmt1cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWVyZ2VQYXJ0VG9UcmVlKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gcmVmcmVzaCBhbGwgdGhlIG9yZGVycyB3aXRoaW4gdGhlIHRyZWVcclxuICAgICAgICByZWluZGV4KHRoaXMuc2VjdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgdGhpcyBwYWdlJ3MgY29udGVudCBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgQ2xpZW50U2lkZVBhZ2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKFwiQ2FudmFzQ29udGVudDFcIiwgXCJDb21tZW50c0Rpc2FibGVkXCIpLnRoZW4oZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgX3RoaXMuZnJvbUh0bWwoaXRlbS5DYW52YXNDb250ZW50MSk7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbW1lbnRzRGlzYWJsZWQgPSBpdGVtLkNvbW1lbnRzRGlzYWJsZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJzaXN0cyB0aGUgY29udGVudCBjaGFuZ2VzIChzZWN0aW9ucywgY29sdW1ucywgYW5kIGNvbnRyb2xzKVxyXG4gICAgICovXHJcbiAgICBDbGllbnRTaWRlUGFnZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHsgQ2FudmFzQ29udGVudDE6IHRoaXMudG9IdG1sKCkgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIGNvbW1lbnRzIG9uIHRoaXMgcGFnZVxyXG4gICAgICovXHJcbiAgICBDbGllbnRTaWRlUGFnZS5wcm90b3R5cGUuZW5hYmxlQ29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRDb21tZW50c09uKHRydWUpLnRoZW4oZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgX3RoaXMuY29tbWVudHNEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGVzIGNvbW1lbnRzIG9uIHRoaXMgcGFnZVxyXG4gICAgICovXHJcbiAgICBDbGllbnRTaWRlUGFnZS5wcm90b3R5cGUuZGlzYWJsZUNvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q29tbWVudHNPbihmYWxzZSkudGhlbihmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICBfdGhpcy5jb21tZW50c0Rpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyBhIGNvbnRyb2wgYnkgdGhlIHNwZWNpZmllZCBpbnN0YW5jZSBpZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCBJbnN0YW5jZSBpZCBvZiB0aGUgY29udHJvbCB0byBmaW5kXHJcbiAgICAgKi9cclxuICAgIENsaWVudFNpZGVQYWdlLnByb3RvdHlwZS5maW5kQ29udHJvbEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kQ29udHJvbChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5pZCA9PT0gaWQ7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgYSBjb250cm9sIHdpdGhpbiB0aGlzIHBhZ2UncyBjb250cm9sIHRyZWUgdXNpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcmVkaWNhdGUgVGFrZXMgYSBjb250cm9sIGFuZCByZXR1cm5zIHRydWUgb3IgZmFsc2UsIGlmIHRydWUgdGhhdCBjb250cm9sIGlzIHJldHVybmVkIGJ5IGZpbmRDb250cm9sXHJcbiAgICAgKi9cclxuICAgIENsaWVudFNpZGVQYWdlLnByb3RvdHlwZS5maW5kQ29udHJvbCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcclxuICAgICAgICAvLyBjaGVjayBhbGwgc2VjdGlvbnNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgYWxsIGNvbHVtbnNcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNlY3Rpb25zW2ldLmNvbHVtbnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGFsbCBjb250cm9sc1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLnNlY3Rpb25zW2ldLmNvbHVtbnNbal0uY29udHJvbHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHByZWRpY2F0ZSBsaWtlcyB0aGlzIGNvbnRyb2xcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKHRoaXMuc2VjdGlvbnNbaV0uY29sdW1uc1tqXS5jb250cm9sc1trXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VjdGlvbnNbaV0uY29sdW1uc1tqXS5jb250cm9sc1trXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2UgZm91bmQgbm90aGluZyBzbyBnaXZlIG5vdGhpbmcgYmFja1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29tbWVudHMgZmxhZyBmb3IgYSBwYWdlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9uIElmIHRydWUgY29tbWVudHMgYXJlIGVuYWJsZWQsIGZhbHNlIHRoZXkgYXJlIGRpc2FibGVkXHJcbiAgICAgKi9cclxuICAgIENsaWVudFNpZGVQYWdlLnByb3RvdHlwZS5zZXRDb21tZW50c09uID0gZnVuY3Rpb24gKG9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbSgpLnRoZW4oZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZXIgPSBuZXcgSXRlbShpLCBcIlNldENvbW1lbnRzRGlzYWJsZWQoXCIgKyAhb24gKyBcIilcIik7XHJcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVyLnVwZGF0ZSh7fSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNZXJnZXMgdGhlIGNvbnRyb2wgaW50byB0aGUgdHJlZSBvZiBzZWN0aW9ucyBhbmQgY29sdW1ucyBmb3IgdGhpcyBwYWdlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyb2wgVGhlIGNvbnRyb2wgdG8gbWVyZ2VcclxuICAgICAqL1xyXG4gICAgQ2xpZW50U2lkZVBhZ2UucHJvdG90eXBlLm1lcmdlUGFydFRvVHJlZSA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHZhciBjb2x1bW4gPSBudWxsO1xyXG4gICAgICAgIHZhciBzZWN0aW9ucyA9IHRoaXMuc2VjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLm9yZGVyID09PSBjb250cm9sLmNvbnRyb2xEYXRhLnBvc2l0aW9uLnpvbmVJbmRleDsgfSk7XHJcbiAgICAgICAgaWYgKHNlY3Rpb25zLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgc2VjdGlvbiA9IG5ldyBDYW52YXNTZWN0aW9uKHRoaXMsIGNvbnRyb2wuY29udHJvbERhdGEucG9zaXRpb24uem9uZUluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5zZWN0aW9ucy5wdXNoKHNlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29sdW1ucyA9IHNlY3Rpb24uY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMub3JkZXIgPT09IGNvbnRyb2wuY29udHJvbERhdGEucG9zaXRpb24uc2VjdGlvbkluZGV4OyB9KTtcclxuICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbiA9IG5ldyBDYW52YXNDb2x1bW4oc2VjdGlvbiwgY29udHJvbC5jb250cm9sRGF0YS5wb3NpdGlvbi5zZWN0aW9uSW5kZXgsIGNvbnRyb2wuY29udHJvbERhdGEucG9zaXRpb24uc2VjdGlvbkZhY3Rvcik7XHJcbiAgICAgICAgICAgIHNlY3Rpb24uY29sdW1ucy5wdXNoKGNvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250cm9sLmNvbHVtbiA9IGNvbHVtbjtcclxuICAgICAgICBjb2x1bW4uYWRkQ29udHJvbChjb250cm9sKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlcyB0aGUgc3VwcGxpZWQgY29sdW1uIGludG8gdGhlIHRyZWVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sdW1uIENvbHVtbiB0byBtZXJnZVxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiBkYXRhIGZvciB0aGUgY29sdW1uXHJcbiAgICAgKi9cclxuICAgIENsaWVudFNpZGVQYWdlLnByb3RvdHlwZS5tZXJnZUNvbHVtblRvVHJlZSA9IGZ1bmN0aW9uIChjb2x1bW4pIHtcclxuICAgICAgICB2YXIgc2VjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdmFyIHNlY3Rpb25zID0gdGhpcy5zZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMub3JkZXIgPT09IGNvbHVtbi5jb250cm9sRGF0YS5wb3NpdGlvbi56b25lSW5kZXg7IH0pO1xyXG4gICAgICAgIGlmIChzZWN0aW9ucy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIHNlY3Rpb24gPSBuZXcgQ2FudmFzU2VjdGlvbih0aGlzLCBjb2x1bW4uY29udHJvbERhdGEucG9zaXRpb24uem9uZUluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5zZWN0aW9ucy5wdXNoKHNlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2x1bW4uc2VjdGlvbiA9IHNlY3Rpb247XHJcbiAgICAgICAgc2VjdGlvbi5jb2x1bW5zLnB1c2goY29sdW1uKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHVuZGVybHlpbmcgTGlzdEl0ZW0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgQ2xpZW50U2lkZVBhZ2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBTZXQgb2YgcHJvcGVydGllcyB0byB1cGRhdGVcclxuICAgICAqIEBwYXJhbSBlVGFnIFZhbHVlIHVzZWQgaW4gdGhlIElGLU1hdGNoIGhlYWRlciwgYnkgZGVmYXVsdCBcIipcIlxyXG4gICAgICovXHJcbiAgICBDbGllbnRTaWRlUGFnZS5wcm90b3R5cGUudXBkYXRlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBlVGFnKSB7XHJcbiAgICAgICAgaWYgKGVUYWcgPT09IHZvaWQgMCkgeyBlVGFnID0gXCIqXCI7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKCkudGhlbihmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS51cGRhdGUocHJvcGVydGllcywgZVRhZyk7IH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDbGllbnRTaWRlUGFnZTtcclxufShGaWxlKSk7XHJcbnZhciBDYW52YXNTZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FudmFzU2VjdGlvbihwYWdlLCBvcmRlciwgY29sdW1ucykge1xyXG4gICAgICAgIGlmIChjb2x1bW5zID09PSB2b2lkIDApIHsgY29sdW1ucyA9IFtdOyB9XHJcbiAgICAgICAgdGhpcy5wYWdlID0gcGFnZTtcclxuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcclxuICAgICAgICB0aGlzLl9tZW1JZCA9IGdldEdVSUQoKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYW52YXNTZWN0aW9uLnByb3RvdHlwZSwgXCJkZWZhdWx0Q29sdW1uXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZhdWx0IGNvbHVtbiAodGhpcy5jb2x1bW5zWzBdKSBmb3IgdGhpcyBzZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbnMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb2x1bW4oMTIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNbMF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgY29sdW1uIHRvIHRoaXMgc2VjdGlvblxyXG4gICAgICovXHJcbiAgICBDYW52YXNTZWN0aW9uLnByb3RvdHlwZS5hZGRDb2x1bW4gPSBmdW5jdGlvbiAoZmFjdG9yKSB7XHJcbiAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBDYW52YXNDb2x1bW4odGhpcywgZ2V0TmV4dE9yZGVyKHRoaXMuY29sdW1ucyksIGZhY3Rvcik7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2goY29sdW1uKTtcclxuICAgICAgICByZXR1cm4gY29sdW1uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGNvbnRyb2wgdG8gdGhlIGRlZmF1bHQgY29sdW1uIGZvciB0aGlzIHNlY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJvbCBDb250cm9sIHRvIGFkZCB0byB0aGUgZGVmYXVsdCBjb2x1bW5cclxuICAgICAqL1xyXG4gICAgQ2FudmFzU2VjdGlvbi5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29sdW1uLmFkZENvbnRyb2woY29udHJvbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgQ2FudmFzU2VjdGlvbi5wcm90b3R5cGUudG9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBodG1sID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaHRtbC5wdXNoKHRoaXMuY29sdW1uc1tpXS50b0h0bWwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1sLmpvaW4oXCJcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoaXMgc2VjdGlvbiBhbmQgYWxsIGNvbnRhaW5lZCBjb2x1bW5zIGFuZCBjb250cm9scyBmcm9tIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIENhbnZhc1NlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucGFnZS5zZWN0aW9ucyA9IHRoaXMucGFnZS5zZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHNlY3Rpb24pIHsgcmV0dXJuIHNlY3Rpb24uX21lbUlkICE9PSBfdGhpcy5fbWVtSWQ7IH0pO1xyXG4gICAgICAgIHJlaW5kZXgodGhpcy5wYWdlLnNlY3Rpb25zKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2FudmFzU2VjdGlvbjtcclxufSgpKTtcclxudmFyIENhbnZhc0NvbnRyb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYW52YXNDb250cm9sKGNvbnRyb2xUeXBlLCBkYXRhVmVyc2lvbiwgY29sdW1uLCBvcmRlciwgaWQsIGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gdm9pZCAwKSB7IGNvbHVtbiA9IG51bGw7IH1cclxuICAgICAgICBpZiAob3JkZXIgPT09IHZvaWQgMCkgeyBvcmRlciA9IDE7IH1cclxuICAgICAgICBpZiAoaWQgPT09IHZvaWQgMCkgeyBpZCA9IGdldEdVSUQoKTsgfVxyXG4gICAgICAgIGlmIChjb250cm9sRGF0YSA9PT0gdm9pZCAwKSB7IGNvbnRyb2xEYXRhID0gbnVsbDsgfVxyXG4gICAgICAgIHRoaXMuY29udHJvbFR5cGUgPSBjb250cm9sVHlwZTtcclxuICAgICAgICB0aGlzLmRhdGFWZXJzaW9uID0gZGF0YVZlcnNpb247XHJcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XHJcbiAgICAgICAgdGhpcy5vcmRlciA9IG9yZGVyO1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLmNvbnRyb2xEYXRhID0gY29udHJvbERhdGE7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FudmFzQ29udHJvbC5wcm90b3R5cGUsIFwianNvbkRhdGFcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZhbHVlIG9mIHRoZSBjb250cm9sJ3MgXCJkYXRhLXNwLWNvbnRyb2xkYXRhXCIgYXR0cmlidXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbGllbnRTaWRlUGFnZS5qc29uVG9Fc2NhcGVkU3RyaW5nKHRoaXMuZ2V0Q29udHJvbERhdGEoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDYW52YXNDb250cm9sLnByb3RvdHlwZS5mcm9tSHRtbCA9IGZ1bmN0aW9uIChodG1sKSB7XHJcbiAgICAgICAgdGhpcy5jb250cm9sRGF0YSA9IENsaWVudFNpZGVQYWdlLmVzY2FwZWRTdHJpbmdUb0pzb24oZ2V0QXR0clZhbHVlRnJvbVN0cmluZyhodG1sLCBcImRhdGEtc3AtY29udHJvbGRhdGFcIikpO1xyXG4gICAgICAgIHRoaXMuZGF0YVZlcnNpb24gPSBnZXRBdHRyVmFsdWVGcm9tU3RyaW5nKGh0bWwsIFwiZGF0YS1zcC1jYW52YXNkYXRhdmVyc2lvblwiKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xUeXBlID0gdGhpcy5jb250cm9sRGF0YS5jb250cm9sVHlwZTtcclxuICAgICAgICB0aGlzLmlkID0gdGhpcy5jb250cm9sRGF0YS5pZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2FudmFzQ29udHJvbDtcclxufSgpKTtcclxudmFyIENhbnZhc0NvbHVtbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDYW52YXNDb2x1bW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDYW52YXNDb2x1bW4oc2VjdGlvbiwgb3JkZXIsIGZhY3RvciwgY29udHJvbHMsIGRhdGFWZXJzaW9uKSB7XHJcbiAgICAgICAgaWYgKGZhY3RvciA9PT0gdm9pZCAwKSB7IGZhY3RvciA9IDEyOyB9XHJcbiAgICAgICAgaWYgKGNvbnRyb2xzID09PSB2b2lkIDApIHsgY29udHJvbHMgPSBbXTsgfVxyXG4gICAgICAgIGlmIChkYXRhVmVyc2lvbiA9PT0gdm9pZCAwKSB7IGRhdGFWZXJzaW9uID0gXCIxLjBcIjsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDAsIGRhdGFWZXJzaW9uKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnNlY3Rpb24gPSBzZWN0aW9uO1xyXG4gICAgICAgIF90aGlzLm9yZGVyID0gb3JkZXI7XHJcbiAgICAgICAgX3RoaXMuZmFjdG9yID0gZmFjdG9yO1xyXG4gICAgICAgIF90aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ2FudmFzQ29sdW1uLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICBjb250cm9sLmNvbHVtbiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jb250cm9scy5wdXNoKGNvbnRyb2wpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIENhbnZhc0NvbHVtbi5wcm90b3R5cGUuZ2V0Q29udHJvbCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzW2luZGV4XTtcclxuICAgIH07XHJcbiAgICBDYW52YXNDb2x1bW4ucHJvdG90eXBlLnRvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaHRtbCA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xzLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgaHRtbC5wdXNoKFwiPGRpdiBkYXRhLXNwLWNhbnZhc2NvbnRyb2w9XFxcIlxcXCIgZGF0YS1zcC1jYW52YXNkYXRhdmVyc2lvbj1cXFwiXCIgKyB0aGlzLmRhdGFWZXJzaW9uICsgXCJcXFwiIGRhdGEtc3AtY29udHJvbGRhdGE9XFxcIlwiICsgdGhpcy5qc29uRGF0YSArIFwiXFxcIj48L2Rpdj5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udHJvbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGh0bWwucHVzaCh0aGlzLmNvbnRyb2xzW2ldLnRvSHRtbChpICsgMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1sLmpvaW4oXCJcIik7XHJcbiAgICB9O1xyXG4gICAgQ2FudmFzQ29sdW1uLnByb3RvdHlwZS5mcm9tSHRtbCA9IGZ1bmN0aW9uIChodG1sKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mcm9tSHRtbC5jYWxsKHRoaXMsIGh0bWwpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbERhdGEgPSBDbGllbnRTaWRlUGFnZS5lc2NhcGVkU3RyaW5nVG9Kc29uKGdldEF0dHJWYWx1ZUZyb21TdHJpbmcoaHRtbCwgXCJkYXRhLXNwLWNvbnRyb2xkYXRhXCIpKTtcclxuICAgICAgICB0aGlzLmZhY3RvciA9IHRoaXMuY29udHJvbERhdGEucG9zaXRpb24uc2VjdGlvbkZhY3RvcjtcclxuICAgICAgICB0aGlzLm9yZGVyID0gdGhpcy5jb250cm9sRGF0YS5wb3NpdGlvbi5zZWN0aW9uSW5kZXg7XHJcbiAgICB9O1xyXG4gICAgQ2FudmFzQ29sdW1uLnByb3RvdHlwZS5nZXRDb250cm9sRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkaXNwbGF5TW9kZTogMixcclxuICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25GYWN0b3I6IHRoaXMuZmFjdG9yLFxyXG4gICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4OiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgem9uZUluZGV4OiB0aGlzLnNlY3Rpb24ub3JkZXIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhpcyBjb2x1bW4gYW5kIGFsbCBjb250YWluZWQgY29udHJvbHMgZnJvbSB0aGUgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBDYW52YXNDb2x1bW4ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc2VjdGlvbi5jb2x1bW5zID0gdGhpcy5zZWN0aW9uLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5pZCAhPT0gX3RoaXMuaWQ7IH0pO1xyXG4gICAgICAgIHJlaW5kZXgodGhpcy5jb2x1bW4uY29udHJvbHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDYW52YXNDb2x1bW47XHJcbn0oQ2FudmFzQ29udHJvbCkpO1xyXG4vKipcclxuICogQWJzdHJhY3QgY2xhc3Mgd2l0aCBzaGFyZWQgZnVuY3Rpb25hbGl0eSBmb3IgcGFydHNcclxuICovXHJcbnZhciBDbGllbnRTaWRlUGFydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDbGllbnRTaWRlUGFydCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENsaWVudFNpZGVQYXJ0KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGlzIGNvbHVtbiBhbmQgYWxsIGNvbnRhaW5lZCBjb250cm9scyBmcm9tIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIENsaWVudFNpZGVQYXJ0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNvbHVtbi5jb250cm9scyA9IHRoaXMuY29sdW1uLmNvbnRyb2xzLmZpbHRlcihmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC5pZCAhPT0gX3RoaXMuaWQ7IH0pO1xyXG4gICAgICAgIHJlaW5kZXgodGhpcy5jb2x1bW4uY29udHJvbHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDbGllbnRTaWRlUGFydDtcclxufShDYW52YXNDb250cm9sKSk7XHJcbnZhciBDbGllbnRTaWRlVGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDbGllbnRTaWRlVGV4dCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENsaWVudFNpZGVUZXh0KHRleHQpIHtcclxuICAgICAgICBpZiAodGV4dCA9PT0gdm9pZCAwKSB7IHRleHQgPSBcIlwiOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgNCwgXCIxLjBcIikgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xpZW50U2lkZVRleHQucHJvdG90eXBlLCBcInRleHRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0IG1hcmt1cCBvZiB0aGlzIGNvbnRyb2xcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGV4dC5zdGFydHNXaXRoKFwiPHA+XCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCI8cD5cIiArIHRleHQgKyBcIjwvcD5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENsaWVudFNpZGVUZXh0LnByb3RvdHlwZS5nZXRDb250cm9sRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb250cm9sVHlwZTogdGhpcy5jb250cm9sVHlwZSxcclxuICAgICAgICAgICAgZWRpdG9yVHlwZTogXCJDS0VkaXRvclwiLFxyXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcclxuICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xJbmRleDogdGhpcy5vcmRlcixcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25GYWN0b3I6IHRoaXMuY29sdW1uLmZhY3RvcixcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25JbmRleDogdGhpcy5jb2x1bW4ub3JkZXIsXHJcbiAgICAgICAgICAgICAgICB6b25lSW5kZXg6IHRoaXMuY29sdW1uLnNlY3Rpb24ub3JkZXIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBDbGllbnRTaWRlVGV4dC5wcm90b3R5cGUudG9IdG1sID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgLy8gc2V0IG91ciBvcmRlciB0byB0aGUgdmFsdWUgcGFzc2VkIGluXHJcbiAgICAgICAgdGhpcy5vcmRlciA9IGluZGV4O1xyXG4gICAgICAgIHZhciBodG1sID0gW107XHJcbiAgICAgICAgaHRtbC5wdXNoKFwiPGRpdiBkYXRhLXNwLWNhbnZhc2NvbnRyb2w9XFxcIlxcXCIgZGF0YS1zcC1jYW52YXNkYXRhdmVyc2lvbj1cXFwiXCIgKyB0aGlzLmRhdGFWZXJzaW9uICsgXCJcXFwiIGRhdGEtc3AtY29udHJvbGRhdGE9XFxcIlwiICsgdGhpcy5qc29uRGF0YSArIFwiXFxcIj5cIik7XHJcbiAgICAgICAgaHRtbC5wdXNoKFwiPGRpdiBkYXRhLXNwLXJ0ZT1cXFwiXFxcIj5cIik7XHJcbiAgICAgICAgaHRtbC5wdXNoKFwiXCIgKyB0aGlzLnRleHQpO1xyXG4gICAgICAgIGh0bWwucHVzaChcIjwvZGl2PlwiKTtcclxuICAgICAgICBodG1sLnB1c2goXCI8L2Rpdj5cIik7XHJcbiAgICAgICAgcmV0dXJuIGh0bWwuam9pbihcIlwiKTtcclxuICAgIH07XHJcbiAgICBDbGllbnRTaWRlVGV4dC5wcm90b3R5cGUuZnJvbUh0bWwgPSBmdW5jdGlvbiAoaHRtbCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mcm9tSHRtbC5jYWxsKHRoaXMsIGh0bWwpO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XHJcbiAgICAgICAgZ2V0Qm91bmRlZERpdk1hcmt1cChodG1sLCAvPGRpdltePl0qZGF0YS1zcC1ydGVbXj5dKj4vaSwgZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gZ3JhYiB0aGUgaW5uZXIgdGV4dCBiZXR3ZWVuIHRoZSBkaXZzXHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IC88ZGl2W14+XSpkYXRhLXNwLXJ0ZVtePl0qPiguKj8pPFxcL2Rpdj4kL2kuZXhlYyhzKTtcclxuICAgICAgICAgICAgX3RoaXMudGV4dCA9IG1hdGNoLmxlbmd0aCA+IDEgPyBtYXRjaFsxXSA6IFwiXCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENsaWVudFNpZGVUZXh0O1xyXG59KENsaWVudFNpZGVQYXJ0KSk7XHJcbnZhciBDbGllbnRTaWRlV2VicGFydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDbGllbnRTaWRlV2VicGFydCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENsaWVudFNpZGVXZWJwYXJ0KHRpdGxlLCBkZXNjcmlwdGlvbiwgcHJvcGVydGllSnNvbiwgd2ViUGFydElkLCBodG1sUHJvcGVydGllcywgc2VydmVyUHJvY2Vzc2VkQ29udGVudCwgY2FudmFzRGF0YVZlcnNpb24pIHtcclxuICAgICAgICBpZiAoZGVzY3JpcHRpb24gPT09IHZvaWQgMCkgeyBkZXNjcmlwdGlvbiA9IFwiXCI7IH1cclxuICAgICAgICBpZiAocHJvcGVydGllSnNvbiA9PT0gdm9pZCAwKSB7IHByb3BlcnRpZUpzb24gPSB7fTsgfVxyXG4gICAgICAgIGlmICh3ZWJQYXJ0SWQgPT09IHZvaWQgMCkgeyB3ZWJQYXJ0SWQgPSBcIlwiOyB9XHJcbiAgICAgICAgaWYgKGh0bWxQcm9wZXJ0aWVzID09PSB2b2lkIDApIHsgaHRtbFByb3BlcnRpZXMgPSBcIlwiOyB9XHJcbiAgICAgICAgaWYgKHNlcnZlclByb2Nlc3NlZENvbnRlbnQgPT09IHZvaWQgMCkgeyBzZXJ2ZXJQcm9jZXNzZWRDb250ZW50ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChjYW52YXNEYXRhVmVyc2lvbiA9PT0gdm9pZCAwKSB7IGNhbnZhc0RhdGFWZXJzaW9uID0gXCIxLjBcIjsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDMsIFwiMS4wXCIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGl0bGUgPSB0aXRsZTtcclxuICAgICAgICBfdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG4gICAgICAgIF90aGlzLnByb3BlcnRpZUpzb24gPSBwcm9wZXJ0aWVKc29uO1xyXG4gICAgICAgIF90aGlzLndlYlBhcnRJZCA9IHdlYlBhcnRJZDtcclxuICAgICAgICBfdGhpcy5odG1sUHJvcGVydGllcyA9IGh0bWxQcm9wZXJ0aWVzO1xyXG4gICAgICAgIF90aGlzLnNlcnZlclByb2Nlc3NlZENvbnRlbnQgPSBzZXJ2ZXJQcm9jZXNzZWRDb250ZW50O1xyXG4gICAgICAgIF90aGlzLmNhbnZhc0RhdGFWZXJzaW9uID0gY2FudmFzRGF0YVZlcnNpb247XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ2xpZW50U2lkZVdlYnBhcnQuZnJvbUNvbXBvbmVudERlZiA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdmFyIHBhcnQgPSBuZXcgQ2xpZW50U2lkZVdlYnBhcnQoXCJcIik7XHJcbiAgICAgICAgcGFydC5pbXBvcnQoZGVmaW5pdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHBhcnQ7XHJcbiAgICB9O1xyXG4gICAgQ2xpZW50U2lkZVdlYnBhcnQucHJvdG90eXBlLmltcG9ydCA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLndlYlBhcnRJZCA9IGNvbXBvbmVudC5JZC5yZXBsYWNlKC9eXFx7fFxcfSQvZywgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB2YXIgbWFuaWZlc3QgPSBKU09OLnBhcnNlKGNvbXBvbmVudC5NYW5pZmVzdCk7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IG1hbmlmZXN0LnByZWNvbmZpZ3VyZWRFbnRyaWVzWzBdLnRpdGxlLmRlZmF1bHQ7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IG1hbmlmZXN0LnByZWNvbmZpZ3VyZWRFbnRyaWVzWzBdLmRlc2NyaXB0aW9uLmRlZmF1bHQ7XHJcbiAgICAgICAgdGhpcy5kYXRhVmVyc2lvbiA9IFwiMS4wXCI7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVKc29uID0gdGhpcy5wYXJzZUpzb25Qcm9wZXJ0aWVzKG1hbmlmZXN0LnByZWNvbmZpZ3VyZWRFbnRyaWVzWzBdLnByb3BlcnRpZXMpO1xyXG4gICAgfTtcclxuICAgIENsaWVudFNpZGVXZWJwYXJ0LnByb3RvdHlwZS5zZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZUpzb24gPSBleHRlbmQodGhpcy5wcm9wZXJ0aWVKc29uLCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBDbGllbnRTaWRlV2VicGFydC5wcm90b3R5cGUuZ2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVKc29uO1xyXG4gICAgfTtcclxuICAgIENsaWVudFNpZGVXZWJwYXJ0LnByb3RvdHlwZS50b0h0bWwgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAvLyBzZXQgb3VyIG9yZGVyIHRvIHRoZSB2YWx1ZSBwYXNzZWQgaW5cclxuICAgICAgICB0aGlzLm9yZGVyID0gaW5kZXg7XHJcbiAgICAgICAgLy8gd2lsbCBmb3JtIHRoZSB2YWx1ZSBvZiB0aGUgZGF0YS1zcC13ZWJwYXJ0ZGF0YSBhdHRyaWJ1dGVcclxuICAgICAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICAgICAgZGF0YVZlcnNpb246IHRoaXMuZGF0YVZlcnNpb24sXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICBpZDogdGhpcy53ZWJQYXJ0SWQsXHJcbiAgICAgICAgICAgIGluc3RhbmNlSWQ6IHRoaXMuaWQsXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHRoaXMucHJvcGVydGllSnNvbixcclxuICAgICAgICAgICAgc2VydmVyUHJvY2Vzc2VkQ29udGVudDogdGhpcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50LFxyXG4gICAgICAgICAgICB0aXRsZTogdGhpcy50aXRsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBodG1sID0gW107XHJcbiAgICAgICAgaHRtbC5wdXNoKFwiPGRpdiBkYXRhLXNwLWNhbnZhc2NvbnRyb2w9XFxcIlxcXCIgZGF0YS1zcC1jYW52YXNkYXRhdmVyc2lvbj1cXFwiXCIgKyB0aGlzLmNhbnZhc0RhdGFWZXJzaW9uICsgXCJcXFwiIGRhdGEtc3AtY29udHJvbGRhdGE9XFxcIlwiICsgdGhpcy5qc29uRGF0YSArIFwiXFxcIj5cIik7XHJcbiAgICAgICAgaHRtbC5wdXNoKFwiPGRpdiBkYXRhLXNwLXdlYnBhcnQ9XFxcIlxcXCIgZGF0YS1zcC13ZWJwYXJ0ZGF0YXZlcnNpb249XFxcIlwiICsgdGhpcy5kYXRhVmVyc2lvbiArIFwiXFxcIiBkYXRhLXNwLXdlYnBhcnRkYXRhPVxcXCJcIiArIENsaWVudFNpZGVQYWdlLmpzb25Ub0VzY2FwZWRTdHJpbmcoZGF0YSkgKyBcIlxcXCI+XCIpO1xyXG4gICAgICAgIGh0bWwucHVzaChcIjxkaXYgZGF0YS1zcC1jb21wb25lbnRpZD5cIik7XHJcbiAgICAgICAgaHRtbC5wdXNoKHRoaXMud2ViUGFydElkKTtcclxuICAgICAgICBodG1sLnB1c2goXCI8L2Rpdj5cIik7XHJcbiAgICAgICAgaHRtbC5wdXNoKFwiPGRpdiBkYXRhLXNwLWh0bWxwcm9wZXJ0aWVzPVxcXCJcXFwiPlwiKTtcclxuICAgICAgICBodG1sLnB1c2godGhpcy5yZW5kZXJIdG1sUHJvcGVydGllcygpKTtcclxuICAgICAgICBodG1sLnB1c2goXCI8L2Rpdj5cIik7XHJcbiAgICAgICAgaHRtbC5wdXNoKFwiPC9kaXY+XCIpO1xyXG4gICAgICAgIGh0bWwucHVzaChcIjwvZGl2PlwiKTtcclxuICAgICAgICByZXR1cm4gaHRtbC5qb2luKFwiXCIpO1xyXG4gICAgfTtcclxuICAgIENsaWVudFNpZGVXZWJwYXJ0LnByb3RvdHlwZS5mcm9tSHRtbCA9IGZ1bmN0aW9uIChodG1sKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mcm9tSHRtbC5jYWxsKHRoaXMsIGh0bWwpO1xyXG4gICAgICAgIHZhciB3ZWJQYXJ0RGF0YSA9IENsaWVudFNpZGVQYWdlLmVzY2FwZWRTdHJpbmdUb0pzb24oZ2V0QXR0clZhbHVlRnJvbVN0cmluZyhodG1sLCBcImRhdGEtc3Atd2VicGFydGRhdGFcIikpO1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSB3ZWJQYXJ0RGF0YS50aXRsZTtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gd2ViUGFydERhdGEuZGVzY3JpcHRpb247XHJcbiAgICAgICAgdGhpcy53ZWJQYXJ0SWQgPSB3ZWJQYXJ0RGF0YS5pZDtcclxuICAgICAgICB0aGlzLmNhbnZhc0RhdGFWZXJzaW9uID0gZ2V0QXR0clZhbHVlRnJvbVN0cmluZyhodG1sLCBcImRhdGEtc3AtY2FudmFzZGF0YXZlcnNpb25cIikucmVwbGFjZSgvXFxcXFxcLi8sIFwiLlwiKTtcclxuICAgICAgICB0aGlzLmRhdGFWZXJzaW9uID0gZ2V0QXR0clZhbHVlRnJvbVN0cmluZyhodG1sLCBcImRhdGEtc3Atd2VicGFydGRhdGF2ZXJzaW9uXCIpLnJlcGxhY2UoL1xcXFxcXC4vLCBcIi5cIik7XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHdlYlBhcnREYXRhLnByb3BlcnRpZXMpO1xyXG4gICAgICAgIGlmICh3ZWJQYXJ0RGF0YS5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50ID0gd2ViUGFydERhdGEuc2VydmVyUHJvY2Vzc2VkQ29udGVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2V0IG91ciBodG1sIHByb3BlcnRpZXNcclxuICAgICAgICB2YXIgaHRtbFByb3BzID0gZ2V0Qm91bmRlZERpdk1hcmt1cChodG1sLCAvPGRpdlxcYltePl0qZGF0YS1zcC1odG1scHJvcGVydGllc1tePl0qPz4vaSwgZnVuY3Rpb24gKG1hcmt1cCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoL148ZGl2XFxiW14+XSpkYXRhLXNwLWh0bWxwcm9wZXJ0aWVzW14+XSo/Pi9pLCBcIlwiKS5yZXBsYWNlKC88XFwvZGl2PiQvaSwgXCJcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5odG1sUHJvcGVydGllcyA9IGh0bWxQcm9wcy5sZW5ndGggPiAwID8gaHRtbFByb3BzWzBdIDogXCJcIjtcclxuICAgIH07XHJcbiAgICBDbGllbnRTaWRlV2VicGFydC5wcm90b3R5cGUuZ2V0Q29udHJvbERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udHJvbFR5cGU6IHRoaXMuY29udHJvbFR5cGUsXHJcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbEluZGV4OiB0aGlzLm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgc2VjdGlvbkZhY3RvcjogdGhpcy5jb2x1bW4uZmFjdG9yLFxyXG4gICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4OiB0aGlzLmNvbHVtbi5vcmRlcixcclxuICAgICAgICAgICAgICAgIHpvbmVJbmRleDogdGhpcy5jb2x1bW4uc2VjdGlvbi5vcmRlcixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd2ViUGFydElkOiB0aGlzLndlYlBhcnRJZCxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIENsaWVudFNpZGVXZWJwYXJ0LnByb3RvdHlwZS5yZW5kZXJIdG1sUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaHRtbCA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnNlcnZlclByb2Nlc3NlZENvbnRlbnQgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnNlcnZlclByb2Nlc3NlZENvbnRlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgaHRtbC5wdXNoKHRoaXMuaHRtbFByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlcnZlclByb2Nlc3NlZENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50LnNlYXJjaGFibGVQbGFpblRleHRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50LnNlYXJjaGFibGVQbGFpblRleHRzKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaChcIjxkaXYgZGF0YS1zcC1wcm9wLW5hbWU9XFxcIlwiICsga2V5c1tpXSArIFwiXFxcIiBkYXRhLXNwLXNlYXJjaGFibGVwbGFpbnRleHQ9XFxcInRydWVcXFwiPlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2godGhpcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50LnNlYXJjaGFibGVQbGFpblRleHRzW2tleXNbaV1dKTtcclxuICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2goXCI8L2Rpdj5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyUHJvY2Vzc2VkQ29udGVudC5pbWFnZVNvdXJjZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnNlcnZlclByb2Nlc3NlZENvbnRlbnQuaW1hZ2VTb3VyY2VzKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaChcIjxpbWcgZGF0YS1zcC1wcm9wLW5hbWU9XFxcIlwiICsga2V5c1tpXSArIFwiXFxcIiBzcmM9XFxcIlwiICsgdGhpcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50LmltYWdlU291cmNlc1trZXlzW2ldXSArIFwiXFxcIiAvPlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50LmxpbmtzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50LmxpbmtzKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaChcIjxhIGRhdGEtc3AtcHJvcC1uYW1lPVxcXCJcIiArIGtleXNbaV0gKyBcIlxcXCIgaHJlZj1cXFwiXCIgKyB0aGlzLnNlcnZlclByb2Nlc3NlZENvbnRlbnQubGlua3Nba2V5c1tpXV0gKyBcIlxcXCI+PC9hPlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaHRtbC5qb2luKFwiXCIpO1xyXG4gICAgfTtcclxuICAgIENsaWVudFNpZGVXZWJwYXJ0LnByb3RvdHlwZS5wYXJzZUpzb25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIHdlYiBwYXJ0IGhhcyB0aGUgc2VydmVyUHJvY2Vzc2VkQ29udGVudCBwcm9wZXJ0eSB0aGVuIGtlZXAgdGhpcyBvbmUgYXMgaXQgbWlnaHQgYmUgbmVlZGVkIGFzIGlucHV0IHRvIHJlbmRlciB0aGUgd2ViIHBhcnQgSFRNTCBsYXRlciBvblxyXG4gICAgICAgIGlmIChwcm9wcy53ZWJQYXJ0RGF0YSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLndlYlBhcnREYXRhLnNlcnZlclByb2Nlc3NlZENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlcnZlclByb2Nlc3NlZENvbnRlbnQgPSBwcm9wcy53ZWJQYXJ0RGF0YS5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9wcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJQcm9jZXNzZWRDb250ZW50ID0gcHJvcHMuc2VydmVyUHJvY2Vzc2VkQ29udGVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyUHJvY2Vzc2VkQ29udGVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy53ZWJQYXJ0RGF0YSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLndlYlBhcnREYXRhLnByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMud2ViUGFydERhdGEucHJvcGVydGllcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvcHMucHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5wcm9wZXJ0aWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2xpZW50U2lkZVdlYnBhcnQ7XHJcbn0oQ2xpZW50U2lkZVBhcnQpKTtcblxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIG5hdmlnYXRpb24gbm9kZXNcclxuICpcclxuICovXHJcbnZhciBOYXZpZ2F0aW9uTm9kZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbk5vZGVzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbk5vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIG5hdmlnYXRpb24gbm9kZSBieSBpZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIG5vZGVcclxuICAgICAqL1xyXG4gICAgTmF2aWdhdGlvbk5vZGVzLnByb3RvdHlwZS5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTmF2aWdhdGlvbk5vZGUodGhpcyk7XHJcbiAgICAgICAgbm9kZS5jb25jYXQoXCIoXCIgKyBpZCArIFwiKVwiKTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgbm9kZSB0byB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aXRsZSBEaXNwbGF5IG5hbWUgb2YgdGhlIG5vZGVcclxuICAgICAqIEBwYXJhbSB1cmwgVGhlIHVybCBvZiB0aGUgbm9kZVxyXG4gICAgICogQHBhcmFtIHZpc2libGUgSWYgdHJ1ZSB0aGUgbm9kZSBpcyB2aXNpYmxlLCBvdGhlcndpc2UgaXQgaXMgaGlkZGVuIChkZWZhdWx0OiB0cnVlKVxyXG4gICAgICovXHJcbiAgICBOYXZpZ2F0aW9uTm9kZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0aXRsZSwgdXJsLCB2aXNpYmxlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodmlzaWJsZSA9PT0gdm9pZCAwKSB7IHZpc2libGUgPSB0cnVlOyB9XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKGV4dGVuZChtZXRhZGF0YShcIlNQLk5hdmlnYXRpb25Ob2RlXCIpLCB7XHJcbiAgICAgICAgICAgIElzVmlzaWJsZTogdmlzaWJsZSxcclxuICAgICAgICAgICAgVGl0bGU6IHRpdGxlLFxyXG4gICAgICAgICAgICBVcmw6IHVybCxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoTmF2aWdhdGlvbk5vZGVzLCBudWxsKS5wb3N0Q29yZSh7IGJvZHk6IHBvc3RCb2R5IH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBub2RlOiBfdGhpcy5nZXRCeUlkKGRhdGEuSWQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgYSBub2RlIHRvIGJlIGFmdGVyIGFub3RoZXIgbm9kZSBpbiB0aGUgbmF2aWdhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBub2RlSWQgSWQgb2YgdGhlIG5vZGUgdG8gbW92ZVxyXG4gICAgICogQHBhcmFtIHByZXZpb3VzTm9kZUlkIElkIG9mIHRoZSBub2RlIGFmdGVyIHdoaWNoIHdlIG1vdmUgdGhlIG5vZGUgc3BlY2lmaWVkIGJ5IG5vZGVJZFxyXG4gICAgICovXHJcbiAgICBOYXZpZ2F0aW9uTm9kZXMucHJvdG90eXBlLm1vdmVBZnRlciA9IGZ1bmN0aW9uIChub2RlSWQsIHByZXZpb3VzTm9kZUlkKSB7XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKHtcclxuICAgICAgICAgICAgbm9kZUlkOiBub2RlSWQsXHJcbiAgICAgICAgICAgIHByZXZpb3VzTm9kZUlkOiBwcmV2aW91c05vZGVJZCxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShOYXZpZ2F0aW9uTm9kZXMsIFwiTW92ZUFmdGVyXCIpLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHkgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5hdmlnYXRpb25Ob2RlcztcclxufShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbikpO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhIG5hdmlnYXRpb24gbm9kZVxyXG4gKlxyXG4gKi9cclxudmFyIE5hdmlnYXRpb25Ob2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5hdmlnYXRpb25Ob2RlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbk5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5hdmlnYXRpb25Ob2RlLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhpcyBub2RlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvbk5vZGVzKHRoaXMsIFwiQ2hpbGRyZW5cIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhpcyBub2RlIGFuZCBhbnkgY2hpbGQgbm9kZXNcclxuICAgICAqL1xyXG4gICAgTmF2aWdhdGlvbk5vZGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kZWxldGVDb3JlLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5hdmlnYXRpb25Ob2RlO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xyXG4vKipcclxuICogRXhwb3NlcyB0aGUgbmF2aWdhdGlvbiBjb21wb25lbnRzXHJcbiAqXHJcbiAqL1xyXG52YXIgTmF2aWdhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOYXZpZ2F0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmF2aWdhdGlvbi5wcm90b3R5cGUsIFwicXVpY2tsYXVuY2hcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHF1aWNrbGF1bmNoIG5hdmlnYXRpb24gbm9kZXMgZm9yIHRoZSBjdXJyZW50IGNvbnRleHRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5hdmlnYXRpb25Ob2Rlcyh0aGlzLCBcInF1aWNrbGF1bmNoXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5hdmlnYXRpb24ucHJvdG90eXBlLCBcInRvcE5hdmlnYXRpb25CYXJcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHRvcCBiYXIgbmF2aWdhdGlvbiBub2RlcyBmb3IgdGhlIGN1cnJlbnQgY29udGV4dFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvbk5vZGVzKHRoaXMsIFwidG9wbmF2aWdhdGlvbmJhclwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE5hdmlnYXRpb24gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcIm5hdmlnYXRpb25cIilcclxuICAgIF0sIE5hdmlnYXRpb24pO1xyXG4gICAgcmV0dXJuIE5hdmlnYXRpb247XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZSkpO1xyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgdG9wIGxldmVsIG5hdmlnYXRpb24gc2VydmljZVxyXG4gKi9cclxudmFyIE5hdmlnYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE5hdmlnYXRpb25TZXJ2aWNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvblNlcnZpY2UocGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJfYXBpL25hdmlnYXRpb25cIiwgcGF0aCkgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIE1lbnVTdGF0ZSBzZXJ2aWNlIG9wZXJhdGlvbiByZXR1cm5zIGEgTWVudS1TdGF0ZSAoZHVtcCkgb2YgYSBTaXRlTWFwUHJvdmlkZXIgb24gYSBzaXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZW51Tm9kZUtleSBNZW51Tm9kZS5LZXkgb2YgdGhlIHN0YXJ0IG5vZGUgd2l0aGluIHRoZSBTaXRlTWFwUHJvdmlkZXIgSWYgbm8ga2V5IGlzIHByb3ZpZGVkIHRoZSBTaXRlTWFwUHJvdmlkZXIuUm9vdE5vZGUgd2lsbCBiZSB0aGUgcm9vdCBvZiB0aGUgbWVudSBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBEZXB0aCBvZiB0aGUgZHVtcC4gSWYgbm8gdmFsdWUgaXMgcHJvdmlkZWQgYSBkdW1wIHdpdGggdGhlIGRlcHRoIG9mIDEwIGlzIHJldHVybmVkXHJcbiAgICAgKiBAcGFyYW0gbWFwUHJvdmlkZXJOYW1lIFRoZSBuYW1lIGlkZW50aWZ5aW5nIHRoZSBTaXRlTWFwUHJvdmlkZXIgdG8gYmUgdXNlZFxyXG4gICAgICogQHBhcmFtIGN1c3RvbVByb3BlcnRpZXMgY29tbWEgc2VwZXJhdGVkIGxpc3Qgb2YgY3VzdG9tIHByb3BlcnRpZXMgdG8gYmUgcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRNZW51U3RhdGUgPSBmdW5jdGlvbiAobWVudU5vZGVLZXksIGRlcHRoLCBtYXBQcm92aWRlck5hbWUsIGN1c3RvbVByb3BlcnRpZXMpIHtcclxuICAgICAgICBpZiAobWVudU5vZGVLZXkgPT09IHZvaWQgMCkgeyBtZW51Tm9kZUtleSA9IG51bGw7IH1cclxuICAgICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkgeyBkZXB0aCA9IDEwOyB9XHJcbiAgICAgICAgaWYgKG1hcFByb3ZpZGVyTmFtZSA9PT0gdm9pZCAwKSB7IG1hcFByb3ZpZGVyTmFtZSA9IG51bGw7IH1cclxuICAgICAgICBpZiAoY3VzdG9tUHJvcGVydGllcyA9PT0gdm9pZCAwKSB7IGN1c3RvbVByb3BlcnRpZXMgPSBudWxsOyB9XHJcbiAgICAgICAgcmV0dXJuIChuZXcgTmF2aWdhdGlvblNlcnZpY2UoXCJNZW51U3RhdGVcIikpLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbVByb3BlcnRpZXM6IGN1c3RvbVByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICBkZXB0aDogZGVwdGgsXHJcbiAgICAgICAgICAgICAgICBtYXBQcm92aWRlck5hbWU6IG1hcFByb3ZpZGVyTmFtZSxcclxuICAgICAgICAgICAgICAgIG1lbnVOb2RlS2V5OiBtZW51Tm9kZUtleSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmllcyB0byBnZXQgYSBTaXRlTWFwTm9kZS5LZXkgZm9yIGEgZ2l2ZW4gVVJMIHdpdGhpbiBhIHNpdGUgY29sbGVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3VycmVudFVybCBBIHVybCByZXByZXNlbnRpbmcgdGhlIFNpdGVNYXBOb2RlXHJcbiAgICAgKiBAcGFyYW0gbWFwUHJvdmlkZXJOYW1lIFRoZSBuYW1lIGlkZW50aWZ5aW5nIHRoZSBTaXRlTWFwUHJvdmlkZXIgdG8gYmUgdXNlZFxyXG4gICAgICovXHJcbiAgICBOYXZpZ2F0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0TWVudU5vZGVLZXkgPSBmdW5jdGlvbiAoY3VycmVudFVybCwgbWFwUHJvdmlkZXJOYW1lKSB7XHJcbiAgICAgICAgaWYgKG1hcFByb3ZpZGVyTmFtZSA9PT0gdm9pZCAwKSB7IG1hcFByb3ZpZGVyTmFtZSA9IG51bGw7IH1cclxuICAgICAgICByZXR1cm4gKG5ldyBOYXZpZ2F0aW9uU2VydmljZShcIk1lbnVOb2RlS2V5XCIpKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyh7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJsOiBjdXJyZW50VXJsLFxyXG4gICAgICAgICAgICAgICAgbWFwUHJvdmlkZXJOYW1lOiBtYXBQcm92aWRlck5hbWUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOYXZpZ2F0aW9uU2VydmljZTtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlKSk7XG5cbi8qKlxyXG4gKiBEZXNjcmliZXMgcmVnaW9uYWwgc2V0dGluZ3MgT0RhZGEgb2JqZWN0XHJcbiAqL1xyXG52YXIgUmVnaW9uYWxTZXR0aW5ncyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSZWdpb25hbFNldHRpbmdzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVnaW9uYWxTZXR0aW5ncygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVnaW9uYWxTZXR0aW5ncy5wcm90b3R5cGUsIFwiaW5zdGFsbGVkTGFuZ3VhZ2VzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjb2xsZWN0aW9uIG9mIGxhbmd1YWdlcyB1c2VkIGluIGEgc2VydmVyIGZhcm0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5zdGFsbGVkTGFuZ3VhZ2VzKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZ2lvbmFsU2V0dGluZ3MucHJvdG90eXBlLCBcImdsb2JhbEluc3RhbGxlZExhbmd1YWdlc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY29sbGVjdGlvbiBvZiBsYW5ndWFnZSBwYWNrcyB0aGF0IGFyZSBpbnN0YWxsZWQgb24gdGhlIHNlcnZlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnN0YWxsZWRMYW5ndWFnZXModGhpcywgXCJnbG9iYWxpbnN0YWxsZWRsYW5ndWFnZXNcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVnaW9uYWxTZXR0aW5ncy5wcm90b3R5cGUsIFwidGltZVpvbmVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGltZSB6b25lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGltZVpvbmUodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVnaW9uYWxTZXR0aW5ncy5wcm90b3R5cGUsIFwidGltZVpvbmVzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRpbWUgem9uZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lWm9uZXModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBSZWdpb25hbFNldHRpbmdzID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJyZWdpb25hbHNldHRpbmdzXCIpXHJcbiAgICBdLCBSZWdpb25hbFNldHRpbmdzKTtcclxuICAgIHJldHVybiBSZWdpb25hbFNldHRpbmdzO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIGluc3RhbGxlZCBsYW5ndWFnZXMgT0RhZGEgcXVlcmlhYmxlIGNvbGxlY3Rpb25cclxuICovXHJcbnZhciBJbnN0YWxsZWRMYW5ndWFnZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW5zdGFsbGVkTGFuZ3VhZ2VzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSW5zdGFsbGVkTGFuZ3VhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEluc3RhbGxlZExhbmd1YWdlcyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwiaW5zdGFsbGVkbGFuZ3VhZ2VzXCIpXHJcbiAgICBdLCBJbnN0YWxsZWRMYW5ndWFnZXMpO1xyXG4gICAgcmV0dXJuIEluc3RhbGxlZExhbmd1YWdlcztcclxufShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbikpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIFRpbWVab25lIE9EYWRhIG9iamVjdFxyXG4gKi9cclxudmFyIFRpbWVab25lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRpbWVab25lLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGltZVpvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgVGltZVpvbmVfMSA9IFRpbWVab25lO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFuIExvY2FsIFRpbWUgYnkgVVRDIFRpbWVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXRjVGltZSBVVEMgVGltZSBhcyBEYXRlIG9yIElTTyBTdHJpbmdcclxuICAgICAqL1xyXG4gICAgVGltZVpvbmUucHJvdG90eXBlLnV0Y1RvTG9jYWxUaW1lID0gZnVuY3Rpb24gKHV0Y1RpbWUpIHtcclxuICAgICAgICB2YXIgZGF0ZUlzb1N0cmluZztcclxuICAgICAgICBpZiAodHlwZW9mIHV0Y1RpbWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgZGF0ZUlzb1N0cmluZyA9IHV0Y1RpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRlSXNvU3RyaW5nID0gdXRjVGltZS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShUaW1lWm9uZV8xLCBcInV0Y3RvbG9jYWx0aW1lKCdcIiArIGRhdGVJc29TdHJpbmcgKyBcIicpXCIpXHJcbiAgICAgICAgICAgIC5wb3N0Q29yZSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIGhPUChyZXMsIFwiVVRDVG9Mb2NhbFRpbWVcIikgPyByZXMuVVRDVG9Mb2NhbFRpbWUgOiByZXM7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbiBVVEMgVGltZSBieSBMb2NhbCBUaW1lXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvY2FsVGltZSBMb2NhbCBUaW1lIGFzIERhdGUgb3IgSVNPIFN0cmluZ1xyXG4gICAgICovXHJcbiAgICBUaW1lWm9uZS5wcm90b3R5cGUubG9jYWxUaW1lVG9VVEMgPSBmdW5jdGlvbiAobG9jYWxUaW1lKSB7XHJcbiAgICAgICAgdmFyIGRhdGVJc29TdHJpbmc7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbFRpbWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgZGF0ZUlzb1N0cmluZyA9IGxvY2FsVGltZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGVJc29TdHJpbmcgPSBkYXRlQWRkKGxvY2FsVGltZSwgXCJtaW51dGVcIiwgbG9jYWxUaW1lLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMSkudG9JU09TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoVGltZVpvbmVfMSwgXCJsb2NhbHRpbWV0b3V0YygnXCIgKyBkYXRlSXNvU3RyaW5nICsgXCInKVwiKVxyXG4gICAgICAgICAgICAucG9zdENvcmUoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBoT1AocmVzLCBcIkxvY2FsVGltZVRvVVRDXCIpID8gcmVzLkxvY2FsVGltZVRvVVRDIDogcmVzOyB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgVGltZVpvbmVfMTtcclxuICAgIFRpbWVab25lID0gVGltZVpvbmVfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwidGltZXpvbmVcIilcclxuICAgIF0sIFRpbWVab25lKTtcclxuICAgIHJldHVybiBUaW1lWm9uZTtcclxufShTaGFyZVBvaW50UXVlcnlhYmxlSW5zdGFuY2UpKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aW1lIHpvbmVzIHF1ZXJpYWJsZSBjb2xsZWN0aW9uXHJcbiAqL1xyXG52YXIgVGltZVpvbmVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRpbWVab25lcywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVab25lcygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBUaW1lWm9uZXNfMSA9IFRpbWVab25lcztcclxuICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvb2ZmaWNlL2pqMjQ3MDA4LmFzcHggLSB0aW1lem9uZXMgaWRzXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW4gVGltZVpvbmUgYnkgaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGludGVnZXIgaWQgb2YgdGhlIHRpbWV6b25lIHRvIHJldHJpZXZlXHJcbiAgICAgKi9cclxuICAgIFRpbWVab25lcy5wcm90b3R5cGUuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIC8vIGRvIHRoZSBwb3N0IGFuZCBtZXJnZSB0aGUgcmVzdWx0IGludG8gYSBUaW1lWm9uZSBpbnN0YW5jZSBzbyB0aGUgZGF0YSBhbmQgbWV0aG9kcyBhcmUgYXZhaWxhYmxlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoVGltZVpvbmVzXzEsIFwiR2V0QnlJZChcIiArIGlkICsgXCIpXCIpLnBvc3RDb3JlKHt9LCBzcE9EYXRhRW50aXR5KFRpbWVab25lKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIFRpbWVab25lc18xO1xyXG4gICAgVGltZVpvbmVzID0gVGltZVpvbmVzXzEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBkZWZhdWx0UGF0aChcInRpbWV6b25lc1wiKVxyXG4gICAgXSwgVGltZVpvbmVzKTtcclxuICAgIHJldHVybiBUaW1lWm9uZXM7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24pKTtcblxudmFyIGZ1bmNzID0gbmV3IE1hcChbXHJcbiAgICBbXCJ0ZXh0XCIsIFwiUXVlcnl0ZXh0XCJdLFxyXG4gICAgW1widGVtcGxhdGVcIiwgXCJRdWVyeVRlbXBsYXRlXCJdLFxyXG4gICAgW1wic291cmNlSWRcIiwgXCJTb3VyY2VJZFwiXSxcclxuICAgIFtcInRyaW1EdXBsaWNhdGVzSW5jbHVkZUlkXCIsIFwiXCJdLFxyXG4gICAgW1wic3RhcnRSb3dcIiwgXCJcIl0sXHJcbiAgICBbXCJyb3dMaW1pdFwiLCBcIlwiXSxcclxuICAgIFtcInJhbmtpbmdNb2RlbElkXCIsIFwiXCJdLFxyXG4gICAgW1wicm93c1BlclBhZ2VcIiwgXCJcIl0sXHJcbiAgICBbXCJzZWxlY3RQcm9wZXJ0aWVzXCIsIFwiXCJdLFxyXG4gICAgW1wiY3VsdHVyZVwiLCBcIlwiXSxcclxuICAgIFtcInRpbWVab25lSWRcIiwgXCJcIl0sXHJcbiAgICBbXCJyZWZpbmVtZW50RmlsdGVyc1wiLCBcIlwiXSxcclxuICAgIFtcInJlZmluZXJzXCIsIFwiXCJdLFxyXG4gICAgW1wiaGlkZGVuQ29uc3RyYWludHNcIiwgXCJcIl0sXHJcbiAgICBbXCJzb3J0TGlzdFwiLCBcIlwiXSxcclxuICAgIFtcInRpbWVvdXRcIiwgXCJcIl0sXHJcbiAgICBbXCJoaXRoaWdobGlnaHRlZFByb3BlcnRpZXNcIiwgXCJcIl0sXHJcbiAgICBbXCJjbGllbnRUeXBlXCIsIFwiXCJdLFxyXG4gICAgW1wicGVyc29uYWxpemF0aW9uRGF0YVwiLCBcIlwiXSxcclxuICAgIFtcInJlc3VsdHNVUkxcIiwgXCJcIl0sXHJcbiAgICBbXCJxdWVyeVRhZ1wiLCBcIlwiXSxcclxuICAgIFtcInByb3BlcnRpZXNcIiwgXCJcIl0sXHJcbiAgICBbXCJxdWVyeVRlbXBsYXRlUHJvcGVydGllc1VybFwiLCBcIlwiXSxcclxuICAgIFtcInJlb3JkZXJpbmdSdWxlc1wiLCBcIlwiXSxcclxuICAgIFtcImhpdEhpZ2hsaWdodGVkTXVsdGl2YWx1ZVByb3BlcnR5TGltaXRcIiwgXCJcIl0sXHJcbiAgICBbXCJjb2xsYXBzZVNwZWNpZmljYXRpb25cIiwgXCJcIl0sXHJcbiAgICBbXCJ1aUxhbmd1YWdlXCIsIFwiXCJdLFxyXG4gICAgW1wiZGVzaXJlZFNuaXBwZXRMZW5ndGhcIiwgXCJcIl0sXHJcbiAgICBbXCJtYXhTbmlwcGV0TGVuZ3RoXCIsIFwiXCJdLFxyXG4gICAgW1wic3VtbWFyeUxlbmd0aFwiLCBcIlwiXSxcclxuXSk7XHJcbnZhciBwcm9wcyA9IG5ldyBNYXAoW10pO1xyXG5mdW5jdGlvbiB0b1Byb3BDYXNlKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eKC4pLywgZnVuY3Rpb24gKCQxKSB7IHJldHVybiAkMS50b1VwcGVyQ2FzZSgpOyB9KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgU2VhcmNoUXVlcnlCdWlsZGVyXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeVRleHQgSW5pdGlhbCBxdWVyeSB0ZXh0XHJcbiAqIEBwYXJhbSBfcXVlcnkgQW55IGluaXRpYWwgcXVlcnkgY29uZmlndXJhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gU2VhcmNoUXVlcnlCdWlsZGVyKHF1ZXJ5VGV4dCwgX3F1ZXJ5KSB7XHJcbiAgICBpZiAocXVlcnlUZXh0ID09PSB2b2lkIDApIHsgcXVlcnlUZXh0ID0gXCJcIjsgfVxyXG4gICAgaWYgKF9xdWVyeSA9PT0gdm9pZCAwKSB7IF9xdWVyeSA9IHt9OyB9XHJcbiAgICByZXR1cm4gbmV3IFByb3h5KHtcclxuICAgICAgICBxdWVyeTogT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgICAgIFF1ZXJ5dGV4dDogcXVlcnlUZXh0LFxyXG4gICAgICAgIH0sIF9xdWVyeSksXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoc2VsZiwgcHJvcGVydHlLZXksIHByb3h5KSB7XHJcbiAgICAgICAgICAgIHZhciBwayA9IHByb3BlcnR5S2V5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChwayA9PT0gXCJ0b1NlYXJjaFF1ZXJ5XCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLnF1ZXJ5OyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmdW5jcy5oYXMocGspKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXBwZWRQayA9IGZ1bmNzLmdldChwayk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5xdWVyeVttYXBwZWRQay5sZW5ndGggPiAwID8gbWFwcGVkUGsgOiB0b1Byb3BDYXNlKHBrKV0gPSB2YWx1ZS5sZW5ndGggPiAxID8gdmFsdWUgOiB2YWx1ZVswXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwcm9wS2V5ID0gcHJvcHMuaGFzKHBrKSA/IHByb3BzLmdldChwaykgOiB0b1Byb3BDYXNlKHBrKTtcclxuICAgICAgICAgICAgc2VsZi5xdWVyeVtwcm9wS2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm94eTtcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aGUgc2VhcmNoIEFQSVxyXG4gKlxyXG4gKi9cclxudmFyIFNlYXJjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTZWFyY2gsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTZWFyY2goKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIFNlYXJjaC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChxdWVyeUluaXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMucGFyc2VRdWVyeShxdWVyeUluaXQpO1xyXG4gICAgICAgIHZhciBwb3N0Qm9keSA9IGpzUyh7XHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGV4dGVuZChtZXRhZGF0YShcIk1pY3Jvc29mdC5PZmZpY2UuU2VydmVyLlNlYXJjaC5SRVNULlNlYXJjaFJlcXVlc3RcIiksIE9iamVjdC5hc3NpZ24oe30sIHF1ZXJ5LCB7XHJcbiAgICAgICAgICAgICAgICBIaXRIaWdobGlnaHRlZFByb3BlcnRpZXM6IHRoaXMuZml4QXJyUHJvcChxdWVyeS5IaXRIaWdobGlnaHRlZFByb3BlcnRpZXMpLFxyXG4gICAgICAgICAgICAgICAgUHJvcGVydGllczogdGhpcy5maXhBcnJQcm9wKHF1ZXJ5LlByb3BlcnRpZXMpLFxyXG4gICAgICAgICAgICAgICAgUmVmaW5lbWVudEZpbHRlcnM6IHRoaXMuZml4QXJyUHJvcChxdWVyeS5SZWZpbmVtZW50RmlsdGVycyksXHJcbiAgICAgICAgICAgICAgICBSZW9yZGVyaW5nUnVsZXM6IHRoaXMuZml4QXJyUHJvcChxdWVyeS5SZW9yZGVyaW5nUnVsZXMpLFxyXG4gICAgICAgICAgICAgICAgU2VsZWN0UHJvcGVydGllczogdGhpcy5maXhBcnJQcm9wKHF1ZXJ5LlNlbGVjdFByb3BlcnRpZXMpLFxyXG4gICAgICAgICAgICAgICAgU29ydExpc3Q6IHRoaXMuZml4QXJyUHJvcChxdWVyeS5Tb3J0TGlzdCksXHJcbiAgICAgICAgICAgIH0pKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBpZiB3ZSBhcmUgdXNpbmcgY2FjaGluZyB3aXRoIHRoaXMgc2VhcmNoIHJlcXVlc3QsIHRoZW4gd2UgbmVlZCB0byBoYW5kbGUgc29tZSB3b3JrIHVwZnJvbnQgdG8gZW5hYmxlIHRoYXRcclxuICAgICAgICBpZiAodGhpcy5fdXNlQ2FjaGluZykge1xyXG4gICAgICAgICAgICAvLyBmb3JjZSB1c2Ugb2YgdGhlIGNhY2hlIGZvciB0aGlzIHJlcXVlc3QgaWYgLnVzaW5nQ2FjaGluZyB3YXMgY2FsbGVkXHJcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlQ2FjaGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgYWxsIHRoZSByZXF1ZXN0cyB1c2UgdGhlIHNhbWUgdXJsIHRoZXkgd291bGQgY29sbGlkZSBpbiB0aGUgY2FjaGUgd2UgdXNlIGEgc3BlY2lhbCBrZXlcclxuICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gXCJQblBqcy5TZWFyY2hXaXRoQ2FjaGluZyhcIiArIGdldEhhc2hDb2RlKHBvc3RCb2R5KSArIFwiKVwiO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0RGVmaW5lZE5vdE51bGwodGhpcy5fY2FjaGluZ09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBvdXIga2V5IGVuZHMgaW4gdGhlIHBvc3RxdWVyeSB1cmwgd2Ugb3ZlcndyaXRlIGl0XHJcbiAgICAgICAgICAgICAgICBpZiAoL1xcL19hcGlcXC9zZWFyY2hcXC9wb3N0cXVlcnkkL2kudGVzdCh0aGlzLl9jYWNoaW5nT3B0aW9ucy5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGluZ09wdGlvbnMua2V5ID0gY2FjaGVLZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoaW5nT3B0aW9ucyA9IG5ldyBDYWNoaW5nT3B0aW9ucyhjYWNoZUtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdENvcmUoeyBib2R5OiBwb3N0Qm9keSB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBuZXcgU2VhcmNoUmVzdWx0cyhkYXRhLCBfdGhpcy50b1VybCgpLCBxdWVyeSk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRml4IGFycmF5IHByb3BlcnR5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3AgcHJvcGVydHkgdG8gZml4IGZvciBjb250YWluZXIgc3RydWN0XHJcbiAgICAgKi9cclxuICAgIFNlYXJjaC5wcm90b3R5cGUuZml4QXJyUHJvcCA9IGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoeyByZXN1bHRzOiBbXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcCA9IGlzQXJyYXkocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xyXG4gICAgICAgIHJldHVybiBoT1AocHJvcCwgXCJyZXN1bHRzXCIpID8gcHJvcCA6IHsgcmVzdWx0czogcHJvcCB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlcyBvbmUgb2YgdGhlIHF1ZXJ5IGluaXRpYWxpemVycyBpbnRvIGEgU2VhcmNoUXVlcnkgaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcXVlcnlcclxuICAgICAqL1xyXG4gICAgU2VhcmNoLnByb3RvdHlwZS5wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGZpbmFsUXVlcnk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBmaW5hbFF1ZXJ5ID0geyBRdWVyeXRleHQ6IHF1ZXJ5IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHF1ZXJ5LnRvU2VhcmNoUXVlcnkpIHtcclxuICAgICAgICAgICAgZmluYWxRdWVyeSA9IHF1ZXJ5LnRvU2VhcmNoUXVlcnkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpbmFsUXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbmFsUXVlcnk7XHJcbiAgICB9O1xyXG4gICAgU2VhcmNoID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJfYXBpL3NlYXJjaC9wb3N0cXVlcnlcIilcclxuICAgIF0sIFNlYXJjaCk7XHJcbiAgICByZXR1cm4gU2VhcmNoO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIHRoZSBTZWFyY2hSZXN1bHRzIGNsYXNzLCB3aGljaCByZXR1cm5zIHRoZSBmb3JtYXR0ZWQgYW5kIHJhdyB2ZXJzaW9uIG9mIHRoZSBxdWVyeSByZXNwb25zZVxyXG4gKi9cclxudmFyIFNlYXJjaFJlc3VsdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFNlYXJjaFJlc3VsdCBjbGFzc1xyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU2VhcmNoUmVzdWx0cyhyYXdSZXNwb25zZSwgX3VybCwgX3F1ZXJ5LCBfcmF3LCBfcHJpbWFyeSkge1xyXG4gICAgICAgIGlmIChfcmF3ID09PSB2b2lkIDApIHsgX3JhdyA9IG51bGw7IH1cclxuICAgICAgICBpZiAoX3ByaW1hcnkgPT09IHZvaWQgMCkgeyBfcHJpbWFyeSA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLl91cmwgPSBfdXJsO1xyXG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gX3F1ZXJ5O1xyXG4gICAgICAgIHRoaXMuX3JhdyA9IF9yYXc7XHJcbiAgICAgICAgdGhpcy5fcHJpbWFyeSA9IF9wcmltYXJ5O1xyXG4gICAgICAgIHRoaXMuX3JhdyA9IHJhd1Jlc3BvbnNlLnBvc3RxdWVyeSA/IHJhd1Jlc3BvbnNlLnBvc3RxdWVyeSA6IHJhd1Jlc3BvbnNlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlYXJjaFJlc3VsdHMucHJvdG90eXBlLCBcIkVsYXBzZWRUaW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuUmF3U2VhcmNoUmVzdWx0cy5FbGFwc2VkVGltZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWFyY2hSZXN1bHRzLnByb3RvdHlwZSwgXCJSb3dDb3VudFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlJhd1NlYXJjaFJlc3VsdHMuUHJpbWFyeVF1ZXJ5UmVzdWx0LlJlbGV2YW50UmVzdWx0cy5Sb3dDb3VudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWFyY2hSZXN1bHRzLnByb3RvdHlwZSwgXCJUb3RhbFJvd3NcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5SYXdTZWFyY2hSZXN1bHRzLlByaW1hcnlRdWVyeVJlc3VsdC5SZWxldmFudFJlc3VsdHMuVG90YWxSb3dzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlYXJjaFJlc3VsdHMucHJvdG90eXBlLCBcIlRvdGFsUm93c0luY2x1ZGluZ0R1cGxpY2F0ZXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5SYXdTZWFyY2hSZXN1bHRzLlByaW1hcnlRdWVyeVJlc3VsdC5SZWxldmFudFJlc3VsdHMuVG90YWxSb3dzSW5jbHVkaW5nRHVwbGljYXRlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWFyY2hSZXN1bHRzLnByb3RvdHlwZSwgXCJSYXdTZWFyY2hSZXN1bHRzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhdztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWFyY2hSZXN1bHRzLnByb3RvdHlwZSwgXCJQcmltYXJ5U2VhcmNoUmVzdWx0c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmltYXJ5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmltYXJ5ID0gdGhpcy5mb3JtYXRTZWFyY2hSZXN1bHRzKHRoaXMuX3Jhdy5QcmltYXJ5UXVlcnlSZXN1bHQuUmVsZXZhbnRSZXN1bHRzLlRhYmxlLlJvd3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmltYXJ5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgcGFnZSBvZiByZXN1bHRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhZ2VOdW1iZXIgSW5kZXggb2YgdGhlIHBhZ2UgdG8gcmV0dXJuLiBVc2VkIHRvIGRldGVybWluZSBTdGFydFJvd1xyXG4gICAgICogQHBhcmFtIHBhZ2VTaXplIE9wdGlvbmFsLCBpdGVtcyBwZXIgcGFnZSAoZGVmYXVsdCA9IDEwKVxyXG4gICAgICovXHJcbiAgICBTZWFyY2hSZXN1bHRzLnByb3RvdHlwZS5nZXRQYWdlID0gZnVuY3Rpb24gKHBhZ2VOdW1iZXIsIHBhZ2VTaXplKSB7XHJcbiAgICAgICAgLy8gaWYgd2UgZ290IGFsbCB0aGUgYXZhaWxhYmxlIHJvd3Mgd2UgZG9uJ3QgaGF2ZSBhbm90aGVyIHBhZ2VcclxuICAgICAgICBpZiAodGhpcy5Ub3RhbFJvd3MgPCB0aGlzLlJvd0NvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHBhZ2VTaXplIGlzIHN1cHBsaWVkLCB0aGVuIHdlIHVzZSB0aGF0IHJlZ2FyZGxlc3Mgb2YgYW55IHByZXZpb3VzIHZhbHVlc1xyXG4gICAgICAgIC8vIG90aGVyd2lzZSBnZXQgdGhlIHByZXZpb3VzIFJvd0xpbWl0IG9yIGRlZmF1bHQgdG8gMTBcclxuICAgICAgICB2YXIgcm93cyA9IHBhZ2VTaXplICE9PSB1bmRlZmluZWQgPyBwYWdlU2l6ZSA6IGhPUCh0aGlzLl9xdWVyeSwgXCJSb3dMaW1pdFwiKSA/IHRoaXMuX3F1ZXJ5LlJvd0xpbWl0IDogMTA7XHJcbiAgICAgICAgdmFyIHF1ZXJ5ID0gZXh0ZW5kKHRoaXMuX3F1ZXJ5LCB7XHJcbiAgICAgICAgICAgIFJvd0xpbWl0OiByb3dzLFxyXG4gICAgICAgICAgICBTdGFydFJvdzogcm93cyAqIChwYWdlTnVtYmVyIC0gMSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gd2UgaGF2ZSByZWFjaGVkIHRoZSBlbmRcclxuICAgICAgICBpZiAocXVlcnkuU3RhcnRSb3cgPiB0aGlzLlRvdGFsUm93cykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VhcmNoID0gbmV3IFNlYXJjaCh0aGlzLl91cmwsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBzZWFyY2guZXhlY3V0ZShxdWVyeSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXRzIGEgc2VhcmNoIHJlc3VsdHMgYXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmF3UmVzdWx0cyBUaGUgYXJyYXkgdG8gcHJvY2Vzc1xyXG4gICAgICovXHJcbiAgICBTZWFyY2hSZXN1bHRzLnByb3RvdHlwZS5mb3JtYXRTZWFyY2hSZXN1bHRzID0gZnVuY3Rpb24gKHJhd1Jlc3VsdHMpIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHZhciB0ZW1wUmVzdWx0cyA9IHJhd1Jlc3VsdHMucmVzdWx0cyA/IHJhd1Jlc3VsdHMucmVzdWx0cyA6IHJhd1Jlc3VsdHM7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0ZW1wUmVzdWx0c18xID0gdGVtcFJlc3VsdHM7IF9pIDwgdGVtcFJlc3VsdHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHRlbXBSZXN1bHQgPSB0ZW1wUmVzdWx0c18xW19pXTtcclxuICAgICAgICAgICAgdmFyIGNlbGxzID0gdGVtcFJlc3VsdC5DZWxscy5yZXN1bHRzID8gdGVtcFJlc3VsdC5DZWxscy5yZXN1bHRzIDogdGVtcFJlc3VsdC5DZWxscztcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNlbGxzLnJlZHVjZShmdW5jdGlvbiAocmVzLCBjZWxsKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzLCBjZWxsLktleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2VsbC5WYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZWFyY2hSZXN1bHRzO1xyXG59KCkpO1xyXG4vKipcclxuICogZGVmaW5lcyB0aGUgU29ydERpcmVjdGlvbiBlbnVtXHJcbiAqL1xyXG52YXIgU29ydERpcmVjdGlvbjtcclxuKGZ1bmN0aW9uIChTb3J0RGlyZWN0aW9uKSB7XHJcbiAgICBTb3J0RGlyZWN0aW9uW1NvcnREaXJlY3Rpb25bXCJBc2NlbmRpbmdcIl0gPSAwXSA9IFwiQXNjZW5kaW5nXCI7XHJcbiAgICBTb3J0RGlyZWN0aW9uW1NvcnREaXJlY3Rpb25bXCJEZXNjZW5kaW5nXCJdID0gMV0gPSBcIkRlc2NlbmRpbmdcIjtcclxuICAgIFNvcnREaXJlY3Rpb25bU29ydERpcmVjdGlvbltcIkZRTEZvcm11bGFcIl0gPSAyXSA9IFwiRlFMRm9ybXVsYVwiO1xyXG59KShTb3J0RGlyZWN0aW9uIHx8IChTb3J0RGlyZWN0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIGRlZmluZXMgdGhlIFJlb3JkZXJpbmdSdWxlTWF0Y2hUeXBlICBlbnVtXHJcbiAqL1xyXG52YXIgUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGU7XHJcbihmdW5jdGlvbiAoUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGUpIHtcclxuICAgIFJlb3JkZXJpbmdSdWxlTWF0Y2hUeXBlW1Jlb3JkZXJpbmdSdWxlTWF0Y2hUeXBlW1wiUmVzdWx0Q29udGFpbnNLZXl3b3JkXCJdID0gMF0gPSBcIlJlc3VsdENvbnRhaW5zS2V5d29yZFwiO1xyXG4gICAgUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGVbUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGVbXCJUaXRsZUNvbnRhaW5zS2V5d29yZFwiXSA9IDFdID0gXCJUaXRsZUNvbnRhaW5zS2V5d29yZFwiO1xyXG4gICAgUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGVbUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGVbXCJUaXRsZU1hdGNoZXNLZXl3b3JkXCJdID0gMl0gPSBcIlRpdGxlTWF0Y2hlc0tleXdvcmRcIjtcclxuICAgIFJlb3JkZXJpbmdSdWxlTWF0Y2hUeXBlW1Jlb3JkZXJpbmdSdWxlTWF0Y2hUeXBlW1wiVXJsU3RhcnRzV2l0aFwiXSA9IDNdID0gXCJVcmxTdGFydHNXaXRoXCI7XHJcbiAgICBSZW9yZGVyaW5nUnVsZU1hdGNoVHlwZVtSZW9yZGVyaW5nUnVsZU1hdGNoVHlwZVtcIlVybEV4YWN0bHlNYXRjaGVzXCJdID0gNF0gPSBcIlVybEV4YWN0bHlNYXRjaGVzXCI7XHJcbiAgICBSZW9yZGVyaW5nUnVsZU1hdGNoVHlwZVtSZW9yZGVyaW5nUnVsZU1hdGNoVHlwZVtcIkNvbnRlbnRUeXBlSXNcIl0gPSA1XSA9IFwiQ29udGVudFR5cGVJc1wiO1xyXG4gICAgUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGVbUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGVbXCJGaWxlRXh0ZW5zaW9uTWF0Y2hlc1wiXSA9IDZdID0gXCJGaWxlRXh0ZW5zaW9uTWF0Y2hlc1wiO1xyXG4gICAgUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGVbUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGVbXCJSZXN1bHRIYXNUYWdcIl0gPSA3XSA9IFwiUmVzdWx0SGFzVGFnXCI7XHJcbiAgICBSZW9yZGVyaW5nUnVsZU1hdGNoVHlwZVtSZW9yZGVyaW5nUnVsZU1hdGNoVHlwZVtcIk1hbnVhbENvbmRpdGlvblwiXSA9IDhdID0gXCJNYW51YWxDb25kaXRpb25cIjtcclxufSkoUmVvcmRlcmluZ1J1bGVNYXRjaFR5cGUgfHwgKFJlb3JkZXJpbmdSdWxlTWF0Y2hUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIFNwZWNpZmllcyB0aGUgdHlwZSB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5XHJcbiAqL1xyXG52YXIgUXVlcnlQcm9wZXJ0eVZhbHVlVHlwZTtcclxuKGZ1bmN0aW9uIChRdWVyeVByb3BlcnR5VmFsdWVUeXBlKSB7XHJcbiAgICBRdWVyeVByb3BlcnR5VmFsdWVUeXBlW1F1ZXJ5UHJvcGVydHlWYWx1ZVR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIFF1ZXJ5UHJvcGVydHlWYWx1ZVR5cGVbUXVlcnlQcm9wZXJ0eVZhbHVlVHlwZVtcIlN0cmluZ1R5cGVcIl0gPSAxXSA9IFwiU3RyaW5nVHlwZVwiO1xyXG4gICAgUXVlcnlQcm9wZXJ0eVZhbHVlVHlwZVtRdWVyeVByb3BlcnR5VmFsdWVUeXBlW1wiSW50MzJUeXBlXCJdID0gMl0gPSBcIkludDMyVHlwZVwiO1xyXG4gICAgUXVlcnlQcm9wZXJ0eVZhbHVlVHlwZVtRdWVyeVByb3BlcnR5VmFsdWVUeXBlW1wiQm9vbGVhblR5cGVcIl0gPSAzXSA9IFwiQm9vbGVhblR5cGVcIjtcclxuICAgIFF1ZXJ5UHJvcGVydHlWYWx1ZVR5cGVbUXVlcnlQcm9wZXJ0eVZhbHVlVHlwZVtcIlN0cmluZ0FycmF5VHlwZVwiXSA9IDRdID0gXCJTdHJpbmdBcnJheVR5cGVcIjtcclxuICAgIFF1ZXJ5UHJvcGVydHlWYWx1ZVR5cGVbUXVlcnlQcm9wZXJ0eVZhbHVlVHlwZVtcIlVuU3VwcG9ydGVkVHlwZVwiXSA9IDVdID0gXCJVblN1cHBvcnRlZFR5cGVcIjtcclxufSkoUXVlcnlQcm9wZXJ0eVZhbHVlVHlwZSB8fCAoUXVlcnlQcm9wZXJ0eVZhbHVlVHlwZSA9IHt9KSk7XHJcbnZhciBTZWFyY2hCdWlsdEluU291cmNlSWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWFyY2hCdWlsdEluU291cmNlSWQoKSB7XHJcbiAgICB9XHJcbiAgICBTZWFyY2hCdWlsdEluU291cmNlSWQuRG9jdW1lbnRzID0gXCJlN2VjOGNlZS1kZWQ4LTQzYzktYmViNS00MzZiNTRiMzFlODRcIjtcclxuICAgIFNlYXJjaEJ1aWx0SW5Tb3VyY2VJZC5JdGVtc01hdGNoaW5nQ29udGVudFR5cGUgPSBcIjVkYzlmNTAzLTgwMWUtNGNlZC04YTJjLTVkMTIzNzEzMjQxOVwiO1xyXG4gICAgU2VhcmNoQnVpbHRJblNvdXJjZUlkLkl0ZW1zTWF0Y2hpbmdUYWcgPSBcImUxMzI3YjljLTJiOGMtNGIyMy05OWM5LTM3MzBjYjI5YzNmN1wiO1xyXG4gICAgU2VhcmNoQnVpbHRJblNvdXJjZUlkLkl0ZW1zUmVsYXRlZFRvQ3VycmVudFVzZXIgPSBcIjQ4ZmVjNDJlLTRhOTItNDhjZS04MzYzLWMyNzAzYTQwZTY3ZFwiO1xyXG4gICAgU2VhcmNoQnVpbHRJblNvdXJjZUlkLkl0ZW1zV2l0aFNhbWVLZXl3b3JkQXNUaGlzSXRlbSA9IFwiNWMwNjkyODgtMWQxNy00NTRhLThhYzYtOWM2NDJhMDY1ZjQ4XCI7XHJcbiAgICBTZWFyY2hCdWlsdEluU291cmNlSWQuTG9jYWxQZW9wbGVSZXN1bHRzID0gXCJiMDlhNzk5MC0wNWVhLTRhZjktODFlZi1lZGZhYjE2YzRlMzFcIjtcclxuICAgIFNlYXJjaEJ1aWx0SW5Tb3VyY2VJZC5Mb2NhbFJlcG9ydHNBbmREYXRhUmVzdWx0cyA9IFwiMjAzZmJhMzYtMjc2My00MDYwLTk5MzEtOTExYWM4YzA1ODNiXCI7XHJcbiAgICBTZWFyY2hCdWlsdEluU291cmNlSWQuTG9jYWxTaGFyZVBvaW50UmVzdWx0cyA9IFwiODQxM2NkMzktMjE1Ni00ZTAwLWI1NGQtMTFlZmQ5YWJkYjg5XCI7XHJcbiAgICBTZWFyY2hCdWlsdEluU291cmNlSWQuTG9jYWxWaWRlb1Jlc3VsdHMgPSBcIjc4Yjc5M2NlLTc5NTYtNDY2OS1hYTNiLTQ1MWZjNWRlZmViZlwiO1xyXG4gICAgU2VhcmNoQnVpbHRJblNvdXJjZUlkLlBhZ2VzID0gXCI1ZTM0NTc4ZS00ZDA4LTRlZGMtOGJmMy0wMDJhY2YzY2RiY2NcIjtcclxuICAgIFNlYXJjaEJ1aWx0SW5Tb3VyY2VJZC5QaWN0dXJlcyA9IFwiMzg0MDNjOGMtMzk3NS00MWE4LTgyNmUtNzE3ZjJkNDE1NjhhXCI7XHJcbiAgICBTZWFyY2hCdWlsdEluU291cmNlSWQuUG9wdWxhciA9IFwiOTdjNzFkYjEtNThjZS00ODkxLThiNjQtNTg1YmMyMzI2YzEyXCI7XHJcbiAgICBTZWFyY2hCdWlsdEluU291cmNlSWQuUmVjZW50bHlDaGFuZ2VkSXRlbXMgPSBcImJhNjNiYmFlLWZhOWMtNDJjMC1iMDI3LTlhODc4ZjE2NTU3Y1wiO1xyXG4gICAgU2VhcmNoQnVpbHRJblNvdXJjZUlkLlJlY29tbWVuZGVkSXRlbXMgPSBcImVjNjc1MjUyLTE0ZmEtNGZiZS04NGRkLThkMDk4ZWQ3NDE4MVwiO1xyXG4gICAgU2VhcmNoQnVpbHRJblNvdXJjZUlkLldpa2kgPSBcIjk0NzliZjg1LWUyNTctNDMxOC1iNWE4LTgxYTE4MGY1ZmFhMVwiO1xyXG4gICAgcmV0dXJuIFNlYXJjaEJ1aWx0SW5Tb3VyY2VJZDtcclxufSgpKTtcblxudmFyIFNlYXJjaFN1Z2dlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2VhcmNoU3VnZ2VzdCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNlYXJjaFN1Z2dlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgU2VhcmNoU3VnZ2VzdC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgIHRoaXMubWFwUXVlcnlUb1F1ZXJ5U3RyaW5nKHF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICB2YXIgbWFwcGVyID0gaE9QKHJlc3BvbnNlLCBcInN1Z2dlc3RcIikgPyBmdW5jdGlvbiAocykgeyByZXR1cm4gcmVzcG9uc2Uuc3VnZ2VzdFtzXS5yZXN1bHRzOyB9IDogZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHJlc3BvbnNlW3NdOyB9O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgUGVvcGxlTmFtZXM6IG1hcHBlcihcIlBlb3BsZU5hbWVzXCIpLFxyXG4gICAgICAgICAgICAgICAgUGVyc29uYWxSZXN1bHRzOiBtYXBwZXIoXCJQZXJzb25hbFJlc3VsdHNcIiksXHJcbiAgICAgICAgICAgICAgICBRdWVyaWVzOiBtYXBwZXIoXCJRdWVyaWVzXCIpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFNlYXJjaFN1Z2dlc3QucHJvdG90eXBlLm1hcFF1ZXJ5VG9RdWVyeVN0cmluZyA9IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNldFByb3AgPSBmdW5jdGlvbiAocSkgeyByZXR1cm4gZnVuY3Rpb24gKGNoZWNrUHJvcCkgeyByZXR1cm4gZnVuY3Rpb24gKHNwKSB7XHJcbiAgICAgICAgICAgIGlmIChoT1AocSwgY2hlY2tQcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucXVlcnkuc2V0KHNwLCBxW2NoZWNrUHJvcF0udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9OyB9OyB9O1xyXG4gICAgICAgIHRoaXMucXVlcnkuc2V0KFwicXVlcnl0ZXh0XCIsIFwiJ1wiICsgcXVlcnkucXVlcnl0ZXh0ICsgXCInXCIpO1xyXG4gICAgICAgIHZhciBxdWVyeVNldHRlciA9IHNldFByb3AocXVlcnkpO1xyXG4gICAgICAgIHF1ZXJ5U2V0dGVyKFwiY291bnRcIikoXCJpbnVtYmVyb2ZxdWVyeXN1Z2dlc3Rpb25zXCIpO1xyXG4gICAgICAgIHF1ZXJ5U2V0dGVyKFwicGVyc29uYWxDb3VudFwiKShcImludW1iZXJvZnJlc3VsdHN1Z2dlc3Rpb25zXCIpO1xyXG4gICAgICAgIHF1ZXJ5U2V0dGVyKFwicHJlUXVlcnlcIikoXCJmcHJlcXVlcnlzdWdnZXN0aW9uc1wiKTtcclxuICAgICAgICBxdWVyeVNldHRlcihcImhpdEhpZ2hsaWdodGluZ1wiKShcImZoaXRoaWdobGlnaHRpbmdcIik7XHJcbiAgICAgICAgcXVlcnlTZXR0ZXIoXCJjYXBpdGFsaXplXCIpKFwiZmNhcGl0YWxpemVmaXJzdGxldHRlcnNcIik7XHJcbiAgICAgICAgcXVlcnlTZXR0ZXIoXCJjdWx0dXJlXCIpKFwiY3VsdHVyZVwiKTtcclxuICAgICAgICBxdWVyeVNldHRlcihcInN0ZW1taW5nXCIpKFwiZW5hYmxlc3RlbW1pbmdcIik7XHJcbiAgICAgICAgcXVlcnlTZXR0ZXIoXCJpbmNsdWRlUGVvcGxlXCIpKFwic2hvd3Blb3BsZW5hbWVzdWdnZXN0aW9uc1wiKTtcclxuICAgICAgICBxdWVyeVNldHRlcihcInF1ZXJ5UnVsZXNcIikoXCJlbmFibGVxdWVyeXJ1bGVzXCIpO1xyXG4gICAgICAgIHF1ZXJ5U2V0dGVyKFwicHJlZml4TWF0Y2hcIikoXCJmcHJlZml4bWF0Y2hhbGx0ZXJtc1wiKTtcclxuICAgIH07XHJcbiAgICBTZWFyY2hTdWdnZXN0ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJfYXBpL3NlYXJjaC9zdWdnZXN0XCIpXHJcbiAgICBdLCBTZWFyY2hTdWdnZXN0KTtcclxuICAgIHJldHVybiBTZWFyY2hTdWdnZXN0O1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xuXG4vKipcclxuICogRGVzY3JpYmVzIGEgY29sbGVjdGlvbiBvZiBMaXN0IG9iamVjdHNcclxuICpcclxuICovXHJcbnZhciBGZWF0dXJlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGZWF0dXJlcywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZlYXR1cmVzKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEZlYXR1cmVzXzEgPSBGZWF0dXJlcztcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBsaXN0IHRvIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIFRoZSBJZCBvZiB0aGUgZmVhdHVyZSAoR1VJRClcclxuICAgICAqIEBwYXJhbSBmb3JjZSBJZiB0cnVlIHRoZSBmZWF0dXJlIGFjdGl2YXRpb24gd2lsbCBiZSBmb3JjZWRcclxuICAgICAqL1xyXG4gICAgRmVhdHVyZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpZCwgZm9yY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGZWF0dXJlc18xLCBcImFkZFwiKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyh7XHJcbiAgICAgICAgICAgICAgICBmZWF0ZGVmU2NvcGU6IDAsXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlSWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgZm9yY2U6IGZvcmNlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZTogX3RoaXMuZ2V0QnlJZChpZCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgbGlzdCBmcm9tIHRoZSBjb2xsZWN0aW9uIGJ5IGd1aWQgaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWQgVGhlIElkIG9mIHRoZSBmZWF0dXJlIChHVUlEKVxyXG4gICAgICovXHJcbiAgICBGZWF0dXJlcy5wcm90b3R5cGUuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBmZWF0dXJlID0gbmV3IEZlYXR1cmUodGhpcyk7XHJcbiAgICAgICAgZmVhdHVyZS5jb25jYXQoXCIoJ1wiICsgaWQgKyBcIicpXCIpO1xyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyAoZGVhY3RpdmF0ZXMpIGEgZmVhdHVyZSBmcm9tIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIFRoZSBJZCBvZiB0aGUgZmVhdHVyZSAoR1VJRClcclxuICAgICAqIEBwYXJhbSBmb3JjZSBJZiB0cnVlIHRoZSBmZWF0dXJlIGRlYWN0aXZhdGlvbiB3aWxsIGJlIGZvcmNlZFxyXG4gICAgICovXHJcbiAgICBGZWF0dXJlcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGlkLCBmb3JjZSkge1xyXG4gICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShGZWF0dXJlc18xLCBcInJlbW92ZVwiKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyh7XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlSWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgZm9yY2U6IGZvcmNlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgRmVhdHVyZXNfMTtcclxuICAgIEZlYXR1cmVzID0gRmVhdHVyZXNfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwiZmVhdHVyZXNcIilcclxuICAgIF0sIEZlYXR1cmVzKTtcclxuICAgIHJldHVybiBGZWF0dXJlcztcclxufShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbikpO1xyXG52YXIgRmVhdHVyZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGZWF0dXJlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRmVhdHVyZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgKGRlYWN0aXZhdGVzKSBhIGZlYXR1cmUgZnJvbSB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmb3JjZSBJZiB0cnVlIHRoZSBmZWF0dXJlIGRlYWN0aXZhdGlvbiB3aWxsIGJlIGZvcmNlZFxyXG4gICAgICovXHJcbiAgICBGZWF0dXJlLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKGZvcmNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHJlbW92ZURlcGVuZGVuY3kgPSB0aGlzLmFkZEJhdGNoRGVwZW5kZW5jeSgpO1xyXG4gICAgICAgIHZhciBpZEdldCA9IG5ldyBGZWF0dXJlKHRoaXMpLnNlbGVjdChcIkRlZmluaXRpb25JZFwiKTtcclxuICAgICAgICByZXR1cm4gaWRHZXQuZ2V0KCkudGhlbihmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IF90aGlzLmdldFBhcmVudChGZWF0dXJlcywgX3RoaXMucGFyZW50VXJsLCBcIlwiLCBfdGhpcy5iYXRjaCkucmVtb3ZlKGZlYXR1cmUuRGVmaW5pdGlvbklkLCBmb3JjZSk7XHJcbiAgICAgICAgICAgIHJlbW92ZURlcGVuZGVuY3koKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZlYXR1cmU7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XG5cbnZhciBSZWxhdGVkSXRlbU1hbmFnZXJJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJlbGF0ZWRJdGVtTWFuYWdlckltcGwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZWxhdGVkSXRlbU1hbmFnZXJJbXBsKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFJlbGF0ZWRJdGVtTWFuYWdlckltcGxfMSA9IFJlbGF0ZWRJdGVtTWFuYWdlckltcGw7XHJcbiAgICBSZWxhdGVkSXRlbU1hbmFnZXJJbXBsLkZyb21VcmwgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgaWYgKHVybCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlbGF0ZWRJdGVtTWFuYWdlckltcGxfMShcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdXJsLmluZGV4T2YoXCJfYXBpL1wiKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlbGF0ZWRJdGVtTWFuYWdlckltcGxfMSh1cmwuc3Vic3RyKDAsIGluZGV4KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmVsYXRlZEl0ZW1NYW5hZ2VySW1wbF8xKHVybCk7XHJcbiAgICB9O1xyXG4gICAgUmVsYXRlZEl0ZW1NYW5hZ2VySW1wbC5wcm90b3R5cGUuZ2V0UmVsYXRlZEl0ZW1zID0gZnVuY3Rpb24gKHNvdXJjZUxpc3ROYW1lLCBzb3VyY2VJdGVtSWQpIHtcclxuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLmNsb25lKFJlbGF0ZWRJdGVtTWFuYWdlckltcGxfMSwgbnVsbCk7XHJcbiAgICAgICAgcXVlcnkuY29uY2F0KFwiLkdldFJlbGF0ZWRJdGVtc1wiKTtcclxuICAgICAgICByZXR1cm4gcXVlcnkucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1Moe1xyXG4gICAgICAgICAgICAgICAgU291cmNlSXRlbUlEOiBzb3VyY2VJdGVtSWQsXHJcbiAgICAgICAgICAgICAgICBTb3VyY2VMaXN0TmFtZTogc291cmNlTGlzdE5hbWUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFJlbGF0ZWRJdGVtTWFuYWdlckltcGwucHJvdG90eXBlLmdldFBhZ2VPbmVSZWxhdGVkSXRlbXMgPSBmdW5jdGlvbiAoc291cmNlTGlzdE5hbWUsIHNvdXJjZUl0ZW1JZCkge1xyXG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMuY2xvbmUoUmVsYXRlZEl0ZW1NYW5hZ2VySW1wbF8xLCBudWxsKTtcclxuICAgICAgICBxdWVyeS5jb25jYXQoXCIuR2V0UGFnZU9uZVJlbGF0ZWRJdGVtc1wiKTtcclxuICAgICAgICByZXR1cm4gcXVlcnkucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1Moe1xyXG4gICAgICAgICAgICAgICAgU291cmNlSXRlbUlEOiBzb3VyY2VJdGVtSWQsXHJcbiAgICAgICAgICAgICAgICBTb3VyY2VMaXN0TmFtZTogc291cmNlTGlzdE5hbWUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFJlbGF0ZWRJdGVtTWFuYWdlckltcGwucHJvdG90eXBlLmFkZFNpbmdsZUxpbmsgPSBmdW5jdGlvbiAoc291cmNlTGlzdE5hbWUsIHNvdXJjZUl0ZW1JZCwgc291cmNlV2ViVXJsLCB0YXJnZXRMaXN0TmFtZSwgdGFyZ2V0SXRlbUlELCB0YXJnZXRXZWJVcmwsIHRyeUFkZFJldmVyc2VMaW5rKSB7XHJcbiAgICAgICAgaWYgKHRyeUFkZFJldmVyc2VMaW5rID09PSB2b2lkIDApIHsgdHJ5QWRkUmV2ZXJzZUxpbmsgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMuY2xvbmUoUmVsYXRlZEl0ZW1NYW5hZ2VySW1wbF8xLCBudWxsKTtcclxuICAgICAgICBxdWVyeS5jb25jYXQoXCIuQWRkU2luZ2xlTGlua1wiKTtcclxuICAgICAgICByZXR1cm4gcXVlcnkucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1Moe1xyXG4gICAgICAgICAgICAgICAgU291cmNlSXRlbUlEOiBzb3VyY2VJdGVtSWQsXHJcbiAgICAgICAgICAgICAgICBTb3VyY2VMaXN0TmFtZTogc291cmNlTGlzdE5hbWUsXHJcbiAgICAgICAgICAgICAgICBTb3VyY2VXZWJVcmw6IHNvdXJjZVdlYlVybCxcclxuICAgICAgICAgICAgICAgIFRhcmdldEl0ZW1JRDogdGFyZ2V0SXRlbUlELFxyXG4gICAgICAgICAgICAgICAgVGFyZ2V0TGlzdE5hbWU6IHRhcmdldExpc3ROYW1lLFxyXG4gICAgICAgICAgICAgICAgVGFyZ2V0V2ViVXJsOiB0YXJnZXRXZWJVcmwsXHJcbiAgICAgICAgICAgICAgICBUcnlBZGRSZXZlcnNlTGluazogdHJ5QWRkUmV2ZXJzZUxpbmssXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJlbGF0ZWQgaXRlbSBsaW5rIGZyb20gYW4gaXRlbSBzcGVjaWZpZWQgYnkgbGlzdCBuYW1lIGFuZCBpdGVtIGlkLCB0byBhbiBpdGVtIHNwZWNpZmllZCBieSB1cmxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc291cmNlTGlzdE5hbWUgVGhlIHNvdXJjZSBsaXN0IG5hbWUgb3IgbGlzdCBpZFxyXG4gICAgICogQHBhcmFtIHNvdXJjZUl0ZW1JZCBUaGUgc291cmNlIGl0ZW0gaWRcclxuICAgICAqIEBwYXJhbSB0YXJnZXRJdGVtVXJsIFRoZSB0YXJnZXQgaXRlbSB1cmxcclxuICAgICAqIEBwYXJhbSB0cnlBZGRSZXZlcnNlTGluayBJZiBzZXQgdG8gdHJ1ZSB0cnkgdG8gYWRkIHRoZSByZXZlcnNlIGxpbmsgKHdpbGwgbm90IHJldHVybiBlcnJvciBpZiBpdCBmYWlscylcclxuICAgICAqL1xyXG4gICAgUmVsYXRlZEl0ZW1NYW5hZ2VySW1wbC5wcm90b3R5cGUuYWRkU2luZ2xlTGlua1RvVXJsID0gZnVuY3Rpb24gKHNvdXJjZUxpc3ROYW1lLCBzb3VyY2VJdGVtSWQsIHRhcmdldEl0ZW1VcmwsIHRyeUFkZFJldmVyc2VMaW5rKSB7XHJcbiAgICAgICAgaWYgKHRyeUFkZFJldmVyc2VMaW5rID09PSB2b2lkIDApIHsgdHJ5QWRkUmV2ZXJzZUxpbmsgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMuY2xvbmUoUmVsYXRlZEl0ZW1NYW5hZ2VySW1wbF8xLCBudWxsKTtcclxuICAgICAgICBxdWVyeS5jb25jYXQoXCIuQWRkU2luZ2xlTGlua1RvVXJsXCIpO1xyXG4gICAgICAgIHJldHVybiBxdWVyeS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyh7XHJcbiAgICAgICAgICAgICAgICBTb3VyY2VJdGVtSUQ6IHNvdXJjZUl0ZW1JZCxcclxuICAgICAgICAgICAgICAgIFNvdXJjZUxpc3ROYW1lOiBzb3VyY2VMaXN0TmFtZSxcclxuICAgICAgICAgICAgICAgIFRhcmdldEl0ZW1Vcmw6IHRhcmdldEl0ZW1VcmwsXHJcbiAgICAgICAgICAgICAgICBUcnlBZGRSZXZlcnNlTGluazogdHJ5QWRkUmV2ZXJzZUxpbmssXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJlbGF0ZWQgaXRlbSBsaW5rIGZyb20gYW4gaXRlbSBzcGVjaWZpZWQgYnkgdXJsLCB0byBhbiBpdGVtIHNwZWNpZmllZCBieSBsaXN0IG5hbWUgYW5kIGl0ZW0gaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc291cmNlSXRlbVVybCBUaGUgc291cmNlIGl0ZW0gdXJsXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TGlzdE5hbWUgVGhlIHRhcmdldCBsaXN0IG5hbWUgb3IgbGlzdCBpZFxyXG4gICAgICogQHBhcmFtIHRhcmdldEl0ZW1JZCBUaGUgdGFyZ2V0IGl0ZW0gaWRcclxuICAgICAqIEBwYXJhbSB0cnlBZGRSZXZlcnNlTGluayBJZiBzZXQgdG8gdHJ1ZSB0cnkgdG8gYWRkIHRoZSByZXZlcnNlIGxpbmsgKHdpbGwgbm90IHJldHVybiBlcnJvciBpZiBpdCBmYWlscylcclxuICAgICAqL1xyXG4gICAgUmVsYXRlZEl0ZW1NYW5hZ2VySW1wbC5wcm90b3R5cGUuYWRkU2luZ2xlTGlua0Zyb21VcmwgPSBmdW5jdGlvbiAoc291cmNlSXRlbVVybCwgdGFyZ2V0TGlzdE5hbWUsIHRhcmdldEl0ZW1JZCwgdHJ5QWRkUmV2ZXJzZUxpbmspIHtcclxuICAgICAgICBpZiAodHJ5QWRkUmV2ZXJzZUxpbmsgPT09IHZvaWQgMCkgeyB0cnlBZGRSZXZlcnNlTGluayA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5jbG9uZShSZWxhdGVkSXRlbU1hbmFnZXJJbXBsXzEsIG51bGwpO1xyXG4gICAgICAgIHF1ZXJ5LmNvbmNhdChcIi5BZGRTaW5nbGVMaW5rRnJvbVVybFwiKTtcclxuICAgICAgICByZXR1cm4gcXVlcnkucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1Moe1xyXG4gICAgICAgICAgICAgICAgU291cmNlSXRlbVVybDogc291cmNlSXRlbVVybCxcclxuICAgICAgICAgICAgICAgIFRhcmdldEl0ZW1JRDogdGFyZ2V0SXRlbUlkLFxyXG4gICAgICAgICAgICAgICAgVGFyZ2V0TGlzdE5hbWU6IHRhcmdldExpc3ROYW1lLFxyXG4gICAgICAgICAgICAgICAgVHJ5QWRkUmV2ZXJzZUxpbms6IHRyeUFkZFJldmVyc2VMaW5rLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSZWxhdGVkSXRlbU1hbmFnZXJJbXBsLnByb3RvdHlwZS5kZWxldGVTaW5nbGVMaW5rID0gZnVuY3Rpb24gKHNvdXJjZUxpc3ROYW1lLCBzb3VyY2VJdGVtSWQsIHNvdXJjZVdlYlVybCwgdGFyZ2V0TGlzdE5hbWUsIHRhcmdldEl0ZW1JZCwgdGFyZ2V0V2ViVXJsLCB0cnlEZWxldGVSZXZlcnNlTGluaykge1xyXG4gICAgICAgIGlmICh0cnlEZWxldGVSZXZlcnNlTGluayA9PT0gdm9pZCAwKSB7IHRyeURlbGV0ZVJldmVyc2VMaW5rID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLmNsb25lKFJlbGF0ZWRJdGVtTWFuYWdlckltcGxfMSwgbnVsbCk7XHJcbiAgICAgICAgcXVlcnkuY29uY2F0KFwiLkRlbGV0ZVNpbmdsZUxpbmtcIik7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHtcclxuICAgICAgICAgICAgICAgIFNvdXJjZUl0ZW1JRDogc291cmNlSXRlbUlkLFxyXG4gICAgICAgICAgICAgICAgU291cmNlTGlzdE5hbWU6IHNvdXJjZUxpc3ROYW1lLFxyXG4gICAgICAgICAgICAgICAgU291cmNlV2ViVXJsOiBzb3VyY2VXZWJVcmwsXHJcbiAgICAgICAgICAgICAgICBUYXJnZXRJdGVtSUQ6IHRhcmdldEl0ZW1JZCxcclxuICAgICAgICAgICAgICAgIFRhcmdldExpc3ROYW1lOiB0YXJnZXRMaXN0TmFtZSxcclxuICAgICAgICAgICAgICAgIFRhcmdldFdlYlVybDogdGFyZ2V0V2ViVXJsLFxyXG4gICAgICAgICAgICAgICAgVHJ5RGVsZXRlUmV2ZXJzZUxpbms6IHRyeURlbGV0ZVJldmVyc2VMaW5rLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgUmVsYXRlZEl0ZW1NYW5hZ2VySW1wbF8xO1xyXG4gICAgUmVsYXRlZEl0ZW1NYW5hZ2VySW1wbCA9IFJlbGF0ZWRJdGVtTWFuYWdlckltcGxfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwiX2FwaS9TUC5SZWxhdGVkSXRlbU1hbmFnZXJcIilcclxuICAgIF0sIFJlbGF0ZWRJdGVtTWFuYWdlckltcGwpO1xyXG4gICAgcmV0dXJuIFJlbGF0ZWRJdGVtTWFuYWdlckltcGw7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZSkpO1xuXG4vKipcclxuICogRGVzY3JpYmVzIGEgY29sbGVjdGlvbiBvZiB3ZWJzXHJcbiAqXHJcbiAqL1xyXG52YXIgV2VicyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhXZWJzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gV2VicygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBXZWJzXzEgPSBXZWJzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IHdlYiB0byB0aGUgY29sbGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aXRsZSBUaGUgbmV3IHdlYidzIHRpdGxlXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBuZXcgd2ViJ3MgcmVsYXRpdmUgdXJsXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gVGhlIG5ldyB3ZWIncyBkZXNjcmlwdGlvblxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIFRoZSBuZXcgd2ViJ3MgdGVtcGxhdGUgaW50ZXJuYWwgbmFtZSAoZGVmYXVsdCA9IFNUUylcclxuICAgICAqIEBwYXJhbSBsYW5ndWFnZSBUaGUgbG9jYWxlIGlkIHRoYXQgc3BlY2lmaWVzIHRoZSBuZXcgd2ViJ3MgbGFuZ3VhZ2UgKGRlZmF1bHQgPSAxMDMzIFtFbmdsaXNoLCBVU10pXHJcbiAgICAgKiBAcGFyYW0gaW5oZXJpdFBlcm1pc3Npb25zIFdoZW4gdHJ1ZSwgcGVybWlzc2lvbnMgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgbmV3IHdlYidzIHBhcmVudCAoZGVmYXVsdCA9IHRydWUpXHJcbiAgICAgKi9cclxuICAgIFdlYnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0aXRsZSwgdXJsLCBkZXNjcmlwdGlvbiwgdGVtcGxhdGUsIGxhbmd1YWdlLCBpbmhlcml0UGVybWlzc2lvbnMpIHtcclxuICAgICAgICBpZiAoZGVzY3JpcHRpb24gPT09IHZvaWQgMCkgeyBkZXNjcmlwdGlvbiA9IFwiXCI7IH1cclxuICAgICAgICBpZiAodGVtcGxhdGUgPT09IHZvaWQgMCkgeyB0ZW1wbGF0ZSA9IFwiU1RTXCI7IH1cclxuICAgICAgICBpZiAobGFuZ3VhZ2UgPT09IHZvaWQgMCkgeyBsYW5ndWFnZSA9IDEwMzM7IH1cclxuICAgICAgICBpZiAoaW5oZXJpdFBlcm1pc3Npb25zID09PSB2b2lkIDApIHsgaW5oZXJpdFBlcm1pc3Npb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBwcm9wcyA9IHtcclxuICAgICAgICAgICAgRGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICBMYW5ndWFnZTogbGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgIFRpdGxlOiB0aXRsZSxcclxuICAgICAgICAgICAgVXJsOiB1cmwsXHJcbiAgICAgICAgICAgIFVzZVNhbWVQZXJtaXNzaW9uc0FzUGFyZW50U2l0ZTogaW5oZXJpdFBlcm1pc3Npb25zLFxyXG4gICAgICAgICAgICBXZWJUZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcG9zdEJvZHkgPSBqc1Moe1xyXG4gICAgICAgICAgICBcInBhcmFtZXRlcnNcIjogZXh0ZW5kKHtcclxuICAgICAgICAgICAgICAgIFwiX19tZXRhZGF0YVwiOiB7IFwidHlwZVwiOiBcIlNQLldlYkNyZWF0aW9uSW5mb3JtYXRpb25cIiB9LFxyXG4gICAgICAgICAgICB9LCBwcm9wcyksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoV2Vic18xLCBcImFkZFwiKS5wb3N0Q29yZSh7IGJvZHk6IHBvc3RCb2R5IH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICB3ZWI6IG5ldyBXZWIob2RhdGFVcmxGcm9tKGRhdGEpLnJlcGxhY2UoL19hcGlcXC93ZWJcXC8/L2ksIFwiXCIpKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgV2Vic18xO1xyXG4gICAgV2VicyA9IFdlYnNfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwid2Vic1wiKVxyXG4gICAgXSwgV2Vicyk7XHJcbiAgICByZXR1cm4gV2VicztcclxufShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbikpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIGEgY29sbGVjdGlvbiBvZiB3ZWIgaW5mb3NcclxuICpcclxuICovXHJcbnZhciBXZWJJbmZvcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhXZWJJbmZvcywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFdlYkluZm9zKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFdlYkluZm9zID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJ3ZWJpbmZvc1wiKVxyXG4gICAgXSwgV2ViSW5mb3MpO1xyXG4gICAgcmV0dXJuIFdlYkluZm9zO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVDb2xsZWN0aW9uKSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgYSB3ZWJcclxuICpcclxuICovXHJcbnZhciBXZWIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoV2ViLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gV2ViKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFdlYl8xID0gV2ViO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHdlYiBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiB1cmwgYnkgaW5kZXhpbmcgdGhlIGxvY2F0aW9uIG9mIHRoZSAvX2FwaS9cclxuICAgICAqIHNlZ21lbnQuIElmIHRoaXMgaXMgbm90IGZvdW5kIHRoZSBtZXRob2QgY3JlYXRlcyBhIG5ldyB3ZWIgd2l0aCB0aGUgZW50aXJlIHN0cmluZyBhc1xyXG4gICAgICogc3VwcGxpZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVybFxyXG4gICAgICovXHJcbiAgICBXZWIuZnJvbVVybCA9IGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFdlYl8xKGV4dHJhY3RXZWJVcmwodXJsKSwgcGF0aCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwid2Vic1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGlzIHdlYidzIHN1YndlYnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYnModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhpcyB3ZWIncyBwYXJlbnQgd2ViIGFuZCBkYXRhXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBXZWIucHJvdG90eXBlLmdldFBhcmVudFdlYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdChcIlBhcmVudFdlYi9JZFwiKS5leHBhbmQoXCJQYXJlbnRXZWJcIikuZ2V0KClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBQYXJlbnRXZWIgPSBfYS5QYXJlbnRXZWI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2l0ZShfdGhpcy50b1VybEFuZFF1ZXJ5KCkuc3BsaXQoXCIvX2FwaVwiKVswXSkub3BlbldlYkJ5SWQoUGFyZW50V2ViLklkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyBhIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyB0aGF0IGNvbnRhaW4gbWV0YWRhdGEgYWJvdXQgc3Vic2l0ZXMgb2YgdGhlIGN1cnJlbnQgc2l0ZSBpbiB3aGljaCB0aGUgY3VycmVudCB1c2VyIGlzIGEgbWVtYmVyLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0gbldlYlRlbXBsYXRlRmlsdGVyIFNwZWNpZmllcyB0aGUgc2l0ZSBkZWZpbml0aW9uIChkZWZhdWx0ID0gLTEpXHJcbiAgICAqIEBwYXJhbSBuQ29uZmlndXJhdGlvbkZpbHRlciBBIDE2LWJpdCBpbnRlZ2VyIHRoYXQgc3BlY2lmaWVzIHRoZSBpZGVudGlmaWVyIG9mIGEgY29uZmlndXJhdGlvbiAoZGVmYXVsdCA9IC0xKVxyXG4gICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUuZ2V0U3Vid2Vic0ZpbHRlcmVkRm9yQ3VycmVudFVzZXIgPSBmdW5jdGlvbiAobldlYlRlbXBsYXRlRmlsdGVyLCBuQ29uZmlndXJhdGlvbkZpbHRlcikge1xyXG4gICAgICAgIGlmIChuV2ViVGVtcGxhdGVGaWx0ZXIgPT09IHZvaWQgMCkgeyBuV2ViVGVtcGxhdGVGaWx0ZXIgPSAtMTsgfVxyXG4gICAgICAgIGlmIChuQ29uZmlndXJhdGlvbkZpbHRlciA9PT0gdm9pZCAwKSB7IG5Db25maWd1cmF0aW9uRmlsdGVyID0gLTE7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShXZWJzLCBcImdldFN1YndlYnNGaWx0ZXJlZEZvckN1cnJlbnRVc2VyKG5XZWJUZW1wbGF0ZUZpbHRlcj1cIiArIG5XZWJUZW1wbGF0ZUZpbHRlciArIFwiLG5Db25maWd1cmF0aW9uRmlsdGVyPVwiICsgbkNvbmZpZ3VyYXRpb25GaWx0ZXIgKyBcIilcIik7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwiYWxsUHJvcGVydGllc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsb3dzIGFjY2VzcyB0byB0aGUgd2ViJ3MgYWxsIHByb3BlcnRpZXMgY29sbGVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbiwgXCJhbGxwcm9wZXJ0aWVzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwid2ViaW5mb3NcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYSBjb2xsZWN0aW9uIG9mIFdlYkluZm9zIGZvciB0aGlzIHdlYidzIHN1YndlYnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkluZm9zKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwiY29udGVudFR5cGVzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjb250ZW50IHR5cGVzIGF2YWlsYWJsZSBpbiB0aGlzIHdlYlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29udGVudFR5cGVzKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwibGlzdHNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGxpc3RzIGluIHRoaXMgd2ViXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0cyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWIucHJvdG90eXBlLCBcImZpZWxkc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZmllbGRzIGluIHRoaXMgd2ViXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaWVsZHModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViLnByb3RvdHlwZSwgXCJmZWF0dXJlc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgYWN0aXZlIGZlYXR1cmVzIGZvciB0aGlzIHdlYlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmVhdHVyZXModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViLnByb3RvdHlwZSwgXCJhdmFpbGFibGVmaWVsZHNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGF2YWlsYWJsZSBmaWVsZHMgaW4gdGhpcyB3ZWJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpZWxkcyh0aGlzLCBcImF2YWlsYWJsZWZpZWxkc1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWIucHJvdG90eXBlLCBcIm5hdmlnYXRpb25cIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIG5hdmlnYXRpb24gb3B0aW9ucyBpbiB0aGlzIHdlYlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvbih0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWIucHJvdG90eXBlLCBcInNpdGVVc2Vyc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgc2l0ZSB1c2Vyc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2l0ZVVzZXJzKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwic2l0ZUdyb3Vwc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgc2l0ZSBncm91cHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpdGVHcm91cHModGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViLnByb3RvdHlwZSwgXCJzaXRlVXNlckluZm9MaXN0XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHNpdGUgdXNlciBpbmZvIGxpc3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3QodGhpcywgXCJzaXRldXNlcmluZm9saXN0XCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwicmVnaW9uYWxTZXR0aW5nc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyByZWdpb25hbCBzZXR0aW5nc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnaW9uYWxTZXR0aW5ncyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWIucHJvdG90eXBlLCBcImN1cnJlbnRVc2VyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHVzZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXJyZW50VXNlcih0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWIucHJvdG90eXBlLCBcImZvbGRlcnNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHRvcC1sZXZlbCBmb2xkZXJzIGluIHRoaXMgd2ViXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb2xkZXJzKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwidXNlckN1c3RvbUFjdGlvbnNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgYWxsIHVzZXIgY3VzdG9tIGFjdGlvbnMgZm9yIHRoaXMgd2ViXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2VyQ3VzdG9tQWN0aW9ucyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWIucHJvdG90eXBlLCBcInJvbGVEZWZpbml0aW9uc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY29sbGVjdGlvbiBvZiBSb2xlRGVmaW5pdGlvbiByZXNvdXJjZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJvbGVEZWZpbml0aW9ucyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWIucHJvdG90eXBlLCBcInJlbGF0ZWRJdGVtc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRvIG1hbmFnZSByZWxhdGVkIGl0ZW1zXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlbGF0ZWRJdGVtTWFuYWdlckltcGwuRnJvbVVybCh0aGlzLnRvVXJsKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGJhdGNoIGZvciByZXF1ZXN0cyB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhpcyB3ZWJcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUuY3JlYXRlQmF0Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTUEJhdGNoKHRoaXMucGFyZW50VXJsKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViLnByb3RvdHlwZSwgXCJyb290Rm9sZGVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSByb290IGZvbGRlciBvZiB0aGlzIHdlYlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9sZGVyKHRoaXMsIFwicm9vdEZvbGRlclwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWIucHJvdG90eXBlLCBcImFzc29jaWF0ZWRPd25lckdyb3VwXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBhc3NvY2lhdGVkIG93bmVyIGdyb3VwIGZvciB0aGlzIHdlYlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2l0ZUdyb3VwKHRoaXMsIFwiYXNzb2NpYXRlZG93bmVyZ3JvdXBcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViLnByb3RvdHlwZSwgXCJhc3NvY2lhdGVkTWVtYmVyR3JvdXBcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGFzc29jaWF0ZWQgbWVtYmVyIGdyb3VwIGZvciB0aGlzIHdlYlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2l0ZUdyb3VwKHRoaXMsIFwiYXNzb2NpYXRlZG1lbWJlcmdyb3VwXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwiYXNzb2NpYXRlZFZpc2l0b3JHcm91cFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgYXNzb2NpYXRlZCB2aXNpdG9yIGdyb3VwIGZvciB0aGlzIHdlYlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2l0ZUdyb3VwKHRoaXMsIFwiYXNzb2NpYXRlZHZpc2l0b3Jncm91cFwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWIucHJvdG90eXBlLCBcImRlZmF1bHREb2N1bWVudExpYnJhcnlcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgZG9jdW1lbnQgbGlicmFyeSBmb3IgdGhpcyB3ZWJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3QodGhpcywgXCJEZWZhdWx0RG9jdW1lbnRMaWJyYXJ5XCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgZm9sZGVyIGJ5IHNlcnZlciByZWxhdGl2ZSB1cmxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm9sZGVyUmVsYXRpdmVVcmwgVGhlIHNlcnZlciByZWxhdGl2ZSBwYXRoIHRvIHRoZSBmb2xkZXIgKGluY2x1ZGluZyAvc2l0ZXMvIGlmIGFwcGxpY2FibGUpXHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUuZ2V0Rm9sZGVyQnlTZXJ2ZXJSZWxhdGl2ZVVybCA9IGZ1bmN0aW9uIChmb2xkZXJSZWxhdGl2ZVVybCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRm9sZGVyKHRoaXMsIFwiZ2V0Rm9sZGVyQnlTZXJ2ZXJSZWxhdGl2ZVVybCgnXCIgKyBmb2xkZXJSZWxhdGl2ZVVybCArIFwiJylcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgZm9sZGVyIGJ5IHNlcnZlciByZWxhdGl2ZSByZWxhdGl2ZSBwYXRoIGlmIHlvdXIgZm9sZGVyIG5hbWUgY29udGFpbnMgIyBhbmQgJSBjaGFyYWN0ZXJzXHJcbiAgICAgKiB5b3UgbmVlZCB0byBmaXJzdCBlbmNvZGUgdGhlIGZpbGUgbmFtZSB1c2luZyBlbmNvZGVVUklDb21wb25lbnQoKSBhbmQgdGhlbiBwYXNzIHRoZSB1cmxcclxuICAgICAqIGxldCB1cmwgPSBcIi9zaXRlcy90ZXN0L1NoYXJlZCBEb2N1bWVudHMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoXCIlMTIzXCIpO1xyXG4gICAgICogVGhpcyB3b3JrcyBvbmx5IGluIFNoYXJlUG9pbnQgb25saW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmb2xkZXJSZWxhdGl2ZVVybCBUaGUgc2VydmVyIHJlbGF0aXZlIHBhdGggdG8gdGhlIGZvbGRlciAoaW5jbHVkaW5nIC9zaXRlcy8gaWYgYXBwbGljYWJsZSlcclxuICAgICAqL1xyXG4gICAgV2ViLnByb3RvdHlwZS5nZXRGb2xkZXJCeVNlcnZlclJlbGF0aXZlUGF0aCA9IGZ1bmN0aW9uIChmb2xkZXJSZWxhdGl2ZVVybCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRm9sZGVyKHRoaXMsIFwiZ2V0Rm9sZGVyQnlTZXJ2ZXJSZWxhdGl2ZVBhdGgoZGVjb2RlZFVybD0nXCIgKyBmb2xkZXJSZWxhdGl2ZVVybCArIFwiJylcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgZmlsZSBieSBzZXJ2ZXIgcmVsYXRpdmUgdXJsXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpbGVSZWxhdGl2ZVVybCBUaGUgc2VydmVyIHJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUgKGluY2x1ZGluZyAvc2l0ZXMvIGlmIGFwcGxpY2FibGUpXHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUuZ2V0RmlsZUJ5U2VydmVyUmVsYXRpdmVVcmwgPSBmdW5jdGlvbiAoZmlsZVJlbGF0aXZlVXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlKHRoaXMsIFwiZ2V0RmlsZUJ5U2VydmVyUmVsYXRpdmVVcmwoJ1wiICsgZmlsZVJlbGF0aXZlVXJsICsgXCInKVwiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBmaWxlIGJ5IHNlcnZlciByZWxhdGl2ZSB1cmwgaWYgeW91ciBmaWxlIG5hbWUgY29udGFpbnMgIyBhbmQgJSBjaGFyYWN0ZXJzXHJcbiAgICAgKiB5b3UgbmVlZCB0byBmaXJzdCBlbmNvZGUgdGhlIGZpbGUgbmFtZSB1c2luZyBlbmNvZGVVUklDb21wb25lbnQoKSBhbmQgdGhlbiBwYXNzIHRoZSB1cmxcclxuICAgICAqIGxldCB1cmwgPSBcIi9zaXRlcy90ZXN0L1NoYXJlZCBEb2N1bWVudHMvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoXCIlMTIzLmRvY3hcIik7XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpbGVSZWxhdGl2ZVVybCBUaGUgc2VydmVyIHJlbGF0aXZlIHBhdGggdG8gdGhlIGZpbGUgKGluY2x1ZGluZyAvc2l0ZXMvIGlmIGFwcGxpY2FibGUpXHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUuZ2V0RmlsZUJ5U2VydmVyUmVsYXRpdmVQYXRoID0gZnVuY3Rpb24gKGZpbGVSZWxhdGl2ZVVybCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmlsZSh0aGlzLCBcImdldEZpbGVCeVNlcnZlclJlbGF0aXZlUGF0aChkZWNvZGVkVXJsPSdcIiArIGZpbGVSZWxhdGl2ZVVybCArIFwiJylcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgbGlzdCBieSBzZXJ2ZXIgcmVsYXRpdmUgdXJsIChsaXN0J3Mgcm9vdCBmb2xkZXIpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxpc3RSZWxhdGl2ZVVybCBUaGUgc2VydmVyIHJlbGF0aXZlIHBhdGggdG8gdGhlIGxpc3QncyByb290IGZvbGRlciAoaW5jbHVkaW5nIC9zaXRlcy8gaWYgYXBwbGljYWJsZSlcclxuICAgICAqL1xyXG4gICAgV2ViLnByb3RvdHlwZS5nZXRMaXN0ID0gZnVuY3Rpb24gKGxpc3RSZWxhdGl2ZVVybCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGlzdCh0aGlzLCBcImdldExpc3QoJ1wiICsgbGlzdFJlbGF0aXZlVXJsICsgXCInKVwiKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhpcyB3ZWIgaW5zdGFuY2Ugd2l0aCB0aGUgc3VwcGxpZWQgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIEEgcGxhaW4gb2JqZWN0IGhhc2ggb2YgdmFsdWVzIHRvIHVwZGF0ZSBmb3IgdGhlIHdlYlxyXG4gICAgICovXHJcbiAgICBXZWIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcG9zdEJvZHkgPSBqc1MoZXh0ZW5kKHtcclxuICAgICAgICAgICAgXCJfX21ldGFkYXRhXCI6IHsgXCJ0eXBlXCI6IFwiU1AuV2ViXCIgfSxcclxuICAgICAgICB9LCBwcm9wZXJ0aWVzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBwb3N0Qm9keSxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgXCJYLUhUVFAtTWV0aG9kXCI6IFwiTUVSR0VcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgd2ViOiBfdGhpcyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhpcyB3ZWJcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRlbGV0ZUNvcmUuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIHRoZW1lIHNwZWNpZmllZCBieSB0aGUgY29udGVudHMgb2YgZWFjaCBvZiB0aGUgZmlsZXMgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudHMgdG8gdGhlIHNpdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sb3JQYWxldHRlVXJsIFRoZSBzZXJ2ZXItcmVsYXRpdmUgVVJMIG9mIHRoZSBjb2xvciBwYWxldHRlIGZpbGVcclxuICAgICAqIEBwYXJhbSBmb250U2NoZW1lVXJsIFRoZSBzZXJ2ZXItcmVsYXRpdmUgVVJMIG9mIHRoZSBmb250IHNjaGVtZVxyXG4gICAgICogQHBhcmFtIGJhY2tncm91bmRJbWFnZVVybCBUaGUgc2VydmVyLXJlbGF0aXZlIFVSTCBvZiB0aGUgYmFja2dyb3VuZCBpbWFnZVxyXG4gICAgICogQHBhcmFtIHNoYXJlR2VuZXJhdGVkIFdoZW4gdHJ1ZSwgdGhlIGdlbmVyYXRlZCB0aGVtZSBmaWxlcyBhcmUgc3RvcmVkIGluIHRoZSByb290IHNpdGUuIFdoZW4gZmFsc2UsIHRoZXkgYXJlIHN0b3JlZCBpbiB0aGlzIHdlYlxyXG4gICAgICovXHJcbiAgICBXZWIucHJvdG90eXBlLmFwcGx5VGhlbWUgPSBmdW5jdGlvbiAoY29sb3JQYWxldHRlVXJsLCBmb250U2NoZW1lVXJsLCBiYWNrZ3JvdW5kSW1hZ2VVcmwsIHNoYXJlR2VuZXJhdGVkKSB7XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlVXJsOiBiYWNrZ3JvdW5kSW1hZ2VVcmwsXHJcbiAgICAgICAgICAgIGNvbG9yUGFsZXR0ZVVybDogY29sb3JQYWxldHRlVXJsLFxyXG4gICAgICAgICAgICBmb250U2NoZW1lVXJsOiBmb250U2NoZW1lVXJsLFxyXG4gICAgICAgICAgICBzaGFyZUdlbmVyYXRlZDogc2hhcmVHZW5lcmF0ZWQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoV2ViXzEsIFwiYXBwbHl0aGVtZVwiKS5wb3N0Q29yZSh7IGJvZHk6IHBvc3RCb2R5IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgc3BlY2lmaWVkIHNpdGUgZGVmaW5pdGlvbiBvciBzaXRlIHRlbXBsYXRlIHRvIHRoZSBXZWIgc2l0ZSB0aGF0IGhhcyBubyB0ZW1wbGF0ZSBhcHBsaWVkIHRvIGl0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIE5hbWUgb2YgdGhlIHNpdGUgZGVmaW5pdGlvbiBvciB0aGUgbmFtZSBvZiB0aGUgc2l0ZSB0ZW1wbGF0ZVxyXG4gICAgICovXHJcbiAgICBXZWIucHJvdG90eXBlLmFwcGx5V2ViVGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICB2YXIgcSA9IHRoaXMuY2xvbmUoV2ViXzEsIFwiYXBwbHl3ZWJ0ZW1wbGF0ZVwiKTtcclxuICAgICAgICBxLmNvbmNhdChcIihAdClcIik7XHJcbiAgICAgICAgcS5xdWVyeS5zZXQoXCJAdFwiLCB0ZW1wbGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIHEucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgbG9naW4gbmFtZSBiZWxvbmdzIHRvIGEgdmFsaWQgdXNlciBpbiB0aGUgd2ViLiBJZiB0aGUgdXNlciBkb2Vzbid0IGV4aXN0LCBhZGRzIHRoZSB1c2VyIHRvIHRoZSB3ZWIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvZ2luTmFtZSBUaGUgbG9naW4gbmFtZSBvZiB0aGUgdXNlciAoZXg6IGk6MCMuZnxtZW1iZXJzaGlwfHVzZXJAZG9tYWluLm9ubWljcm9zb2Z0LmNvbSlcclxuICAgICAqL1xyXG4gICAgV2ViLnByb3RvdHlwZS5lbnN1cmVVc2VyID0gZnVuY3Rpb24gKGxvZ2luTmFtZSkge1xyXG4gICAgICAgIHZhciBwb3N0Qm9keSA9IGpzUyh7XHJcbiAgICAgICAgICAgIGxvZ29uTmFtZTogbG9naW5OYW1lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFdlYl8xLCBcImVuc3VyZXVzZXJcIikucG9zdENvcmUoeyBib2R5OiBwb3N0Qm9keSB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgdXNlcjogbmV3IFNpdGVVc2VyKG9kYXRhVXJsRnJvbShkYXRhKSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29sbGVjdGlvbiBvZiBzaXRlIHRlbXBsYXRlcyBhdmFpbGFibGUgZm9yIHRoZSBzaXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlIFRoZSBsb2NhbGUgaWQgb2YgdGhlIHNpdGUgdGVtcGxhdGVzIHRvIHJldHJpZXZlIChkZWZhdWx0ID0gMTAzMyBbRW5nbGlzaCwgVVNdKVxyXG4gICAgICogQHBhcmFtIGluY2x1ZGVDcm9zc0xhbmd1YWdlIFdoZW4gdHJ1ZSwgaW5jbHVkZXMgbGFuZ3VhZ2UtbmV1dHJhbCBzaXRlIHRlbXBsYXRlczsgb3RoZXJ3aXNlIGZhbHNlIChkZWZhdWx0ID0gdHJ1ZSlcclxuICAgICAqL1xyXG4gICAgV2ViLnByb3RvdHlwZS5hdmFpbGFibGVXZWJUZW1wbGF0ZXMgPSBmdW5jdGlvbiAobGFuZ3VhZ2UsIGluY2x1ZGVDcm9zc0xhbnVnYWdlKSB7XHJcbiAgICAgICAgaWYgKGxhbmd1YWdlID09PSB2b2lkIDApIHsgbGFuZ3VhZ2UgPSAxMDMzOyB9XHJcbiAgICAgICAgaWYgKGluY2x1ZGVDcm9zc0xhbnVnYWdlID09PSB2b2lkIDApIHsgaW5jbHVkZUNyb3NzTGFudWdhZ2UgPSB0cnVlOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbih0aGlzLCBcImdldGF2YWlsYWJsZXdlYnRlbXBsYXRlcyhsY2lkPVwiICsgbGFuZ3VhZ2UgKyBcIiwgZG9pbmNsdWRlY3Jvc3NsYW5ndWFnZT1cIiArIGluY2x1ZGVDcm9zc0xhbnVnYWdlICsgXCIpXCIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBnYWxsZXJ5IG9uIHRoZSBzaXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIGdhbGxlcnkgdHlwZSAtIFdlYlRlbXBsYXRlQ2F0YWxvZyA9IDExMSwgV2ViUGFydENhdGFsb2cgPSAxMTMgTGlzdFRlbXBsYXRlQ2F0YWxvZyA9IDExNCxcclxuICAgICAqIE1hc3RlclBhZ2VDYXRhbG9nID0gMTE2LCBTb2x1dGlvbkNhdGFsb2cgPSAxMjEsIFRoZW1lQ2F0YWxvZyA9IDEyMywgRGVzaWduQ2F0YWxvZyA9IDEyNCwgQXBwRGF0YUNhdGFsb2cgPSAxMjVcclxuICAgICAqL1xyXG4gICAgV2ViLnByb3RvdHlwZS5nZXRDYXRhbG9nID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShXZWJfMSwgXCJnZXRjYXRhbG9nKFwiICsgdHlwZSArIFwiKVwiKS5zZWxlY3QoXCJJZFwiKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdChvZGF0YVVybEZyb20oZGF0YSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBvZiBjaGFuZ2VzIGZyb20gdGhlIGNoYW5nZSBsb2cgdGhhdCBoYXZlIG9jY3VycmVkIHdpdGhpbiB0aGUgbGlzdCwgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBxdWVyeVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBxdWVyeSBUaGUgY2hhbmdlIHF1ZXJ5XHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUuZ2V0Q2hhbmdlcyA9IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgIHZhciBwb3N0Qm9keSA9IGpzUyh7IFwicXVlcnlcIjogZXh0ZW5kKHsgXCJfX21ldGFkYXRhXCI6IHsgXCJ0eXBlXCI6IFwiU1AuQ2hhbmdlUXVlcnlcIiB9IH0sIHF1ZXJ5KSB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShXZWJfMSwgXCJnZXRjaGFuZ2VzXCIpLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHkgfSk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYi5wcm90b3R5cGUsIFwiY3VzdG9tTGlzdFRlbXBsYXRlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBjdXN0b20gbGlzdCB0ZW1wbGF0ZXMgZm9yIHRoZSBzaXRlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbih0aGlzLCBcImdldGN1c3RvbWxpc3R0ZW1wbGF0ZXNcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHVzZXIgY29ycmVzcG9uZGluZyB0byB0aGUgc3BlY2lmaWVkIG1lbWJlciBpZGVudGlmaWVyIGZvciB0aGUgY3VycmVudCBzaXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgdXNlclxyXG4gICAgICovXHJcbiAgICBXZWIucHJvdG90eXBlLmdldFVzZXJCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaXRlVXNlcih0aGlzLCBcImdldFVzZXJCeUlkKFwiICsgaWQgKyBcIilcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBpbWFnZSBmaWxlIGZvciB0aGUgaWNvbiB0aGF0IGlzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBzcGVjaWZpZWQgZmlsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZSBuYW1lLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBlbXB0eSwgdGhlIHNlcnZlciByZXR1cm5zIGFuIGVtcHR5IHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHNpemUgVGhlIHNpemUgb2YgdGhlIGljb246IDE2eDE2IHBpeGVscyA9IDAsIDMyeDMyIHBpeGVscyA9IDEgKGRlZmF1bHQgPSAwKVxyXG4gICAgICogQHBhcmFtIHByb2dJZCBUaGUgUHJvZ0lEIG9mIHRoZSBhcHBsaWNhdGlvbiB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSB0aGUgZmlsZSwgaW4gdGhlIGZvcm0gT0xFU2VydmVyTmFtZS5PYmplY3ROYW1lXHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUubWFwVG9JY29uID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBzaXplLCBwcm9nSWQpIHtcclxuICAgICAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7IHNpemUgPSAwOyB9XHJcbiAgICAgICAgaWYgKHByb2dJZCA9PT0gdm9pZCAwKSB7IHByb2dJZCA9IFwiXCI7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShXZWJfMSwgXCJtYXB0b2ljb24oZmlsZW5hbWU9J1wiICsgZmlsZW5hbWUgKyBcIicsIHByb2dpZD0nXCIgKyBwcm9nSWQgKyBcIicsIHNpemU9XCIgKyBzaXplICsgXCIpXCIpLmdldCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdGVuYW50IHByb3BlcnR5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZCBrZXkgaW4gdGhlIGFwcCBjYXRhbG9nIHNpdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IElkIG9mIHN0b3JhZ2UgZW50aXR5IHRvIGJlIHNldFxyXG4gICAgICovXHJcbiAgICBXZWIucHJvdG90eXBlLmdldFN0b3JhZ2VFbnRpdHkgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoV2ViXzEsIFwiZ2V0U3RvcmFnZUVudGl0eSgnXCIgKyBrZXkgKyBcIicpXCIpLmdldCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyB3aWxsIHNldCB0aGUgc3RvcmFnZSBlbnRpdHkgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4ga2V5IChNVVNUIGJlIGNhbGxlZCBpbiB0aGUgY29udGV4dCBvZiB0aGUgYXBwIGNhdGFsb2cpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSBJZCBvZiBzdG9yYWdlIGVudGl0eSB0byBiZSBzZXRcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBvZiBzdG9yYWdlIGVudGl0eSB0byBiZSBzZXRcclxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBEZXNjcmlwdGlvbiBvZiBzdG9yYWdlIGVudGl0eSB0byBiZSBzZXRcclxuICAgICAqIEBwYXJhbSBjb21tZW50cyBDb21tZW50cyBvZiBzdG9yYWdlIGVudGl0eSB0byBiZSBzZXRcclxuICAgICAqL1xyXG4gICAgV2ViLnByb3RvdHlwZS5zZXRTdG9yYWdlRW50aXR5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGRlc2NyaXB0aW9uLCBjb21tZW50cykge1xyXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gdm9pZCAwKSB7IGRlc2NyaXB0aW9uID0gXCJcIjsgfVxyXG4gICAgICAgIGlmIChjb21tZW50cyA9PT0gdm9pZCAwKSB7IGNvbW1lbnRzID0gXCJcIjsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFdlYl8xLCBcInNldFN0b3JhZ2VFbnRpdHlcIikucG9zdENvcmUoe1xyXG4gICAgICAgICAgICBib2R5OiBqc1Moe1xyXG4gICAgICAgICAgICAgICAgY29tbWVudHM6IGNvbW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyB3aWxsIHJlbW92ZSB0aGUgc3RvcmFnZSBlbnRpdHkgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4ga2V5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSBJZCBvZiBzdG9yYWdlIGVudGl0eSB0byBiZSByZW1vdmVkXHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUucmVtb3ZlU3RvcmFnZUVudGl0eSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShXZWJfMSwgXCJyZW1vdmVTdG9yYWdlRW50aXR5KCdcIiArIGtleSArIFwiJylcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGFwcCBjYXRhbG9nIGZvciB0aGlzIHdlYlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmwgT3B0aW9uYWwgdXJsIG9yIHdlYiBjb250YWluaW5nIHRoZSBhcHAgY2F0YWxvZyAoZGVmYXVsdDogY3VycmVudCB3ZWIpXHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUuZ2V0QXBwQ2F0YWxvZyA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFwcENhdGFsb2codXJsIHx8IHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY29sbGVjdGlvbiBvZiBhdmFpbGFibGUgY2xpZW50IHNpZGUgd2ViIHBhcnRzIGZvciB0aGlzIHdlYiBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBXZWIucHJvdG90eXBlLmdldENsaWVudFNpZGVXZWJQYXJ0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTaGFyZVBvaW50UXVlcnlhYmxlQ29sbGVjdGlvbiwgXCJHZXRDbGllbnRTaWRlV2ViUGFydHNcIikuZ2V0KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNsaWVudCBzaWRlIHBhZ2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFnZU5hbWUgTmFtZSBvZiB0aGUgbmV3IHBhZ2VcclxuICAgICAqIEBwYXJhbSB0aXRsZSBEaXNwbGF5IHRpdGxlIG9mIHRoZSBuZXcgcGFnZVxyXG4gICAgICogQHBhcmFtIGxpYnJhcnlUaXRsZSBUaXRsZSBvZiB0aGUgbGlicmFyeSBpbiB3aGljaCB0byBjcmVhdGUgdGhlIG5ldyBwYWdlLiBEZWZhdWx0OiBcIlNpdGUgUGFnZXNcIlxyXG4gICAgICovXHJcbiAgICBXZWIucHJvdG90eXBlLmFkZENsaWVudFNpZGVQYWdlID0gZnVuY3Rpb24gKHBhZ2VOYW1lLCB0aXRsZSwgbGlicmFyeVRpdGxlKSB7XHJcbiAgICAgICAgaWYgKHRpdGxlID09PSB2b2lkIDApIHsgdGl0bGUgPSBwYWdlTmFtZS5yZXBsYWNlKC9cXC5bXi8uXSskLywgXCJcIik7IH1cclxuICAgICAgICBpZiAobGlicmFyeVRpdGxlID09PSB2b2lkIDApIHsgbGlicmFyeVRpdGxlID0gXCJTaXRlIFBhZ2VzXCI7IH1cclxuICAgICAgICByZXR1cm4gQ2xpZW50U2lkZVBhZ2UuY3JlYXRlKHRoaXMubGlzdHMuZ2V0QnlUaXRsZShsaWJyYXJ5VGl0bGUpLCBwYWdlTmFtZSwgdGl0bGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbGllbnQgc2lkZSBwYWdlIHVzaW5nIHRoZSBsaWJyYXJ5IHBhdGhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFnZU5hbWUgTmFtZSBvZiB0aGUgbmV3IHBhZ2VcclxuICAgICAqIEBwYXJhbSBsaXN0UmVsYXRpdmVQYXRoIFRoZSBzZXJ2ZXIgcmVsYXRpdmUgcGF0aCB0byB0aGUgbGlzdCdzIHJvb3QgZm9sZGVyIChpbmNsdWRpbmcgL3NpdGVzLyBpZiBhcHBsaWNhYmxlKVxyXG4gICAgICogQHBhcmFtIHRpdGxlIERpc3BsYXkgdGl0bGUgb2YgdGhlIG5ldyBwYWdlXHJcbiAgICAgKi9cclxuICAgIFdlYi5wcm90b3R5cGUuYWRkQ2xpZW50U2lkZVBhZ2VCeVBhdGggPSBmdW5jdGlvbiAocGFnZU5hbWUsIGxpc3RSZWxhdGl2ZVBhdGgsIHRpdGxlKSB7XHJcbiAgICAgICAgaWYgKHRpdGxlID09PSB2b2lkIDApIHsgdGl0bGUgPSBwYWdlTmFtZS5yZXBsYWNlKC9cXC5bXi8uXSskLywgXCJcIik7IH1cclxuICAgICAgICByZXR1cm4gQ2xpZW50U2lkZVBhZ2UuY3JlYXRlKHRoaXMuZ2V0TGlzdChsaXN0UmVsYXRpdmVQYXRoKSwgcGFnZU5hbWUsIHRpdGxlKTtcclxuICAgIH07XHJcbiAgICB2YXIgV2ViXzE7XHJcbiAgICBXZWIgPSBXZWJfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwiX2FwaS93ZWJcIilcclxuICAgIF0sIFdlYik7XHJcbiAgICByZXR1cm4gV2ViO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVXZWIpKTtcblxuLyoqXHJcbiAqIERlc2NyaWJlcyBhIHNpdGUgY29sbGVjdGlvblxyXG4gKlxyXG4gKi9cclxudmFyIFNpdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2l0ZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNpdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgU2l0ZV8xID0gU2l0ZTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaXRlLnByb3RvdHlwZSwgXCJyb290V2ViXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSByb290IHdlYiBvZiB0aGUgc2l0ZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWIodGhpcywgXCJyb290d2ViXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpdGUucHJvdG90eXBlLCBcImZlYXR1cmVzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBhY3RpdmUgZmVhdHVyZXMgZm9yIHRoaXMgc2l0ZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGZWF0dXJlcyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaXRlLnByb3RvdHlwZSwgXCJ1c2VyQ3VzdG9tQWN0aW9uc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbGwgY3VzdG9tIGFjdGlvbnMgZm9yIHRoaXMgc2l0ZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2VyQ3VzdG9tQWN0aW9ucyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIFdlYiBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIHJvb3Qgd2ViIG9mIHRoZSBzaXRlIGNvbGxlY3Rpb25cclxuICAgICAqIGNvcnJlY3RseSBzZXR1cCBmb3IgY2hhaW5pbmcgd2l0aGluIHRoZSBsaWJyYXJ5XHJcbiAgICAgKi9cclxuICAgIFNpdGUucHJvdG90eXBlLmdldFJvb3RXZWIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdFdlYi5zZWxlY3QoXCJVcmxcIikuZ2V0KCkudGhlbihmdW5jdGlvbiAod2ViKSB7IHJldHVybiBuZXcgV2ViKHdlYi5VcmwpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNvbnRleHQgaW5mb3JtYXRpb24gZm9yIHRoaXMgc2l0ZSBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIFNpdGUucHJvdG90eXBlLmdldENvbnRleHRJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBxID0gbmV3IFNpdGVfMSh0aGlzLnBhcmVudFVybCwgXCJfYXBpL2NvbnRleHRpbmZvXCIpO1xyXG4gICAgICAgIHJldHVybiBxLnBvc3RDb3JlKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoaE9QKGRhdGEsIFwiR2V0Q29udGV4dFdlYkluZm9ybWF0aW9uXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGRhdGEuR2V0Q29udGV4dFdlYkluZm9ybWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgaW5mby5TdXBwb3J0ZWRTY2hlbWFWZXJzaW9ucyA9IGluZm8uU3VwcG9ydGVkU2NoZW1hVmVyc2lvbnMucmVzdWx0cztcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRvY3VtZW50IGxpYnJhcmllcyBvbiBhIHNpdGUuIFN0YXRpYyBtZXRob2QuIChTaGFyZVBvaW50IE9ubGluZSBvbmx5KVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZVdlYlVybCBUaGUgYWJzb2x1dGUgdXJsIG9mIHRoZSB3ZWIgd2hvc2UgZG9jdW1lbnQgbGlicmFyaWVzIHNob3VsZCBiZSByZXR1cm5lZFxyXG4gICAgICovXHJcbiAgICBTaXRlLnByb3RvdHlwZS5nZXREb2N1bWVudExpYnJhcmllcyA9IGZ1bmN0aW9uIChhYnNvbHV0ZVdlYlVybCkge1xyXG4gICAgICAgIHZhciBxID0gbmV3IFNoYXJlUG9pbnRRdWVyeWFibGUoXCJcIiwgXCJfYXBpL3NwLndlYi5nZXRkb2N1bWVudGxpYnJhcmllcyhAdilcIik7XHJcbiAgICAgICAgcS5xdWVyeS5zZXQoXCJAdlwiLCBcIidcIiArIGFic29sdXRlV2ViVXJsICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiBxLmdldCgpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGhPUChkYXRhLCBcIkdldERvY3VtZW50TGlicmFyaWVzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5HZXREb2N1bWVudExpYnJhcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzaXRlIHVybCBmcm9tIGEgcGFnZSB1cmxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVQYWdlVXJsIFRoZSBhYnNvbHV0ZSB1cmwgb2YgdGhlIHBhZ2VcclxuICAgICAqL1xyXG4gICAgU2l0ZS5wcm90b3R5cGUuZ2V0V2ViVXJsRnJvbVBhZ2VVcmwgPSBmdW5jdGlvbiAoYWJzb2x1dGVQYWdlVXJsKSB7XHJcbiAgICAgICAgdmFyIHEgPSBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZShcIlwiLCBcIl9hcGkvc3Aud2ViLmdldHdlYnVybGZyb21wYWdldXJsKEB2KVwiKTtcclxuICAgICAgICBxLnF1ZXJ5LnNldChcIkB2XCIsIFwiJ1wiICsgYWJzb2x1dGVQYWdlVXJsICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiBxLmdldCgpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGhPUChkYXRhLCBcIkdldFdlYlVybEZyb21QYWdlVXJsXCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5HZXRXZWJVcmxGcm9tUGFnZVVybDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGJhdGNoIGZvciByZXF1ZXN0cyB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhpcyBzaXRlIGNvbGxlY3Rpb25cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFNpdGUucHJvdG90eXBlLmNyZWF0ZUJhdGNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU1BCYXRjaCh0aGlzLnBhcmVudFVybCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhIHdlYiBieSBpZCAodXNpbmcgUE9TVClcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2ViSWQgVGhlIEdVSUQgaWQgb2YgdGhlIHdlYiB0byBvcGVuXHJcbiAgICAgKi9cclxuICAgIFNpdGUucHJvdG90eXBlLm9wZW5XZWJCeUlkID0gZnVuY3Rpb24gKHdlYklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU2l0ZV8xLCBcIm9wZW5XZWJCeUlkKCdcIiArIHdlYklkICsgXCInKVwiKS5wb3N0Q29yZSgpLnRoZW4oZnVuY3Rpb24gKGQpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgIGRhdGE6IGQsXHJcbiAgICAgICAgICAgIHdlYjogV2ViLmZyb21VcmwoZFtcIm9kYXRhLmlkXCJdIHx8IGQuX19tZXRhZGF0YS51cmkpLFxyXG4gICAgICAgIH0pOyB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgU2l0ZV8xO1xyXG4gICAgU2l0ZSA9IFNpdGVfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwiX2FwaS9zaXRlXCIpXHJcbiAgICBdLCBTaXRlKTtcclxuICAgIHJldHVybiBTaXRlO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xuXG52YXIgVXNlclByb2ZpbGVRdWVyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhVc2VyUHJvZmlsZVF1ZXJ5LCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBVc2VyUHJvZmlsZVF1ZXJ5IGNsYXNzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJhc2VVcmwgVGhlIHVybCBvciBTaGFyZVBvaW50UXVlcnlhYmxlIHdoaWNoIGZvcm1zIHRoZSBwYXJlbnQgb2YgdGhpcyB1c2VyIHByb2ZpbGUgcXVlcnlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVXNlclByb2ZpbGVRdWVyeShiYXNlVXJsLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJfYXBpL3NwLnVzZXJwcm9maWxlcy5wZW9wbGVtYW5hZ2VyXCI7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBiYXNlVXJsLCBwYXRoKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNsaWVudFBlb3BsZVBpY2tlclF1ZXJ5ID0gKG5ldyBDbGllbnRQZW9wbGVQaWNrZXJRdWVyeShiYXNlVXJsKSkuY29uZmlndXJlRnJvbShfdGhpcyk7XHJcbiAgICAgICAgX3RoaXMucHJvZmlsZUxvYWRlciA9IChuZXcgUHJvZmlsZUxvYWRlcihiYXNlVXJsKSkuY29uZmlndXJlRnJvbShfdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLCBcImVkaXRQcm9maWxlTGlua1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVybCBvZiB0aGUgZWRpdCBwcm9maWxlIHBhZ2UgZm9yIHRoZSBjdXJyZW50IHVzZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoVXNlclByb2ZpbGVRdWVyeSwgXCJFZGl0UHJvZmlsZUxpbmtcIikuZ2V0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlclByb2ZpbGVRdWVyeS5wcm90b3R5cGUsIFwiaXNNeVBlb3BsZUxpc3RQdWJsaWNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVzZXIncyBcIlBlb3BsZSBJJ20gRm9sbG93aW5nXCIgbGlzdCBpcyBwdWJsaWNcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoVXNlclByb2ZpbGVRdWVyeSwgXCJJc015UGVvcGxlTGlzdFB1YmxpY1wiKS5nZXQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXNlciBpcyBiZWluZyBmb2xsb3dlZCBieSB0aGUgc3BlY2lmaWVkIHVzZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9naW5OYW1lIFRoZSBhY2NvdW50IG5hbWUgb2YgdGhlIHVzZXJcclxuICAgICAqL1xyXG4gICAgVXNlclByb2ZpbGVRdWVyeS5wcm90b3R5cGUuYW1JRm9sbG93ZWRCeSA9IGZ1bmN0aW9uIChsb2dpbk5hbWUpIHtcclxuICAgICAgICB2YXIgcSA9IHRoaXMuY2xvbmUoVXNlclByb2ZpbGVRdWVyeSwgXCJhbWlmb2xsb3dlZGJ5KEB2KVwiKTtcclxuICAgICAgICBxLnF1ZXJ5LnNldChcIkB2XCIsIFwiJ1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGxvZ2luTmFtZSkgKyBcIidcIik7XHJcbiAgICAgICAgcmV0dXJuIHEuZ2V0KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCB1c2VyIGlzIGZvbGxvd2luZyB0aGUgc3BlY2lmaWVkIHVzZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9naW5OYW1lIFRoZSBhY2NvdW50IG5hbWUgb2YgdGhlIHVzZXJcclxuICAgICAqL1xyXG4gICAgVXNlclByb2ZpbGVRdWVyeS5wcm90b3R5cGUuYW1JRm9sbG93aW5nID0gZnVuY3Rpb24gKGxvZ2luTmFtZSkge1xyXG4gICAgICAgIHZhciBxID0gdGhpcy5jbG9uZShVc2VyUHJvZmlsZVF1ZXJ5LCBcImFtaWZvbGxvd2luZyhAdilcIik7XHJcbiAgICAgICAgcS5xdWVyeS5zZXQoXCJAdlwiLCBcIidcIiArIGVuY29kZVVSSUNvbXBvbmVudChsb2dpbk5hbWUpICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiBxLmdldCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0YWdzIHRoYXQgdGhlIGN1cnJlbnQgdXNlciBpcyBmb2xsb3dpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIHRhZ3MgdG8gcmV0cmlldmUgKGRlZmF1bHQgaXMgMjApXHJcbiAgICAgKi9cclxuICAgIFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLmdldEZvbGxvd2VkVGFncyA9IGZ1bmN0aW9uIChtYXhDb3VudCkge1xyXG4gICAgICAgIGlmIChtYXhDb3VudCA9PT0gdm9pZCAwKSB7IG1heENvdW50ID0gMjA7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShVc2VyUHJvZmlsZVF1ZXJ5LCBcImdldGZvbGxvd2VkdGFncyhcIiArIG1heENvdW50ICsgXCIpXCIpLmdldCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcGVvcGxlIHdobyBhcmUgZm9sbG93aW5nIHRoZSBzcGVjaWZpZWQgdXNlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2dpbk5hbWUgVGhlIGFjY291bnQgbmFtZSBvZiB0aGUgdXNlclxyXG4gICAgICovXHJcbiAgICBVc2VyUHJvZmlsZVF1ZXJ5LnByb3RvdHlwZS5nZXRGb2xsb3dlcnNGb3IgPSBmdW5jdGlvbiAobG9naW5OYW1lKSB7XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLmNsb25lKFVzZXJQcm9maWxlUXVlcnksIFwiZ2V0Zm9sbG93ZXJzZm9yKEB2KVwiKTtcclxuICAgICAgICBxLnF1ZXJ5LnNldChcIkB2XCIsIFwiJ1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGxvZ2luTmFtZSkgKyBcIidcIik7XHJcbiAgICAgICAgcmV0dXJuIHEuZ2V0KCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLCBcIm15Rm9sbG93ZXJzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBwZW9wbGUgd2hvIGFyZSBmb2xsb3dpbmcgdGhlIGN1cnJlbnQgdXNlclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24odGhpcywgXCJnZXRteWZvbGxvd2Vyc1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyUHJvZmlsZVF1ZXJ5LnByb3RvdHlwZSwgXCJteVByb3BlcnRpZXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdXNlciBwcm9wZXJ0aWVzIGZvciB0aGUgY3VycmVudCB1c2VyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2VyUHJvZmlsZVF1ZXJ5KHRoaXMsIFwiZ2V0bXlwcm9wZXJ0aWVzXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwZW9wbGUgd2hvIHRoZSBzcGVjaWZpZWQgdXNlciBpcyBmb2xsb3dpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9naW5OYW1lIFRoZSBhY2NvdW50IG5hbWUgb2YgdGhlIHVzZXIuXHJcbiAgICAgKi9cclxuICAgIFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLmdldFBlb3BsZUZvbGxvd2VkQnkgPSBmdW5jdGlvbiAobG9naW5OYW1lKSB7XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLmNsb25lKFVzZXJQcm9maWxlUXVlcnksIFwiZ2V0cGVvcGxlZm9sbG93ZWRieShAdilcIik7XHJcbiAgICAgICAgcS5xdWVyeS5zZXQoXCJAdlwiLCBcIidcIiArIGVuY29kZVVSSUNvbXBvbmVudChsb2dpbk5hbWUpICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiBxLmdldCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB1c2VyIHByb3BlcnRpZXMgZm9yIHRoZSBzcGVjaWZpZWQgdXNlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9naW5OYW1lIFRoZSBhY2NvdW50IG5hbWUgb2YgdGhlIHVzZXIuXHJcbiAgICAgKi9cclxuICAgIFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLmdldFByb3BlcnRpZXNGb3IgPSBmdW5jdGlvbiAobG9naW5OYW1lKSB7XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLmNsb25lKFVzZXJQcm9maWxlUXVlcnksIFwiZ2V0cHJvcGVydGllc2ZvcihAdilcIik7XHJcbiAgICAgICAgcS5xdWVyeS5zZXQoXCJAdlwiLCBcIidcIiArIGVuY29kZVVSSUNvbXBvbmVudChsb2dpbk5hbWUpICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiBxLmdldCgpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyUHJvZmlsZVF1ZXJ5LnByb3RvdHlwZSwgXCJ0cmVuZGluZ1RhZ3NcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIDIwIG1vc3QgcG9wdWxhciBoYXNoIHRhZ3Mgb3ZlciB0aGUgcGFzdCB3ZWVrLCBzb3J0ZWQgc28gdGhhdCB0aGUgbW9zdCBwb3B1bGFyIHRhZyBhcHBlYXJzIGZpcnN0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLmNsb25lKFVzZXJQcm9maWxlUXVlcnksIG51bGwpO1xyXG4gICAgICAgICAgICBxLmNvbmNhdChcIi5nZXR0cmVuZGluZ3RhZ3NcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBxLmdldCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzcGVjaWZpZWQgdXNlciBwcm9maWxlIHByb3BlcnR5IGZvciB0aGUgc3BlY2lmaWVkIHVzZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9naW5OYW1lIFRoZSBhY2NvdW50IG5hbWUgb2YgdGhlIHVzZXJcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgVGhlIGNhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldFxyXG4gICAgICovXHJcbiAgICBVc2VyUHJvZmlsZVF1ZXJ5LnByb3RvdHlwZS5nZXRVc2VyUHJvZmlsZVByb3BlcnR5Rm9yID0gZnVuY3Rpb24gKGxvZ2luTmFtZSwgcHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLmNsb25lKFVzZXJQcm9maWxlUXVlcnksIFwiZ2V0dXNlcnByb2ZpbGVwcm9wZXJ0eWZvcihhY2NvdW50bmFtZT1AdiwgcHJvcGVydHluYW1lPSdcIiArIHByb3BlcnR5TmFtZSArIFwiJylcIik7XHJcbiAgICAgICAgcS5xdWVyeS5zZXQoXCJAdlwiLCBcIidcIiArIGVuY29kZVVSSUNvbXBvbmVudChsb2dpbk5hbWUpICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiBxLmdldCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIHVzZXIgZnJvbSB0aGUgdXNlcidzIGxpc3Qgb2Ygc3VnZ2VzdGVkIHBlb3BsZSB0byBmb2xsb3dcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9naW5OYW1lIFRoZSBhY2NvdW50IG5hbWUgb2YgdGhlIHVzZXJcclxuICAgICAqL1xyXG4gICAgVXNlclByb2ZpbGVRdWVyeS5wcm90b3R5cGUuaGlkZVN1Z2dlc3Rpb24gPSBmdW5jdGlvbiAobG9naW5OYW1lKSB7XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLmNsb25lKFVzZXJQcm9maWxlUXVlcnksIFwiaGlkZXN1Z2dlc3Rpb24oQHYpXCIpO1xyXG4gICAgICAgIHEucXVlcnkuc2V0KFwiQHZcIiwgXCInXCIgKyBlbmNvZGVVUklDb21wb25lbnQobG9naW5OYW1lKSArIFwiJ1wiKTtcclxuICAgICAgICByZXR1cm4gcS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQSBib29sZWFuIHZhbHVlcyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBmaXJzdCB1c2VyIGlzIGZvbGxvd2luZyB0aGUgc2Vjb25kIHVzZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm9sbG93ZXIgVGhlIGFjY291bnQgbmFtZSBvZiB0aGUgdXNlciB3aG8gbWlnaHQgYmUgZm9sbG93aW5nIHRoZSBmb2xsb3dlZVxyXG4gICAgICogQHBhcmFtIGZvbGxvd2VlIFRoZSBhY2NvdW50IG5hbWUgb2YgdGhlIHVzZXIgd2hvIG1pZ2h0IGJlIGZvbGxvd2VkIGJ5IHRoZSBmb2xsb3dlclxyXG4gICAgICovXHJcbiAgICBVc2VyUHJvZmlsZVF1ZXJ5LnByb3RvdHlwZS5pc0ZvbGxvd2luZyA9IGZ1bmN0aW9uIChmb2xsb3dlciwgZm9sbG93ZWUpIHtcclxuICAgICAgICB2YXIgcSA9IHRoaXMuY2xvbmUoVXNlclByb2ZpbGVRdWVyeSwgbnVsbCk7XHJcbiAgICAgICAgcS5jb25jYXQoXCIuaXNmb2xsb3dpbmcocG9zc2libGVmb2xsb3dlcmFjY291bnRuYW1lPUB2LCBwb3NzaWJsZWZvbGxvd2VlYWNjb3VudG5hbWU9QHkpXCIpO1xyXG4gICAgICAgIHEucXVlcnkuc2V0KFwiQHZcIiwgXCInXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZm9sbG93ZXIpICsgXCInXCIpO1xyXG4gICAgICAgIHEucXVlcnkuc2V0KFwiQHlcIiwgXCInXCIgKyBlbmNvZGVVUklDb21wb25lbnQoZm9sbG93ZWUpICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiBxLmdldCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyBhbmQgc2V0cyB0aGUgdXNlciBwcm9maWxlIHBpY3R1cmUgKFVzZXJzIGNhbiB1cGxvYWQgYSBwaWN0dXJlIHRvIHRoZWlyIG93biBwcm9maWxlIG9ubHkpLiBOb3Qgc3VwcG9ydGVkIGZvciBiYXRjaGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvZmlsZVBpY1NvdXJjZSBCbG9iIGRhdGEgcmVwcmVzZW50aW5nIHRoZSB1c2VyJ3MgcGljdHVyZSBpbiBCTVAsIEpQRUcsIG9yIFBORyBmb3JtYXQgb2YgdXAgdG8gNC43Nk1CXHJcbiAgICAgKi9cclxuICAgIFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLnNldE15UHJvZmlsZVBpYyA9IGZ1bmN0aW9uIChwcm9maWxlUGljU291cmNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gYnVmZmVyID0gZS50YXJnZXQucmVzdWx0OyB9O1xyXG4gICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocHJvZmlsZVBpY1NvdXJjZSk7XHJcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFVzZXJQcm9maWxlUXVlcnkoX3RoaXMsIFwic2V0bXlwcm9maWxlcGljdHVyZVwiKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgICAgICBib2R5OiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShidWZmZXIpKSxcclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gcmVzb2x2ZSgpOyB9KS5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gcmVqZWN0KGUpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc2luZ2xlIHZhbHVlIFVzZXIgUHJvZmlsZSBwcm9wZXJ0eVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY2NvdW50TmFtZSBUaGUgYWNjb3VudCBuYW1lIG9mIHRoZSB1c2VyXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWVcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eVZhbHVlIFByb3BlcnR5IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLnNldFNpbmdsZVZhbHVlUHJvZmlsZVByb3BlcnR5ID0gZnVuY3Rpb24gKGFjY291bnROYW1lLCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpIHtcclxuICAgICAgICB2YXIgcG9zdEJvZHkgPSBqc1Moe1xyXG4gICAgICAgICAgICBhY2NvdW50TmFtZTogYWNjb3VudE5hbWUsXHJcbiAgICAgICAgICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxyXG4gICAgICAgICAgICBwcm9wZXJ0eVZhbHVlOiBwcm9wZXJ0eVZhbHVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFVzZXJQcm9maWxlUXVlcnksIFwiU2V0U2luZ2xlVmFsdWVQcm9maWxlUHJvcGVydHlcIilcclxuICAgICAgICAgICAgLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHkgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG11bHRpIHZhbHVlZCBVc2VyIFByb2ZpbGUgcHJvcGVydHlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWNjb3VudE5hbWUgVGhlIGFjY291bnQgbmFtZSBvZiB0aGUgdXNlclxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlWYWx1ZXMgUHJvcGVydHkgdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLnNldE11bHRpVmFsdWVkUHJvZmlsZVByb3BlcnR5ID0gZnVuY3Rpb24gKGFjY291bnROYW1lLCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIHBvc3RCb2R5ID0ganNTKHtcclxuICAgICAgICAgICAgYWNjb3VudE5hbWU6IGFjY291bnROYW1lLFxyXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcclxuICAgICAgICAgICAgcHJvcGVydHlWYWx1ZXM6IHByb3BlcnR5VmFsdWVzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFVzZXJQcm9maWxlUXVlcnksIFwiU2V0TXVsdGlWYWx1ZWRQcm9maWxlUHJvcGVydHlcIilcclxuICAgICAgICAgICAgLnBvc3RDb3JlKHsgYm9keTogcG9zdEJvZHkgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aXNpb25zIG9uZSBvciBtb3JlIHVzZXJzJyBwZXJzb25hbCBzaXRlcy4gKE15IFNpdGUgYWRtaW5pc3RyYXRvciBvbiBTaGFyZVBvaW50IE9ubGluZSBvbmx5KVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbWFpbHMgVGhlIGVtYWlsIGFkZHJlc3NlcyBvZiB0aGUgdXNlcnMgdG8gcHJvdmlzaW9uIHNpdGVzIGZvclxyXG4gICAgICovXHJcbiAgICBVc2VyUHJvZmlsZVF1ZXJ5LnByb3RvdHlwZS5jcmVhdGVQZXJzb25hbFNpdGVFbnF1ZXVlQnVsayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZW1haWxzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgZW1haWxzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2ZpbGVMb2FkZXIuY3JlYXRlUGVyc29uYWxTaXRlRW5xdWV1ZUJ1bGsoZW1haWxzKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlclByb2ZpbGVRdWVyeS5wcm90b3R5cGUsIFwib3duZXJVc2VyUHJvZmlsZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdXNlciBwcm9maWxlIG9mIHRoZSBzaXRlIG93bmVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvZmlsZUxvYWRlci5vd25lclVzZXJQcm9maWxlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLCBcInVzZXJQcm9maWxlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB1c2VyIHByb2ZpbGUgZm9yIHRoZSBjdXJyZW50IHVzZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvZmlsZUxvYWRlci51c2VyUHJvZmlsZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgY3JlYXRpbmcgYSBwZXJzb25hbCBzaXRlIGZvciB0aGlzIHVzZXIsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHNoYXJlIGRvY3VtZW50cywgd2ViIHBhZ2VzLCBhbmQgb3RoZXIgZmlsZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW50ZXJhY3RpdmVSZXF1ZXN0IHRydWUgaWYgaW50ZXJhY3RpdmVseSAod2ViKSBpbml0aWF0ZWQgcmVxdWVzdCwgb3IgZmFsc2UgKGRlZmF1bHQpIGlmIG5vbi1pbnRlcmFjdGl2ZWx5IChjbGllbnQpIGluaXRpYXRlZCByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLmNyZWF0ZVBlcnNvbmFsU2l0ZSA9IGZ1bmN0aW9uIChpbnRlcmFjdGl2ZVJlcXVlc3QpIHtcclxuICAgICAgICBpZiAoaW50ZXJhY3RpdmVSZXF1ZXN0ID09PSB2b2lkIDApIHsgaW50ZXJhY3RpdmVSZXF1ZXN0ID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9maWxlTG9hZGVyLmNyZWF0ZVBlcnNvbmFsU2l0ZShpbnRlcmFjdGl2ZVJlcXVlc3QpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcHJpdmFjeSBzZXR0aW5ncyBmb3IgdGhpcyBwcm9maWxlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNoYXJlIHRydWUgdG8gbWFrZSBhbGwgc29jaWFsIGRhdGEgcHVibGljOyBmYWxzZSB0byBtYWtlIGFsbCBzb2NpYWwgZGF0YSBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIFVzZXJQcm9maWxlUXVlcnkucHJvdG90eXBlLnNoYXJlQWxsU29jaWFsRGF0YSA9IGZ1bmN0aW9uIChzaGFyZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2ZpbGVMb2FkZXIuc2hhcmVBbGxTb2NpYWxEYXRhKHNoYXJlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIHVzZXIgb3IgZ3JvdXAgdXNpbmcgc3BlY2lmaWVkIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcXVlcnlQYXJhbXMgVGhlIHF1ZXJ5IHBhcmFtZXRlcnMgdXNlZCB0byBwZXJmb3JtIHJlc29sdmVcclxuICAgICAqL1xyXG4gICAgVXNlclByb2ZpbGVRdWVyeS5wcm90b3R5cGUuY2xpZW50UGVvcGxlUGlja2VyUmVzb2x2ZVVzZXIgPSBmdW5jdGlvbiAocXVlcnlQYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRQZW9wbGVQaWNrZXJRdWVyeS5jbGllbnRQZW9wbGVQaWNrZXJSZXNvbHZlVXNlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2hlcyBmb3IgdXNlcnMgb3IgZ3JvdXBzIHVzaW5nIHNwZWNpZmllZCBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5UGFyYW1zIFRoZSBxdWVyeSBwYXJhbWV0ZXJzIHVzZWQgdG8gcGVyZm9ybSBzZWFyY2hcclxuICAgICAqL1xyXG4gICAgVXNlclByb2ZpbGVRdWVyeS5wcm90b3R5cGUuY2xpZW50UGVvcGxlUGlja2VyU2VhcmNoVXNlciA9IGZ1bmN0aW9uIChxdWVyeVBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFBlb3BsZVBpY2tlclF1ZXJ5LmNsaWVudFBlb3BsZVBpY2tlclNlYXJjaFVzZXIocXVlcnlQYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBVc2VyUHJvZmlsZVF1ZXJ5O1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSkpO1xyXG52YXIgUHJvZmlsZUxvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQcm9maWxlTG9hZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUHJvZmlsZUxvYWRlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQcm9maWxlTG9hZGVyXzEgPSBQcm9maWxlTG9hZGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aXNpb25zIG9uZSBvciBtb3JlIHVzZXJzJyBwZXJzb25hbCBzaXRlcy4gKE15IFNpdGUgYWRtaW5pc3RyYXRvciBvbiBTaGFyZVBvaW50IE9ubGluZSBvbmx5KSBEb2Vzbid0IHN1cHBvcnQgYmF0Y2hpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW1haWxzIFRoZSBlbWFpbCBhZGRyZXNzZXMgb2YgdGhlIHVzZXJzIHRvIHByb3Zpc2lvbiBzaXRlcyBmb3JcclxuICAgICAqL1xyXG4gICAgUHJvZmlsZUxvYWRlci5wcm90b3R5cGUuY3JlYXRlUGVyc29uYWxTaXRlRW5xdWV1ZUJ1bGsgPSBmdW5jdGlvbiAoZW1haWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoUHJvZmlsZUxvYWRlcl8xLCBcImNyZWF0ZXBlcnNvbmFsc2l0ZWVucXVldWVidWxrXCIsIGZhbHNlKS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IGpzUyh7IFwiZW1haWxJRHNcIjogZW1haWxzIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9maWxlTG9hZGVyLnByb3RvdHlwZSwgXCJvd25lclVzZXJQcm9maWxlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB1c2VyIHByb2ZpbGUgb2YgdGhlIHNpdGUgb3duZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLmdldFBhcmVudChQcm9maWxlTG9hZGVyXzEsIHRoaXMucGFyZW50VXJsLCBcIl9hcGkvc3AudXNlcnByb2ZpbGVzLnByb2ZpbGVsb2FkZXIuZ2V0b3duZXJ1c2VycHJvZmlsZVwiKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQmF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHEgPSBxLmluQmF0Y2godGhpcy5iYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHEucG9zdENvcmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9maWxlTG9hZGVyLnByb3RvdHlwZSwgXCJ1c2VyUHJvZmlsZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgdXNlciBwcm9maWxlIG9mIHRoZSBjdXJyZW50IHVzZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoUHJvZmlsZUxvYWRlcl8xLCBcImdldHVzZXJwcm9maWxlXCIpLnBvc3RDb3JlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEVucXVldWVzIGNyZWF0aW5nIGEgcGVyc29uYWwgc2l0ZSBmb3IgdGhpcyB1c2VyLCB3aGljaCBjYW4gYmUgdXNlZCB0byBzaGFyZSBkb2N1bWVudHMsIHdlYiBwYWdlcywgYW5kIG90aGVyIGZpbGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGl2ZVJlcXVlc3QgdHJ1ZSBpZiBpbnRlcmFjdGl2ZWx5ICh3ZWIpIGluaXRpYXRlZCByZXF1ZXN0LCBvciBmYWxzZSAoZGVmYXVsdCkgaWYgbm9uLWludGVyYWN0aXZlbHkgKGNsaWVudCkgaW5pdGlhdGVkIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgUHJvZmlsZUxvYWRlci5wcm90b3R5cGUuY3JlYXRlUGVyc29uYWxTaXRlID0gZnVuY3Rpb24gKGludGVyYWN0aXZlUmVxdWVzdCkge1xyXG4gICAgICAgIGlmIChpbnRlcmFjdGl2ZVJlcXVlc3QgPT09IHZvaWQgMCkgeyBpbnRlcmFjdGl2ZVJlcXVlc3QgPSBmYWxzZTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFByb2ZpbGVMb2FkZXJfMSwgXCJnZXR1c2VycHJvZmlsZS9jcmVhdGVwZXJzb25hbHNpdGVlbnF1ZShcIiArIGludGVyYWN0aXZlUmVxdWVzdCArIFwiKVwiKS5wb3N0Q29yZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcHJpdmFjeSBzZXR0aW5ncyBmb3IgdGhpcyBwcm9maWxlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNoYXJlIHRydWUgdG8gbWFrZSBhbGwgc29jaWFsIGRhdGEgcHVibGljOyBmYWxzZSB0byBtYWtlIGFsbCBzb2NpYWwgZGF0YSBwcml2YXRlLlxyXG4gICAgICovXHJcbiAgICBQcm9maWxlTG9hZGVyLnByb3RvdHlwZS5zaGFyZUFsbFNvY2lhbERhdGEgPSBmdW5jdGlvbiAoc2hhcmUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShQcm9maWxlTG9hZGVyXzEsIFwiZ2V0dXNlcnByb2ZpbGUvc2hhcmVhbGxzb2NpYWxkYXRhKFwiICsgc2hhcmUgKyBcIilcIikucG9zdENvcmUoKTtcclxuICAgIH07XHJcbiAgICB2YXIgUHJvZmlsZUxvYWRlcl8xO1xyXG4gICAgUHJvZmlsZUxvYWRlciA9IFByb2ZpbGVMb2FkZXJfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwiX2FwaS9zcC51c2VycHJvZmlsZXMucHJvZmlsZWxvYWRlci5nZXRwcm9maWxlbG9hZGVyXCIpXHJcbiAgICBdLCBQcm9maWxlTG9hZGVyKTtcclxuICAgIHJldHVybiBQcm9maWxlTG9hZGVyO1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGUpKTtcclxudmFyIENsaWVudFBlb3BsZVBpY2tlclF1ZXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENsaWVudFBlb3BsZVBpY2tlclF1ZXJ5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ2xpZW50UGVvcGxlUGlja2VyUXVlcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQ2xpZW50UGVvcGxlUGlja2VyUXVlcnlfMSA9IENsaWVudFBlb3BsZVBpY2tlclF1ZXJ5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNvbHZlcyB1c2VyIG9yIGdyb3VwIHVzaW5nIHNwZWNpZmllZCBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5UGFyYW1zIFRoZSBxdWVyeSBwYXJhbWV0ZXJzIHVzZWQgdG8gcGVyZm9ybSByZXNvbHZlXHJcbiAgICAgKi9cclxuICAgIENsaWVudFBlb3BsZVBpY2tlclF1ZXJ5LnByb3RvdHlwZS5jbGllbnRQZW9wbGVQaWNrZXJSZXNvbHZlVXNlciA9IGZ1bmN0aW9uIChxdWVyeVBhcmFtcykge1xyXG4gICAgICAgIHZhciBxID0gdGhpcy5jbG9uZShDbGllbnRQZW9wbGVQaWNrZXJRdWVyeV8xLCBudWxsKTtcclxuICAgICAgICBxLmNvbmNhdChcIi5jbGllbnRwZW9wbGVwaWNrZXJyZXNvbHZldXNlclwiKTtcclxuICAgICAgICByZXR1cm4gcS5wb3N0Q29yZSh7XHJcbiAgICAgICAgICAgIGJvZHk6IHRoaXMuY3JlYXRlQ2xpZW50UGVvcGxlUGlja2VyUXVlcnlQYXJhbWV0ZXJzUmVxdWVzdEJvZHkocXVlcnlQYXJhbXMpLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuQ2xpZW50UGVvcGxlUGlja2VyUmVzb2x2ZVVzZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihKU09OLnBhcnNlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaGVzIGZvciB1c2VycyBvciBncm91cHMgdXNpbmcgc3BlY2lmaWVkIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcXVlcnlQYXJhbXMgVGhlIHF1ZXJ5IHBhcmFtZXRlcnMgdXNlZCB0byBwZXJmb3JtIHNlYXJjaFxyXG4gICAgICovXHJcbiAgICBDbGllbnRQZW9wbGVQaWNrZXJRdWVyeS5wcm90b3R5cGUuY2xpZW50UGVvcGxlUGlja2VyU2VhcmNoVXNlciA9IGZ1bmN0aW9uIChxdWVyeVBhcmFtcykge1xyXG4gICAgICAgIHZhciBxID0gdGhpcy5jbG9uZShDbGllbnRQZW9wbGVQaWNrZXJRdWVyeV8xLCBudWxsKTtcclxuICAgICAgICBxLmNvbmNhdChcIi5jbGllbnRwZW9wbGVwaWNrZXJzZWFyY2h1c2VyXCIpO1xyXG4gICAgICAgIHJldHVybiBxLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keTogdGhpcy5jcmVhdGVDbGllbnRQZW9wbGVQaWNrZXJRdWVyeVBhcmFtZXRlcnNSZXF1ZXN0Qm9keShxdWVyeVBhcmFtcyksXHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5DbGllbnRQZW9wbGVQaWNrZXJTZWFyY2hVc2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oSlNPTi5wYXJzZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIENsaWVudFBlb3BsZVBpY2tlclF1ZXJ5UGFyYW1ldGVycyByZXF1ZXN0IGJvZHlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcXVlcnlQYXJhbXMgVGhlIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gY3JlYXRlIHJlcXVlc3QgYm9keVxyXG4gICAgICovXHJcbiAgICBDbGllbnRQZW9wbGVQaWNrZXJRdWVyeS5wcm90b3R5cGUuY3JlYXRlQ2xpZW50UGVvcGxlUGlja2VyUXVlcnlQYXJhbWV0ZXJzUmVxdWVzdEJvZHkgPSBmdW5jdGlvbiAocXVlcnlQYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4ganNTKHtcclxuICAgICAgICAgICAgXCJxdWVyeVBhcmFtc1wiOiBleHRlbmQobWV0YWRhdGEoXCJTUC5VSS5BcHBsaWNhdGlvblBhZ2VzLkNsaWVudFBlb3BsZVBpY2tlclF1ZXJ5UGFyYW1ldGVyc1wiKSwgcXVlcnlQYXJhbXMpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBDbGllbnRQZW9wbGVQaWNrZXJRdWVyeV8xO1xyXG4gICAgQ2xpZW50UGVvcGxlUGlja2VyUXVlcnkgPSBDbGllbnRQZW9wbGVQaWNrZXJRdWVyeV8xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgZGVmYXVsdFBhdGgoXCJfYXBpL3NwLnVpLmFwcGxpY2F0aW9ucGFnZXMuY2xpZW50cGVvcGxlcGlja2Vyd2Vic2VydmljZWludGVyZmFjZVwiKVxyXG4gICAgXSwgQ2xpZW50UGVvcGxlUGlja2VyUXVlcnkpO1xyXG4gICAgcmV0dXJuIENsaWVudFBlb3BsZVBpY2tlclF1ZXJ5O1xyXG59KFNoYXJlUG9pbnRRdWVyeWFibGUpKTtcblxuLyoqXHJcbiAqIEV4cG9zZXMgc29jaWFsIGZvbGxvd2luZyBtZXRob2RzXHJcbiAqL1xyXG52YXIgU29jaWFsUXVlcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU29jaWFsUXVlcnksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTb2NpYWxRdWVyeSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBTb2NpYWxRdWVyeV8xID0gU29jaWFsUXVlcnk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU29jaWFsUXVlcnkucHJvdG90eXBlLCBcIm15XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNeVNvY2lhbFF1ZXJ5KHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgVVJJIHRvIGEgc2l0ZSB0aGF0IGxpc3RzIHRoZSBjdXJyZW50IHVzZXIncyBmb2xsb3dlZCBzaXRlcy5cclxuICAgICAqL1xyXG4gICAgU29jaWFsUXVlcnkucHJvdG90eXBlLmdldEZvbGxvd2VkU2l0ZXNVcmkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU29jaWFsUXVlcnlfMSwgXCJGb2xsb3dlZFNpdGVzVXJpXCIpLmdldCgpLnRoZW4oZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHIuRm9sbG93ZWRTaXRlc1VyaSB8fCByO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIFVSSSB0byBhIHNpdGUgdGhhdCBsaXN0cyB0aGUgY3VycmVudCB1c2VyJ3MgZm9sbG93ZWQgZG9jdW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBTb2NpYWxRdWVyeS5wcm90b3R5cGUuZ2V0Rm9sbG93ZWREb2N1bWVudHNVcmkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoU29jaWFsUXVlcnlfMSwgXCJGb2xsb3dlZERvY3VtZW50c1VyaVwiKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByLkZvbGxvd2VkRG9jdW1lbnRzVXJpIHx8IHI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyB0aGUgY3VycmVudCB1c2VyIHN0YXJ0IGZvbGxvd2luZyBhIHVzZXIsIGRvY3VtZW50LCBzaXRlLCBvciB0YWdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0b3JJbmZvIFRoZSBhY3RvciB0byBzdGFydCBmb2xsb3dpbmdcclxuICAgICAqL1xyXG4gICAgU29jaWFsUXVlcnkucHJvdG90eXBlLmZvbGxvdyA9IGZ1bmN0aW9uIChhY3RvckluZm8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTb2NpYWxRdWVyeV8xLCBcImZvbGxvd1wiKS5wb3N0Q29yZSh7IGJvZHk6IHRoaXMuY3JlYXRlU29jaWFsQWN0b3JJbmZvUmVxdWVzdEJvZHkoYWN0b3JJbmZvKSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVzZXIgaXMgZm9sbG93aW5nIGEgc3BlY2lmaWVkIHVzZXIsIGRvY3VtZW50LCBzaXRlLCBvciB0YWdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0b3JJbmZvIFRoZSBhY3RvciB0byBmaW5kIHRoZSBmb2xsb3dpbmcgc3RhdHVzIGZvclxyXG4gICAgICovXHJcbiAgICBTb2NpYWxRdWVyeS5wcm90b3R5cGUuaXNGb2xsb3dlZCA9IGZ1bmN0aW9uIChhY3RvckluZm8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShTb2NpYWxRdWVyeV8xLCBcImlzZm9sbG93ZWRcIikucG9zdENvcmUoeyBib2R5OiB0aGlzLmNyZWF0ZVNvY2lhbEFjdG9ySW5mb1JlcXVlc3RCb2R5KGFjdG9ySW5mbykgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyB0aGUgY3VycmVudCB1c2VyIHN0b3AgZm9sbG93aW5nIGEgdXNlciwgZG9jdW1lbnQsIHNpdGUsIG9yIHRhZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3RvckluZm8gVGhlIGFjdG9yIHRvIHN0b3AgZm9sbG93aW5nXHJcbiAgICAgKi9cclxuICAgIFNvY2lhbFF1ZXJ5LnByb3RvdHlwZS5zdG9wRm9sbG93aW5nID0gZnVuY3Rpb24gKGFjdG9ySW5mbykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFNvY2lhbFF1ZXJ5XzEsIFwic3RvcGZvbGxvd2luZ1wiKS5wb3N0Q29yZSh7IGJvZHk6IHRoaXMuY3JlYXRlU29jaWFsQWN0b3JJbmZvUmVxdWVzdEJvZHkoYWN0b3JJbmZvKSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgU29jaWFsQWN0b3JJbmZvIHJlcXVlc3QgYm9keVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3RvckluZm8gVGhlIGFjdG9yIHRvIGNyZWF0ZSByZXF1ZXN0IGJvZHlcclxuICAgICAqL1xyXG4gICAgU29jaWFsUXVlcnkucHJvdG90eXBlLmNyZWF0ZVNvY2lhbEFjdG9ySW5mb1JlcXVlc3RCb2R5ID0gZnVuY3Rpb24gKGFjdG9ySW5mbykge1xyXG4gICAgICAgIHJldHVybiBqc1Moe1xyXG4gICAgICAgICAgICBcImFjdG9yXCI6IE9iamVjdC5hc3NpZ24obWV0YWRhdGEoXCJTUC5Tb2NpYWwuU29jaWFsQWN0b3JJbmZvXCIpLCB7XHJcbiAgICAgICAgICAgICAgICBJZDogbnVsbCxcclxuICAgICAgICAgICAgfSwgYWN0b3JJbmZvKSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgU29jaWFsUXVlcnlfMTtcclxuICAgIFNvY2lhbFF1ZXJ5ID0gU29jaWFsUXVlcnlfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwiX2FwaS9zb2NpYWwuZm9sbG93aW5nXCIpXHJcbiAgICBdLCBTb2NpYWxRdWVyeSk7XHJcbiAgICByZXR1cm4gU29jaWFsUXVlcnk7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XHJcbnZhciBNeVNvY2lhbFF1ZXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE15U29jaWFsUXVlcnksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNeVNvY2lhbFF1ZXJ5KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIE15U29jaWFsUXVlcnlfMSA9IE15U29jaWFsUXVlcnk7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdXNlcnMsIGRvY3VtZW50cywgc2l0ZXMsIGFuZCB0YWdzIHRoYXQgdGhlIGN1cnJlbnQgdXNlciBpcyBmb2xsb3dpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHR5cGVzIEJpdHdpc2Ugc2V0IG9mIFNvY2lhbEFjdG9yVHlwZXMgdG8gcmV0cmlldmVcclxuICAgICAqL1xyXG4gICAgTXlTb2NpYWxRdWVyeS5wcm90b3R5cGUuZm9sbG93ZWQgPSBmdW5jdGlvbiAodHlwZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShNeVNvY2lhbFF1ZXJ5XzEsIFwiZm9sbG93ZWQodHlwZXM9XCIgKyB0eXBlcyArIFwiKVwiKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoT1AociwgXCJGb2xsb3dlZFwiKSA/IHIuRm9sbG93ZWQucmVzdWx0cyA6IHI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjb3VudCBvZiB1c2VycywgZG9jdW1lbnRzLCBzaXRlcywgYW5kIHRhZ3MgdGhhdCB0aGUgY3VycmVudCB1c2VyIGlzIGZvbGxvd2luZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHlwZXMgQml0d2lzZSBzZXQgb2YgU29jaWFsQWN0b3JUeXBlcyB0byByZXRyaWV2ZVxyXG4gICAgICovXHJcbiAgICBNeVNvY2lhbFF1ZXJ5LnByb3RvdHlwZS5mb2xsb3dlZENvdW50ID0gZnVuY3Rpb24gKHR5cGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoTXlTb2NpYWxRdWVyeV8xLCBcImZvbGxvd2VkY291bnQodHlwZXM9XCIgKyB0eXBlcyArIFwiKVwiKS5nZXQoKS50aGVuKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByLkZvbGxvd2VkQ291bnQgfHwgcjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHVzZXJzIHdobyBhcmUgZm9sbG93aW5nIHRoZSBjdXJyZW50IHVzZXIuXHJcbiAgICAgKi9cclxuICAgIE15U29jaWFsUXVlcnkucHJvdG90eXBlLmZvbGxvd2VycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShNeVNvY2lhbFF1ZXJ5XzEsIFwiZm9sbG93ZXJzXCIpLmdldCgpLnRoZW4oZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhPUChyLCBcIkZvbGxvd2Vyc1wiKSA/IHIuRm9sbG93ZXJzLnJlc3VsdHMgOiByO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB1c2VycyB3aG8gdGhlIGN1cnJlbnQgdXNlciBtaWdodCB3YW50IHRvIGZvbGxvdy5cclxuICAgICAqL1xyXG4gICAgTXlTb2NpYWxRdWVyeS5wcm90b3R5cGUuc3VnZ2VzdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoTXlTb2NpYWxRdWVyeV8xLCBcInN1Z2dlc3Rpb25zXCIpLmdldCgpLnRoZW4oZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhPUChyLCBcIlN1Z2dlc3Rpb25zXCIpID8gci5TdWdnZXN0aW9ucy5yZXN1bHRzIDogcjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgTXlTb2NpYWxRdWVyeV8xO1xyXG4gICAgTXlTb2NpYWxRdWVyeSA9IE15U29jaWFsUXVlcnlfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGRlZmF1bHRQYXRoKFwibXlcIilcclxuICAgIF0sIE15U29jaWFsUXVlcnkpO1xyXG4gICAgcmV0dXJuIE15U29jaWFsUXVlcnk7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZUluc3RhbmNlKSk7XHJcbi8qKlxyXG4gKiBTb2NpYWwgYWN0b3IgdHlwZVxyXG4gKlxyXG4gKi9cclxudmFyIFNvY2lhbEFjdG9yVHlwZTtcclxuKGZ1bmN0aW9uIChTb2NpYWxBY3RvclR5cGUpIHtcclxuICAgIFNvY2lhbEFjdG9yVHlwZVtTb2NpYWxBY3RvclR5cGVbXCJVc2VyXCJdID0gMF0gPSBcIlVzZXJcIjtcclxuICAgIFNvY2lhbEFjdG9yVHlwZVtTb2NpYWxBY3RvclR5cGVbXCJEb2N1bWVudFwiXSA9IDFdID0gXCJEb2N1bWVudFwiO1xyXG4gICAgU29jaWFsQWN0b3JUeXBlW1NvY2lhbEFjdG9yVHlwZVtcIlNpdGVcIl0gPSAyXSA9IFwiU2l0ZVwiO1xyXG4gICAgU29jaWFsQWN0b3JUeXBlW1NvY2lhbEFjdG9yVHlwZVtcIlRhZ1wiXSA9IDNdID0gXCJUYWdcIjtcclxufSkoU29jaWFsQWN0b3JUeXBlIHx8IChTb2NpYWxBY3RvclR5cGUgPSB7fSkpO1xyXG4vKipcclxuICogU29jaWFsIGFjdG9yIHR5cGVcclxuICpcclxuICovXHJcbi8qIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2UgKi9cclxudmFyIFNvY2lhbEFjdG9yVHlwZXM7XHJcbihmdW5jdGlvbiAoU29jaWFsQWN0b3JUeXBlcykge1xyXG4gICAgU29jaWFsQWN0b3JUeXBlc1tTb2NpYWxBY3RvclR5cGVzW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICBTb2NpYWxBY3RvclR5cGVzW1NvY2lhbEFjdG9yVHlwZXNbXCJVc2VyXCJdID0gMV0gPSBcIlVzZXJcIjtcclxuICAgIFNvY2lhbEFjdG9yVHlwZXNbU29jaWFsQWN0b3JUeXBlc1tcIkRvY3VtZW50XCJdID0gMl0gPSBcIkRvY3VtZW50XCI7XHJcbiAgICBTb2NpYWxBY3RvclR5cGVzW1NvY2lhbEFjdG9yVHlwZXNbXCJTaXRlXCJdID0gNF0gPSBcIlNpdGVcIjtcclxuICAgIFNvY2lhbEFjdG9yVHlwZXNbU29jaWFsQWN0b3JUeXBlc1tcIlRhZ1wiXSA9IDhdID0gXCJUYWdcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBleGNsdWRlcyBkb2N1bWVudHMgYW5kIHNpdGVzIHRoYXQgZG8gbm90IGhhdmUgZmVlZHMuXHJcbiAgICAgKi9cclxuICAgIFNvY2lhbEFjdG9yVHlwZXNbU29jaWFsQWN0b3JUeXBlc1tcIkV4Y2x1ZGVDb250ZW50V2l0aG91dEZlZWRzXCJdID0gMjY4NDM1NDU2XSA9IFwiRXhjbHVkZUNvbnRlbnRXaXRob3V0RmVlZHNcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBpbmNsdWRlcyBncm91cCBzaXRlc1xyXG4gICAgICovXHJcbiAgICBTb2NpYWxBY3RvclR5cGVzW1NvY2lhbEFjdG9yVHlwZXNbXCJJbmNsdWRlR3JvdXBzU2l0ZXNcIl0gPSA1MzY4NzA5MTJdID0gXCJJbmNsdWRlR3JvdXBzU2l0ZXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBpbmNsdWRlcyBvbmx5IGl0ZW1zIGNyZWF0ZWQgd2l0aGluIHRoZSBsYXN0IDI0IGhvdXJzXHJcbiAgICAgKi9cclxuICAgIFNvY2lhbEFjdG9yVHlwZXNbU29jaWFsQWN0b3JUeXBlc1tcIldpdGhpbkxhc3QyNEhvdXJzXCJdID0gMTA3Mzc0MTgyNF0gPSBcIldpdGhpbkxhc3QyNEhvdXJzXCI7XHJcbn0pKFNvY2lhbEFjdG9yVHlwZXMgfHwgKFNvY2lhbEFjdG9yVHlwZXMgPSB7fSkpO1xyXG4vKiB0c2xpbnQ6ZW5hYmxlICovXHJcbi8qKlxyXG4gKiBSZXN1bHQgZnJvbSBmb2xsb3dpbmdcclxuICpcclxuICovXHJcbnZhciBTb2NpYWxGb2xsb3dSZXN1bHQ7XHJcbihmdW5jdGlvbiAoU29jaWFsRm9sbG93UmVzdWx0KSB7XHJcbiAgICBTb2NpYWxGb2xsb3dSZXN1bHRbU29jaWFsRm9sbG93UmVzdWx0W1wiT2tcIl0gPSAwXSA9IFwiT2tcIjtcclxuICAgIFNvY2lhbEZvbGxvd1Jlc3VsdFtTb2NpYWxGb2xsb3dSZXN1bHRbXCJBbHJlYWR5Rm9sbG93aW5nXCJdID0gMV0gPSBcIkFscmVhZHlGb2xsb3dpbmdcIjtcclxuICAgIFNvY2lhbEZvbGxvd1Jlc3VsdFtTb2NpYWxGb2xsb3dSZXN1bHRbXCJMaW1pdFJlYWNoZWRcIl0gPSAyXSA9IFwiTGltaXRSZWFjaGVkXCI7XHJcbiAgICBTb2NpYWxGb2xsb3dSZXN1bHRbU29jaWFsRm9sbG93UmVzdWx0W1wiSW50ZXJuYWxFcnJvclwiXSA9IDNdID0gXCJJbnRlcm5hbEVycm9yXCI7XHJcbn0pKFNvY2lhbEZvbGxvd1Jlc3VsdCB8fCAoU29jaWFsRm9sbG93UmVzdWx0ID0ge30pKTtcclxuLyoqXHJcbiAqIFNwZWNpZmllcyBhbiBleGNlcHRpb24gb3Igc3RhdHVzIGNvZGUuXHJcbiAqL1xyXG52YXIgU29jaWFsU3RhdHVzQ29kZTtcclxuKGZ1bmN0aW9uIChTb2NpYWxTdGF0dXNDb2RlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseVxyXG4gICAgICovXHJcbiAgICBTb2NpYWxTdGF0dXNDb2RlW1NvY2lhbFN0YXR1c0NvZGVbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVxdWVzdCBpcyBpbnZhbGlkLlxyXG4gICAgICovXHJcbiAgICBTb2NpYWxTdGF0dXNDb2RlW1NvY2lhbFN0YXR1c0NvZGVbXCJJbnZhbGlkUmVxdWVzdFwiXSA9IDFdID0gXCJJbnZhbGlkUmVxdWVzdFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhlIGN1cnJlbnQgdXNlciBpcyBub3QgYXV0aG9yaXplZCB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIFNvY2lhbFN0YXR1c0NvZGVbU29jaWFsU3RhdHVzQ29kZVtcIkFjY2Vzc0RlbmllZFwiXSA9IDJdID0gXCJBY2Nlc3NEZW5pZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGUgb3BlcmF0aW9uIHdhcyBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIFNvY2lhbFN0YXR1c0NvZGVbU29jaWFsU3RhdHVzQ29kZVtcIkl0ZW1Ob3RGb3VuZFwiXSA9IDNdID0gXCJJdGVtTm90Rm91bmRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBpcyBpbnZhbGlkIGZvciB0aGUgdGFyZ2V0J3MgY3VycmVudCBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgU29jaWFsU3RhdHVzQ29kZVtTb2NpYWxTdGF0dXNDb2RlW1wiSW52YWxpZE9wZXJhdGlvblwiXSA9IDRdID0gXCJJbnZhbGlkT3BlcmF0aW9uXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gY29tcGxldGVkIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIFNvY2lhbFN0YXR1c0NvZGVbU29jaWFsU3RhdHVzQ29kZVtcIkl0ZW1Ob3RNb2RpZmllZFwiXSA9IDVdID0gXCJJdGVtTm90TW9kaWZpZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBmYWlsZWQgYmVjYXVzZSBhbiBpbnRlcm5hbCBlcnJvciBvY2N1cnJlZC5cclxuICAgICAqL1xyXG4gICAgU29jaWFsU3RhdHVzQ29kZVtTb2NpYWxTdGF0dXNDb2RlW1wiSW50ZXJuYWxFcnJvclwiXSA9IDZdID0gXCJJbnRlcm5hbEVycm9yXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIHNlcnZlciBjb3VsZCBub3QgYWNjZXNzIHRoZSBkaXN0cmlidXRlZCBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgU29jaWFsU3RhdHVzQ29kZVtTb2NpYWxTdGF0dXNDb2RlW1wiQ2FjaGVSZWFkRXJyb3JcIl0gPSA3XSA9IFwiQ2FjaGVSZWFkRXJyb3JcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiBzdWNjZWVkZWQgYnV0IHRoZSBzZXJ2ZXIgY291bGQgbm90IHVwZGF0ZSB0aGUgZGlzdHJpYnV0ZWQgY2FjaGUuXHJcbiAgICAgKi9cclxuICAgIFNvY2lhbFN0YXR1c0NvZGVbU29jaWFsU3RhdHVzQ29kZVtcIkNhY2hlVXBkYXRlRXJyb3JcIl0gPSA4XSA9IFwiQ2FjaGVVcGRhdGVFcnJvclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBObyBwZXJzb25hbCBzaXRlIGV4aXN0cyBmb3IgdGhlIGN1cnJlbnQgdXNlciwgYW5kIG5vIGZ1cnRoZXIgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlLlxyXG4gICAgICovXHJcbiAgICBTb2NpYWxTdGF0dXNDb2RlW1NvY2lhbFN0YXR1c0NvZGVbXCJQZXJzb25hbFNpdGVOb3RGb3VuZFwiXSA9IDldID0gXCJQZXJzb25hbFNpdGVOb3RGb3VuZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBObyBwZXJzb25hbCBzaXRlIGV4aXN0cyBmb3IgdGhlIGN1cnJlbnQgdXNlciwgYW5kIGEgcHJldmlvdXMgYXR0ZW1wdCB0byBjcmVhdGUgb25lIGZhaWxlZC5cclxuICAgICAqL1xyXG4gICAgU29jaWFsU3RhdHVzQ29kZVtTb2NpYWxTdGF0dXNDb2RlW1wiRmFpbGVkVG9DcmVhdGVQZXJzb25hbFNpdGVcIl0gPSAxMF0gPSBcIkZhaWxlZFRvQ3JlYXRlUGVyc29uYWxTaXRlXCI7XHJcbiAgICAvKipcclxuICAgICAqIE5vIHBlcnNvbmFsIHNpdGUgZXhpc3RzIGZvciB0aGUgY3VycmVudCB1c2VyLCBhbmQgYSBwcmV2aW91cyBhdHRlbXB0IHRvIGNyZWF0ZSBvbmUgd2FzIG5vdCBhdXRob3JpemVkLlxyXG4gICAgICovXHJcbiAgICBTb2NpYWxTdGF0dXNDb2RlW1NvY2lhbFN0YXR1c0NvZGVbXCJOb3RBdXRob3JpemVkVG9DcmVhdGVQZXJzb25hbFNpdGVcIl0gPSAxMV0gPSBcIk5vdEF1dGhvcml6ZWRUb0NyZWF0ZVBlcnNvbmFsU2l0ZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBObyBwZXJzb25hbCBzaXRlIGV4aXN0cyBmb3IgdGhlIGN1cnJlbnQgdXNlciwgYW5kIG5vIGF0dGVtcHQgc2hvdWxkIGJlIG1hZGUgdG8gY3JlYXRlIG9uZS5cclxuICAgICAqL1xyXG4gICAgU29jaWFsU3RhdHVzQ29kZVtTb2NpYWxTdGF0dXNDb2RlW1wiQ2Fubm90Q3JlYXRlUGVyc29uYWxTaXRlXCJdID0gMTJdID0gXCJDYW5ub3RDcmVhdGVQZXJzb25hbFNpdGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiB3YXMgcmVqZWN0ZWQgYmVjYXVzZSBhbiBpbnRlcm5hbCBsaW1pdCBoYWQgYmVlbiByZWFjaGVkLlxyXG4gICAgICovXHJcbiAgICBTb2NpYWxTdGF0dXNDb2RlW1NvY2lhbFN0YXR1c0NvZGVbXCJMaW1pdFJlYWNoZWRcIl0gPSAxM10gPSBcIkxpbWl0UmVhY2hlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BlcmF0aW9uIGZhaWxlZCBiZWNhdXNlIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgc3BlY2lmaWVkIGF0dGFjaG1lbnQuXHJcbiAgICAgKi9cclxuICAgIFNvY2lhbFN0YXR1c0NvZGVbU29jaWFsU3RhdHVzQ29kZVtcIkF0dGFjaG1lbnRFcnJvclwiXSA9IDE0XSA9IFwiQXR0YWNobWVudEVycm9yXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gc3VjY2VlZGVkIHdpdGggcmVjb3ZlcmFibGUgZXJyb3JzOyB0aGUgcmV0dXJuZWQgZGF0YSBpcyBpbmNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBTb2NpYWxTdGF0dXNDb2RlW1NvY2lhbFN0YXR1c0NvZGVbXCJQYXJ0aWFsRGF0YVwiXSA9IDE1XSA9IFwiUGFydGlhbERhdGFcIjtcclxuICAgIC8qKlxyXG4gICAgICogQSByZXF1aXJlZCBTaGFyZVBvaW50IGZlYXR1cmUgaXMgbm90IGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIFNvY2lhbFN0YXR1c0NvZGVbU29jaWFsU3RhdHVzQ29kZVtcIkZlYXR1cmVEaXNhYmxlZFwiXSA9IDE2XSA9IFwiRmVhdHVyZURpc2FibGVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaXRlJ3Mgc3RvcmFnZSBxdW90YSBoYXMgYmVlbiBleGNlZWRlZC5cclxuICAgICAqL1xyXG4gICAgU29jaWFsU3RhdHVzQ29kZVtTb2NpYWxTdGF0dXNDb2RlW1wiU3RvcmFnZVF1b3RhRXhjZWVkZWRcIl0gPSAxN10gPSBcIlN0b3JhZ2VRdW90YUV4Y2VlZGVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGVyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIHNlcnZlciBjb3VsZCBub3QgYWNjZXNzIHRoZSBkYXRhYmFzZS5cclxuICAgICAqL1xyXG4gICAgU29jaWFsU3RhdHVzQ29kZVtTb2NpYWxTdGF0dXNDb2RlW1wiRGF0YWJhc2VFcnJvclwiXSA9IDE4XSA9IFwiRGF0YWJhc2VFcnJvclwiO1xyXG59KShTb2NpYWxTdGF0dXNDb2RlIHx8IChTb2NpYWxTdGF0dXNDb2RlID0ge30pKTtcblxuLyoqXHJcbiAqIEFsbG93cyBmb3IgY2FsbGluZyBvZiB0aGUgc3RhdGljIFNQLlV0aWxpdGllcy5VdGlsaXR5IG1ldGhvZHMgYnkgc3VwcGx5aW5nIHRoZSBtZXRob2QgbmFtZVxyXG4gKi9cclxudmFyIFV0aWxpdHlNZXRob2QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVXRpbGl0eU1ldGhvZCwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgVXRpbGl0eSBtZXRob2QgY2xhc3NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmFzZVVybCBUaGUgcGFyZW50IHVybCBwcm92aWRlclxyXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWUgVGhlIHN0YXRpYyBtZXRob2QgbmFtZSB0byBjYWxsIG9uIHRoZSB1dGlsaXR5IGNsYXNzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFV0aWxpdHlNZXRob2QoYmFzZVVybCwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBVdGlsaXR5TWV0aG9kLmdldEJhc2VVcmwoYmFzZVVybCksIFwiX2FwaS9TUC5VdGlsaXRpZXMuVXRpbGl0eS5cIiArIG1ldGhvZE5hbWUpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBVdGlsaXR5TWV0aG9kLmdldEJhc2VVcmwgPSBmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGMgPSBjYW5kaWRhdGU7XHJcbiAgICAgICAgdmFyIHVybCA9IGMudG9VcmwoKTtcclxuICAgICAgICB2YXIgaW5kZXggPSB1cmwuaW5kZXhPZihcIl9hcGkvXCIpO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVybC5zdWJzdHIoMCwgaW5kZXgpO1xyXG4gICAgfTtcclxuICAgIFV0aWxpdHlNZXRob2QucHJvdG90eXBlLmV4Y3V0ZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc3RDb3JlKHtcclxuICAgICAgICAgICAgYm9keToganNTKHByb3BzKSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGFuIGVtYWlsIGJhc2VkIG9uIHRoZSBzdXBwbGllZCBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3BzIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBlbWFpbCB0byBzZW5kXHJcbiAgICAgKi9cclxuICAgIFV0aWxpdHlNZXRob2QucHJvdG90eXBlLnNlbmRFbWFpbCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IGV4dGVuZChtZXRhZGF0YShcIlNQLlV0aWxpdGllcy5FbWFpbFByb3BlcnRpZXNcIiksIHtcclxuICAgICAgICAgICAgICAgIEJvZHk6IHByb3BzLkJvZHksXHJcbiAgICAgICAgICAgICAgICBGcm9tOiBwcm9wcy5Gcm9tLFxyXG4gICAgICAgICAgICAgICAgU3ViamVjdDogcHJvcHMuU3ViamVjdCxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAocHJvcHMuVG8gJiYgcHJvcHMuVG8ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBwYXJhbXMucHJvcGVydGllcyA9IGV4dGVuZChwYXJhbXMucHJvcGVydGllcywge1xyXG4gICAgICAgICAgICAgICAgVG86IHsgcmVzdWx0czogcHJvcHMuVG8gfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5DQyAmJiBwcm9wcy5DQy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5wcm9wZXJ0aWVzID0gZXh0ZW5kKHBhcmFtcy5wcm9wZXJ0aWVzLCB7XHJcbiAgICAgICAgICAgICAgICBDQzogeyByZXN1bHRzOiBwcm9wcy5DQyB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLkJDQyAmJiBwcm9wcy5CQ0MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBwYXJhbXMucHJvcGVydGllcyA9IGV4dGVuZChwYXJhbXMucHJvcGVydGllcywge1xyXG4gICAgICAgICAgICAgICAgQkNDOiB7IHJlc3VsdHM6IHByb3BzLkJDQyB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLkFkZGl0aW9uYWxIZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5wcm9wZXJ0aWVzID0gZXh0ZW5kKHBhcmFtcy5wcm9wZXJ0aWVzLCB7XHJcbiAgICAgICAgICAgICAgICBBZGRpdGlvbmFsSGVhZGVyczogcHJvcHMuQWRkaXRpb25hbEhlYWRlcnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShVdGlsaXR5TWV0aG9kLCBcIlNlbmRFbWFpbFwiLCB0cnVlKS5leGN1dGUocGFyYW1zKTtcclxuICAgIH07XHJcbiAgICBVdGlsaXR5TWV0aG9kLnByb3RvdHlwZS5nZXRDdXJyZW50VXNlckVtYWlsQWRkcmVzc2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFV0aWxpdHlNZXRob2QsIFwiR2V0Q3VycmVudFVzZXJFbWFpbEFkZHJlc3Nlc1wiLCB0cnVlKS5leGN1dGUoe30pO1xyXG4gICAgfTtcclxuICAgIFV0aWxpdHlNZXRob2QucHJvdG90eXBlLnJlc29sdmVQcmluY2lwYWwgPSBmdW5jdGlvbiAoaW5wdXQsIHNjb3Blcywgc291cmNlcywgaW5wdXRJc0VtYWlsT25seSwgYWRkVG9Vc2VySW5mb0xpc3QsIG1hdGNoVXNlckluZm9MaXN0KSB7XHJcbiAgICAgICAgaWYgKG1hdGNoVXNlckluZm9MaXN0ID09PSB2b2lkIDApIHsgbWF0Y2hVc2VySW5mb0xpc3QgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGFkZFRvVXNlckluZm9MaXN0OiBhZGRUb1VzZXJJbmZvTGlzdCxcclxuICAgICAgICAgICAgaW5wdXQ6IGlucHV0LFxyXG4gICAgICAgICAgICBpbnB1dElzRW1haWxPbmx5OiBpbnB1dElzRW1haWxPbmx5LFxyXG4gICAgICAgICAgICBtYXRjaFVzZXJJbmZvTGlzdDogbWF0Y2hVc2VySW5mb0xpc3QsXHJcbiAgICAgICAgICAgIHNjb3Blczogc2NvcGVzLFxyXG4gICAgICAgICAgICBzb3VyY2VzOiBzb3VyY2VzLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoVXRpbGl0eU1ldGhvZCwgXCJSZXNvbHZlUHJpbmNpcGFsSW5DdXJyZW50Q29udGV4dFwiLCB0cnVlKS5leGN1dGUocGFyYW1zKTtcclxuICAgIH07XHJcbiAgICBVdGlsaXR5TWV0aG9kLnByb3RvdHlwZS5zZWFyY2hQcmluY2lwYWxzID0gZnVuY3Rpb24gKGlucHV0LCBzY29wZXMsIHNvdXJjZXMsIGdyb3VwTmFtZSwgbWF4Q291bnQpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICBncm91cE5hbWU6IGdyb3VwTmFtZSxcclxuICAgICAgICAgICAgaW5wdXQ6IGlucHV0LFxyXG4gICAgICAgICAgICBtYXhDb3VudDogbWF4Q291bnQsXHJcbiAgICAgICAgICAgIHNjb3Blczogc2NvcGVzLFxyXG4gICAgICAgICAgICBzb3VyY2VzOiBzb3VyY2VzLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoVXRpbGl0eU1ldGhvZCwgXCJTZWFyY2hQcmluY2lwYWxzVXNpbmdDb250ZXh0V2ViXCIsIHRydWUpLmV4Y3V0ZShwYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIFV0aWxpdHlNZXRob2QucHJvdG90eXBlLmNyZWF0ZUVtYWlsQm9keUZvckludml0YXRpb24gPSBmdW5jdGlvbiAocGFnZUFkZHJlc3MpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICBwYWdlQWRkcmVzczogcGFnZUFkZHJlc3MsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShVdGlsaXR5TWV0aG9kLCBcIkNyZWF0ZUVtYWlsQm9keUZvckludml0YXRpb25cIiwgdHJ1ZSkuZXhjdXRlKHBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgVXRpbGl0eU1ldGhvZC5wcm90b3R5cGUuZXhwYW5kR3JvdXBzVG9QcmluY2lwYWxzID0gZnVuY3Rpb24gKGlucHV0cywgbWF4Q291bnQpIHtcclxuICAgICAgICBpZiAobWF4Q291bnQgPT09IHZvaWQgMCkgeyBtYXhDb3VudCA9IDMwOyB9XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHMsXHJcbiAgICAgICAgICAgIG1heENvdW50OiBtYXhDb3VudCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKFV0aWxpdHlNZXRob2QsIFwiRXhwYW5kR3JvdXBzVG9QcmluY2lwYWxzXCIsIHRydWUpLmV4Y3V0ZShwYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIFV0aWxpdHlNZXRob2QucHJvdG90eXBlLmNyZWF0ZVdpa2lQYWdlID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShVdGlsaXR5TWV0aG9kLCBcIkNyZWF0ZVdpa2lQYWdlSW5Db250ZXh0V2ViXCIsIHRydWUpLmV4Y3V0ZSh7XHJcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGluZm8sXHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YTogcixcclxuICAgICAgICAgICAgICAgIGZpbGU6IG5ldyBGaWxlKG9kYXRhVXJsRnJvbShyKSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFV0aWxpdHlNZXRob2Q7XHJcbn0oU2hhcmVQb2ludFF1ZXJ5YWJsZSkpO1xuXG4vKipcclxuICogUm9vdCBvZiB0aGUgU2hhcmVQb2ludCBSRVNUIG1vZHVsZVxyXG4gKi9cclxudmFyIFNQUmVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgU1BSZXN0IGNsYXNzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gYmFzZVVybCBBIHN0cmluZyB0aGF0IHNob3VsZCBmb3JtIHRoZSBiYXNlIHBhcnQgb2YgdGhlIHVybFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTUFJlc3QoX29wdGlvbnMsIF9iYXNlVXJsKSB7XHJcbiAgICAgICAgaWYgKF9vcHRpb25zID09PSB2b2lkIDApIHsgX29wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIGlmIChfYmFzZVVybCA9PT0gdm9pZCAwKSB7IF9iYXNlVXJsID0gXCJcIjsgfVxyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgICAgICB0aGlzLl9iYXNlVXJsID0gX2Jhc2VVcmw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgaW5zdGFuY2Ugd2l0aCBhZGRpdGlvbmFsIG9wdGlvbnMgYW5kIGJhc2VVcmwuXHJcbiAgICAgKiBQcm92aWRlZCBjb25maWd1cmF0aW9uIHVzZWQgYnkgb3RoZXIgb2JqZWN0cyBpbiBhIGNoYWluXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gYmFzZVVybCBBIHN0cmluZyB0aGF0IHNob3VsZCBmb3JtIHRoZSBiYXNlIHBhcnQgb2YgdGhlIHVybFxyXG4gICAgICovXHJcbiAgICBTUFJlc3QucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBiYXNlVXJsKSB7XHJcbiAgICAgICAgaWYgKGJhc2VVcmwgPT09IHZvaWQgMCkgeyBiYXNlVXJsID0gXCJcIjsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU1BSZXN0KG9wdGlvbnMsIGJhc2VVcmwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2xvYmFsIFNoYXJlUG9pbnQgY29uZmlndXJhdGlvbiBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgU2hhcmVQb2ludCBjb25maWd1cmF0aW9uIHRvIGFwcGx5XHJcbiAgICAgKi9cclxuICAgIFNQUmVzdC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgc2V0dXAoY29uZmlnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIGEgc2VhcmNoIGFnYWluc3QgdGhpcyB3ZWIgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBxdWVyeSBUaGUgU2VhcmNoUXVlcnkgZGVmaW5pdGlvblxyXG4gICAgICovXHJcbiAgICBTUFJlc3QucHJvdG90eXBlLnNlYXJjaFN1Z2dlc3QgPSBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICB2YXIgZmluYWxRdWVyeTtcclxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGZpbmFsUXVlcnkgPSB7IHF1ZXJ5dGV4dDogcXVlcnkgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpbmFsUXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKFNlYXJjaFN1Z2dlc3QpLmV4ZWN1dGUoZmluYWxRdWVyeSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyBhIHNlYXJjaCBhZ2FpbnN0IHRoaXMgd2ViIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcXVlcnkgVGhlIFNlYXJjaFF1ZXJ5IGRlZmluaXRpb25cclxuICAgICAqL1xyXG4gICAgU1BSZXN0LnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoU2VhcmNoKS5leGVjdXRlKHF1ZXJ5KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBzZWFyY2ggcXVlcnksIGNhY2hpbmcgdGhlIHJlc3VsdHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcXVlcnkgVGhlIFNlYXJjaFF1ZXJ5IGRlZmluaXRpb25cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBzZXQgb2YgY2FjaGluZyBvcHRpb25zIHVzZWQgdG8gc3RvcmUgdGhlIHJlc3VsdHNcclxuICAgICAqL1xyXG4gICAgU1BSZXN0LnByb3RvdHlwZS5zZWFyY2hXaXRoQ2FjaGluZyA9IGZ1bmN0aW9uIChxdWVyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShTZWFyY2gpLnVzaW5nQ2FjaGluZyhvcHRpb25zKS5leGVjdXRlKHF1ZXJ5KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU1BSZXN0LnByb3RvdHlwZSwgXCJzaXRlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCZWdpbnMgYSBzaXRlIGNvbGxlY3Rpb24gc2NvcGVkIFJFU1QgcmVxdWVzdFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShTaXRlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTUFJlc3QucHJvdG90eXBlLCBcIndlYlwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVnaW5zIGEgd2ViIHNjb3BlZCBSRVNUIHJlcXVlc3RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoV2ViKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTUFJlc3QucHJvdG90eXBlLCBcInByb2ZpbGVzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY2Nlc3MgdG8gdXNlciBwcm9maWxlIG1ldGhvZHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoVXNlclByb2ZpbGVRdWVyeSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU1BSZXN0LnByb3RvdHlwZSwgXCJzb2NpYWxcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjY2VzcyB0byBzb2NpYWwgbWV0aG9kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoU29jaWFsUXVlcnkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNQUmVzdC5wcm90b3R5cGUsIFwibmF2aWdhdGlvblwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWNjZXNzIHRvIHRoZSBzaXRlIGNvbGxlY3Rpb24gbGV2ZWwgbmF2aWdhdGlvbiBzZXJ2aWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvblNlcnZpY2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBiYXRjaCBvYmplY3QgZm9yIHVzZSB3aXRoIHRoZSBTaGFyZVBvaW50UXVlcnlhYmxlLmFkZFRvQmF0Y2ggbWV0aG9kXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBTUFJlc3QucHJvdG90eXBlLmNyZWF0ZUJhdGNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndlYi5jcmVhdGVCYXRjaCgpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTUFJlc3QucHJvdG90eXBlLCBcInV0aWxpdHlcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0YXRpYyB1dGlsaXRpZXMgbWV0aG9kcyBmcm9tIFNQLlV0aWxpdGllcy5VdGlsaXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShVdGlsaXR5TWV0aG9kLCBcIlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBjcmVhdGluZyBhbmQgY29uZmlndXJpbmcgdGhlIG9iamVjdHMgcmV0dXJuZWQgZnJvbSB0aGlzIGNsYXNzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZtIFRoZSBmYWN0b3J5IG1ldGhvZCB1c2VkIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSBwYXRoIE9wdGlvbmFsIGFkZGl0aW9uYWwgcGF0aCBpbmZvcm1hdGlvbiB0byBwYXNzIHRvIHRoZSBmYWN0b3J5IG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBTUFJlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChmbSwgcGF0aCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgZm0odGhpcy5fYmFzZVVybCwgcGF0aCkuY29uZmlndXJlKHRoaXMuX29wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTUFJlc3Q7XHJcbn0oKSk7XHJcbnZhciBzcCA9IG5ldyBTUFJlc3QoKTtcblxuZXhwb3J0IHsgb2RhdGFVcmxGcm9tLCBzcE9EYXRhRW50aXR5LCBzcE9EYXRhRW50aXR5QXJyYXksIFNoYXJlUG9pbnRRdWVyeWFibGUsIFNoYXJlUG9pbnRRdWVyeWFibGVJbnN0YW5jZSwgU2hhcmVQb2ludFF1ZXJ5YWJsZUNvbGxlY3Rpb24sIFNoYXJlUG9pbnRRdWVyeWFibGVTZWN1cmFibGUsIEZpbGVGb2xkZXJTaGFyZWQsIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGUsIFNoYXJlUG9pbnRRdWVyeWFibGVTaGFyZWFibGVGaWxlLCBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlRm9sZGVyLCBTaGFyZVBvaW50UXVlcnlhYmxlU2hhcmVhYmxlSXRlbSwgU2hhcmVQb2ludFF1ZXJ5YWJsZVNoYXJlYWJsZVdlYiwgQXBwQ2F0YWxvZywgQXBwLCBTUEJhdGNoLCBDb250ZW50VHlwZSwgQ29udGVudFR5cGVzLCBGaWVsZExpbmssIEZpZWxkTGlua3MsIEZpZWxkLCBGaWVsZHMsIENoZWNraW5UeXBlLCBXZWJQYXJ0c1BlcnNvbmFsaXphdGlvblNjb3BlLCBNb3ZlT3BlcmF0aW9ucywgVGVtcGxhdGVGaWxlVHlwZSwgRmlsZSwgRmlsZXMsIEZvbGRlciwgRm9sZGVycywgU1BIdHRwQ2xpZW50LCBJdGVtLCBJdGVtcywgSXRlbVZlcnNpb24sIEl0ZW1WZXJzaW9ucywgUGFnZWRJdGVtQ29sbGVjdGlvbiwgTmF2aWdhdGlvbk5vZGVzLCBOYXZpZ2F0aW9uTm9kZSwgTmF2aWdhdGlvblNlcnZpY2UsIExpc3QsIExpc3RzLCBSZWdpb25hbFNldHRpbmdzLCBJbnN0YWxsZWRMYW5ndWFnZXMsIFRpbWVab25lLCBUaW1lWm9uZXMsIHNwLCBTUFJlc3QsIFJvbGVEZWZpbml0aW9uQmluZGluZ3MsIFNlYXJjaCwgU2VhcmNoUXVlcnlCdWlsZGVyLCBTZWFyY2hSZXN1bHRzLCBTb3J0RGlyZWN0aW9uLCBSZW9yZGVyaW5nUnVsZU1hdGNoVHlwZSwgUXVlcnlQcm9wZXJ0eVZhbHVlVHlwZSwgU2VhcmNoQnVpbHRJblNvdXJjZUlkLCBTZWFyY2hTdWdnZXN0LCBTaXRlLCBVc2VyUHJvZmlsZVF1ZXJ5LCB0b0Fic29sdXRlVXJsLCBleHRyYWN0V2ViVXJsLCBVdGlsaXR5TWV0aG9kLCBWaWV3LCBWaWV3cywgVmlld0ZpZWxkcywgV2ViUGFydERlZmluaXRpb25zLCBXZWJQYXJ0RGVmaW5pdGlvbiwgV2ViUGFydCwgV2ViLCBQcm9tb3RlZFN0YXRlLCBDbGllbnRTaWRlUGFnZSwgQ2FudmFzU2VjdGlvbiwgQ2FudmFzQ29udHJvbCwgQ2FudmFzQ29sdW1uLCBDbGllbnRTaWRlUGFydCwgQ2xpZW50U2lkZVRleHQsIENsaWVudFNpZGVXZWJwYXJ0LCBDb21tZW50cywgQ29tbWVudCwgUmVwbGllcywgU29jaWFsUXVlcnksIE15U29jaWFsUXVlcnksIFNvY2lhbEFjdG9yVHlwZSwgU29jaWFsQWN0b3JUeXBlcywgU29jaWFsRm9sbG93UmVzdWx0LCBTb2NpYWxTdGF0dXNDb2RlLCBDb250cm9sTW9kZSwgRmllbGRUeXBlcywgRGF0ZVRpbWVGaWVsZEZvcm1hdFR5cGUsIEFkZEZpZWxkT3B0aW9ucywgQ2FsZW5kYXJUeXBlLCBVcmxGaWVsZEZvcm1hdFR5cGUsIFBlcm1pc3Npb25LaW5kLCBQcmluY2lwYWxUeXBlJDEgYXMgUHJpbmNpcGFsVHlwZSwgUHJpbmNpcGFsU291cmNlLCBSb2xlVHlwZSwgUGFnZVR5cGUsIFNoYXJpbmdMaW5rS2luZCwgU2hhcmluZ1JvbGUsIFNoYXJpbmdPcGVyYXRpb25TdGF0dXNDb2RlLCBTUFNoYXJlZE9iamVjdFR5cGUsIFNoYXJpbmdEb21haW5SZXN0cmljdGlvbk1vZGUsIFJlbmRlckxpc3REYXRhT3B0aW9ucywgRmllbGRVc2VyU2VsZWN0aW9uTW9kZSwgQ2hvaWNlRmllbGRGb3JtYXRUeXBlLCBVcmxab25lIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcC5lczUuanMubWFwXG4iLCIvKiEgYWRhbC1hbmd1bGFyIHYxLjAuMTcgMjAxOC0wMi0yNyAqL1xyXG52YXIgQXV0aGVudGljYXRpb25Db250ZXh0PWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIEF1dGhlbnRpY2F0aW9uQ29udGV4dD1mdW5jdGlvbihhKXtpZih0aGlzLlJFUVVFU1RfVFlQRT17TE9HSU46XCJMT0dJTlwiLFJFTkVXX1RPS0VOOlwiUkVORVdfVE9LRU5cIixVTktOT1dOOlwiVU5LTk9XTlwifSx0aGlzLlJFU1BPTlNFX1RZUEU9e0lEX1RPS0VOX1RPS0VOOlwiaWRfdG9rZW4gdG9rZW5cIixUT0tFTjpcInRva2VuXCJ9LHRoaXMuQ09OU1RBTlRTPXtBQ0NFU1NfVE9LRU46XCJhY2Nlc3NfdG9rZW5cIixFWFBJUkVTX0lOOlwiZXhwaXJlc19pblwiLElEX1RPS0VOOlwiaWRfdG9rZW5cIixFUlJPUl9ERVNDUklQVElPTjpcImVycm9yX2Rlc2NyaXB0aW9uXCIsU0VTU0lPTl9TVEFURTpcInNlc3Npb25fc3RhdGVcIixFUlJPUjpcImVycm9yXCIsU1RPUkFHRTp7VE9LRU5fS0VZUzpcImFkYWwudG9rZW4ua2V5c1wiLEFDQ0VTU19UT0tFTl9LRVk6XCJhZGFsLmFjY2Vzcy50b2tlbi5rZXlcIixFWFBJUkFUSU9OX0tFWTpcImFkYWwuZXhwaXJhdGlvbi5rZXlcIixTVEFURV9MT0dJTjpcImFkYWwuc3RhdGUubG9naW5cIixTVEFURV9SRU5FVzpcImFkYWwuc3RhdGUucmVuZXdcIixOT05DRV9JRFRPS0VOOlwiYWRhbC5ub25jZS5pZHRva2VuXCIsU0VTU0lPTl9TVEFURTpcImFkYWwuc2Vzc2lvbi5zdGF0ZVwiLFVTRVJOQU1FOlwiYWRhbC51c2VybmFtZVwiLElEVE9LRU46XCJhZGFsLmlkdG9rZW5cIixFUlJPUjpcImFkYWwuZXJyb3JcIixFUlJPUl9ERVNDUklQVElPTjpcImFkYWwuZXJyb3IuZGVzY3JpcHRpb25cIixMT0dJTl9SRVFVRVNUOlwiYWRhbC5sb2dpbi5yZXF1ZXN0XCIsTE9HSU5fRVJST1I6XCJhZGFsLmxvZ2luLmVycm9yXCIsUkVORVdfU1RBVFVTOlwiYWRhbC50b2tlbi5yZW5ldy5zdGF0dXNcIixBTkdVTEFSX0xPR0lOX1JFUVVFU1Q6XCJhZGFsLmFuZ3VsYXIubG9naW4ucmVxdWVzdFwifSxSRVNPVVJDRV9ERUxJTUVURVI6XCJ8XCIsQ0FDSEVfREVMSU1FVEVSOlwifHxcIixMT0FERlJBTUVfVElNRU9VVDo2ZTMsVE9LRU5fUkVORVdfU1RBVFVTX0NBTkNFTEVEOlwiQ2FuY2VsZWRcIixUT0tFTl9SRU5FV19TVEFUVVNfQ09NUExFVEVEOlwiQ29tcGxldGVkXCIsVE9LRU5fUkVORVdfU1RBVFVTX0lOX1BST0dSRVNTOlwiSW4gUHJvZ3Jlc3NcIixMT0dHSU5HX0xFVkVMOntFUlJPUjowLFdBUk46MSxJTkZPOjIsVkVSQk9TRTozfSxMRVZFTF9TVFJJTkdfTUFQOnswOlwiRVJST1I6XCIsMTpcIldBUk5JTkc6XCIsMjpcIklORk86XCIsMzpcIlZFUkJPU0U6XCJ9LFBPUFVQX1dJRFRIOjQ4MyxQT1BVUF9IRUlHSFQ6NjAwfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9zaW5nbGV0b25JbnN0YW5jZSlyZXR1cm4gQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fc2luZ2xldG9uSW5zdGFuY2U7aWYoQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fc2luZ2xldG9uSW5zdGFuY2U9dGhpcyx0aGlzLmluc3RhbmNlPVwiaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL1wiLHRoaXMuY29uZmlnPXt9LHRoaXMuY2FsbGJhY2s9bnVsbCx0aGlzLnBvcFVwPSExLHRoaXMuaXNBbmd1bGFyPSExLHRoaXMuX3VzZXI9bnVsbCx0aGlzLl9hY3RpdmVSZW5ld2Fscz17fSx0aGlzLl9sb2dpbkluUHJvZ3Jlc3M9ITEsdGhpcy5fYWNxdWlyZVRva2VuSW5Qcm9ncmVzcz0hMSx0aGlzLl9yZW5ld1N0YXRlcz1bXSx0aGlzLl9jYWxsQmFja01hcHBlZFRvUmVuZXdTdGF0ZXM9e30sdGhpcy5fY2FsbEJhY2tzTWFwcGVkVG9SZW5ld1N0YXRlcz17fSx0aGlzLl9vcGVuZWRXaW5kb3dzPVtdLHRoaXMuX3JlcXVlc3RUeXBlPXRoaXMuUkVRVUVTVF9UWVBFLkxPR0lOLHdpbmRvdy5fYWRhbEluc3RhbmNlPXRoaXMsYS5kaXNwbGF5Q2FsbCYmXCJmdW5jdGlvblwiIT10eXBlb2YgYS5kaXNwbGF5Q2FsbCl0aHJvdyBuZXcgRXJyb3IoXCJkaXNwbGF5Q2FsbCBpcyBub3QgYSBmdW5jdGlvblwiKTtpZighYS5jbGllbnRJZCl0aHJvdyBuZXcgRXJyb3IoXCJjbGllbnRJZCBpcyByZXF1aXJlZFwiKTt0aGlzLmNvbmZpZz10aGlzLl9jbG9uZUNvbmZpZyhhKSx2b2lkIDA9PT10aGlzLmNvbmZpZy5uYXZpZ2F0ZVRvTG9naW5SZXF1ZXN0VXJsJiYodGhpcy5jb25maWcubmF2aWdhdGVUb0xvZ2luUmVxdWVzdFVybD0hMCksdGhpcy5jb25maWcucG9wVXAmJih0aGlzLnBvcFVwPSEwKSx0aGlzLmNvbmZpZy5jYWxsYmFjayYmXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jb25maWcuY2FsbGJhY2smJih0aGlzLmNhbGxiYWNrPXRoaXMuY29uZmlnLmNhbGxiYWNrKSx0aGlzLmNvbmZpZy5pbnN0YW5jZSYmKHRoaXMuaW5zdGFuY2U9dGhpcy5jb25maWcuaW5zdGFuY2UpLHRoaXMuY29uZmlnLmxvZ2luUmVzb3VyY2V8fCh0aGlzLmNvbmZpZy5sb2dpblJlc291cmNlPXRoaXMuY29uZmlnLmNsaWVudElkKSx0aGlzLmNvbmZpZy5yZWRpcmVjdFVyaXx8KHRoaXMuY29uZmlnLnJlZGlyZWN0VXJpPXdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KFwiP1wiKVswXS5zcGxpdChcIiNcIilbMF0pLHRoaXMuY29uZmlnLnBvc3RMb2dvdXRSZWRpcmVjdFVyaXx8KHRoaXMuY29uZmlnLnBvc3RMb2dvdXRSZWRpcmVjdFVyaT13aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdChcIj9cIilbMF0uc3BsaXQoXCIjXCIpWzBdKSx0aGlzLmNvbmZpZy5hbm9ueW1vdXNFbmRwb2ludHN8fCh0aGlzLmNvbmZpZy5hbm9ueW1vdXNFbmRwb2ludHM9W10pLHRoaXMuY29uZmlnLmlzQW5ndWxhciYmKHRoaXMuaXNBbmd1bGFyPXRoaXMuY29uZmlnLmlzQW5ndWxhciksdGhpcy5jb25maWcubG9hZEZyYW1lVGltZW91dCYmKHRoaXMuQ09OU1RBTlRTLkxPQURGUkFNRV9USU1FT1VUPXRoaXMuY29uZmlnLmxvYWRGcmFtZVRpbWVvdXQpfSxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYod2luZG93LkxvZ2dpbmc9e3BpaUxvZ2dpbmdFbmFibGVkOiExLGxldmVsOjAsbG9nOmZ1bmN0aW9uKGEpe319KSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLmxvZ2luPWZ1bmN0aW9uKCl7aWYodGhpcy5fbG9naW5JblByb2dyZXNzKXJldHVybiB2b2lkIHRoaXMuaW5mbyhcIkxvZ2luIGluIHByb2dyZXNzXCIpO3RoaXMuX2xvZ2luSW5Qcm9ncmVzcz0hMDt2YXIgYT10aGlzLl9ndWlkKCk7dGhpcy5jb25maWcuc3RhdGU9YSx0aGlzLl9pZFRva2VuTm9uY2U9dGhpcy5fZ3VpZCgpO3ZhciBiPXRoaXMuX2dldEl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5BTkdVTEFSX0xPR0lOX1JFUVVFU1QpO2ImJlwiXCIhPT1iP3RoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuQU5HVUxBUl9MT0dJTl9SRVFVRVNULFwiXCIpOmI9d2luZG93LmxvY2F0aW9uLmhyZWYsdGhpcy52ZXJib3NlKFwiRXhwZWN0ZWQgc3RhdGU6IFwiK2ErXCIgc3RhcnRQYWdlOlwiK2IpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuTE9HSU5fUkVRVUVTVCxiKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkxPR0lOX0VSUk9SLFwiXCIpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuU1RBVEVfTE9HSU4sYSwhMCksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5OT05DRV9JRFRPS0VOLHRoaXMuX2lkVG9rZW5Ob25jZSwhMCksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5FUlJPUixcIlwiKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVSUk9SX0RFU0NSSVBUSU9OLFwiXCIpO3ZhciBjPXRoaXMuX2dldE5hdmlnYXRlVXJsKFwiaWRfdG9rZW5cIixudWxsKStcIiZub25jZT1cIitlbmNvZGVVUklDb21wb25lbnQodGhpcy5faWRUb2tlbk5vbmNlKTt0aGlzLmNvbmZpZy5kaXNwbGF5Q2FsbD90aGlzLmNvbmZpZy5kaXNwbGF5Q2FsbChjKTp0aGlzLnBvcFVwPyh0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLlNUQVRFX0xPR0lOLFwiXCIpLHRoaXMuX3JlbmV3U3RhdGVzLnB1c2goYSksdGhpcy5yZWdpc3RlckNhbGxiYWNrKGEsdGhpcy5jb25maWcuY2xpZW50SWQsdGhpcy5jYWxsYmFjayksdGhpcy5fbG9naW5Qb3B1cChjKSk6dGhpcy5wcm9tcHRVc2VyKGMpfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9vcGVuUG9wdXA9ZnVuY3Rpb24oYSxiLGMsZCl7dHJ5e3ZhciBlPXdpbmRvdy5zY3JlZW5MZWZ0P3dpbmRvdy5zY3JlZW5MZWZ0OndpbmRvdy5zY3JlZW5YLGY9d2luZG93LnNjcmVlblRvcD93aW5kb3cuc2NyZWVuVG9wOndpbmRvdy5zY3JlZW5ZLGc9d2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aHx8ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCxoPXdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodHx8ZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQsaT1nLzItYy8yK2Usaj1oLzItZC8yK2Ysaz13aW5kb3cub3BlbihhLGIsXCJ3aWR0aD1cIitjK1wiLCBoZWlnaHQ9XCIrZCtcIiwgdG9wPVwiK2orXCIsIGxlZnQ9XCIraSk7cmV0dXJuIGsuZm9jdXMmJmsuZm9jdXMoKSxrfWNhdGNoKGEpe3JldHVybiB0aGlzLndhcm4oXCJFcnJvciBvcGVuaW5nIHBvcHVwLCBcIithLm1lc3NhZ2UpLHRoaXMuX2xvZ2luSW5Qcm9ncmVzcz0hMSx0aGlzLl9hY3F1aXJlVG9rZW5JblByb2dyZXNzPSExLG51bGx9fSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9oYW5kbGVQb3B1cEVycm9yPWZ1bmN0aW9uKGEsYixjLGQsZSl7dGhpcy53YXJuKGQpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuRVJST1IsYyksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5FUlJPUl9ERVNDUklQVElPTixkKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkxPR0lOX0VSUk9SLGUpLGImJnRoaXMuX2FjdGl2ZVJlbmV3YWxzW2JdJiYodGhpcy5fYWN0aXZlUmVuZXdhbHNbYl09bnVsbCksdGhpcy5fbG9naW5JblByb2dyZXNzPSExLHRoaXMuX2FjcXVpcmVUb2tlbkluUHJvZ3Jlc3M9ITEsYSYmYShkLG51bGwsYyl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX2xvZ2luUG9wdXA9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX29wZW5Qb3B1cChhLFwibG9naW5cIix0aGlzLkNPTlNUQU5UUy5QT1BVUF9XSURUSCx0aGlzLkNPTlNUQU5UUy5QT1BVUF9IRUlHSFQpLGU9Y3x8dGhpcy5jYWxsYmFjaztpZihudWxsPT1kKXt2YXIgZj1cIlBvcHVwIFdpbmRvdyBpcyBudWxsLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSB1c2luZyBJRVwiO3JldHVybiB2b2lkIHRoaXMuX2hhbmRsZVBvcHVwRXJyb3IoZSxiLFwiRXJyb3Igb3BlbmluZyBwb3B1cFwiLGYsZil9aWYodGhpcy5fb3BlbmVkV2luZG93cy5wdXNoKGQpLC0xIT10aGlzLmNvbmZpZy5yZWRpcmVjdFVyaS5pbmRleE9mKFwiI1wiKSl2YXIgZz10aGlzLmNvbmZpZy5yZWRpcmVjdFVyaS5zcGxpdChcIiNcIilbMF07ZWxzZSB2YXIgZz10aGlzLmNvbmZpZy5yZWRpcmVjdFVyaTt2YXIgaD10aGlzLGk9d2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uKCl7aWYoIWR8fGQuY2xvc2VkfHx2b2lkIDA9PT1kLmNsb3NlZCl7dmFyIGE9XCJQb3B1cCBXaW5kb3cgY2xvc2VkXCIsYz1cIlBvcHVwIFdpbmRvdyBjbG9zZWQgYnkgVUkgYWN0aW9uLyBQb3B1cCBXaW5kb3cgaGFuZGxlIGRlc3Ryb3llZCBkdWUgdG8gY3Jvc3Mgem9uZSBuYXZpZ2F0aW9uIGluIElFL0VkZ2VcIjtyZXR1cm4gaC5pc0FuZ3VsYXImJmguX2Jyb2FkY2FzdChcImFkYWw6cG9wVXBDbG9zZWRcIixjK2guQ09OU1RBTlRTLlJFU09VUkNFX0RFTElNRVRFUithKSxoLl9oYW5kbGVQb3B1cEVycm9yKGUsYixhLGMsYyksdm9pZCB3aW5kb3cuY2xlYXJJbnRlcnZhbChpKX10cnl7dmFyIGY9ZC5sb2NhdGlvbjtpZigtMSE9ZW5jb2RlVVJJKGYuaHJlZikuaW5kZXhPZihlbmNvZGVVUkkoZykpKXJldHVybiBoLmlzQW5ndWxhcj9oLl9icm9hZGNhc3QoXCJhZGFsOnBvcFVwSGFzaENoYW5nZWRcIixmLmhhc2gpOmguaGFuZGxlV2luZG93Q2FsbGJhY2soZi5oYXNoKSx3aW5kb3cuY2xlYXJJbnRlcnZhbChpKSxoLl9sb2dpbkluUHJvZ3Jlc3M9ITEsaC5fYWNxdWlyZVRva2VuSW5Qcm9ncmVzcz0hMSxoLmluZm8oXCJDbG9zaW5nIHBvcHVwIHdpbmRvd1wiKSxoLl9vcGVuZWRXaW5kb3dzPVtdLHZvaWQgZC5jbG9zZSgpfWNhdGNoKGEpe319LDEpfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9icm9hZGNhc3Q9ZnVuY3Rpb24oYSxiKXshZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYil7Yj1ifHx7YnViYmxlczohMSxjYW5jZWxhYmxlOiExLGRldGFpbDp2b2lkIDB9O3ZhciBjPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7cmV0dXJuIGMuaW5pdEN1c3RvbUV2ZW50KGEsYi5idWJibGVzLGIuY2FuY2VsYWJsZSxiLmRldGFpbCksY31pZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQpcmV0dXJuITE7YS5wcm90b3R5cGU9d2luZG93LkV2ZW50LnByb3RvdHlwZSx3aW5kb3cuQ3VzdG9tRXZlbnQ9YX0oKTt2YXIgYz1uZXcgQ3VzdG9tRXZlbnQoYSx7ZGV0YWlsOmJ9KTt3aW5kb3cuZGlzcGF0Y2hFdmVudChjKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5sb2dpbkluUHJvZ3Jlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbG9naW5JblByb2dyZXNzfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9oYXNSZXNvdXJjZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9nZXRJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuVE9LRU5fS0VZUyk7cmV0dXJuIGImJiF0aGlzLl9pc0VtcHR5KGIpJiZiLmluZGV4T2YoYSt0aGlzLkNPTlNUQU5UUy5SRVNPVVJDRV9ERUxJTUVURVIpPi0xfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLmdldENhY2hlZFRva2VuPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLl9oYXNSZXNvdXJjZShhKSlyZXR1cm4gbnVsbDt2YXIgYj10aGlzLl9nZXRJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuQUNDRVNTX1RPS0VOX0tFWSthKSxjPXRoaXMuX2dldEl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5FWFBJUkFUSU9OX0tFWSthKSxkPXRoaXMuY29uZmlnLmV4cGlyZU9mZnNldFNlY29uZHN8fDMwMDtyZXR1cm4gYyYmYz50aGlzLl9ub3coKStkP2I6KHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuQUNDRVNTX1RPS0VOX0tFWSthLFwiXCIpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuRVhQSVJBVElPTl9LRVkrYSwwKSxudWxsKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5nZXRDYWNoZWRVc2VyPWZ1bmN0aW9uKCl7aWYodGhpcy5fdXNlcilyZXR1cm4gdGhpcy5fdXNlcjt2YXIgYT10aGlzLl9nZXRJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuSURUT0tFTik7cmV0dXJuIHRoaXMuX3VzZXI9dGhpcy5fY3JlYXRlVXNlcihhKSx0aGlzLl91c2VyfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLnJlZ2lzdGVyQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuX2FjdGl2ZVJlbmV3YWxzW2JdPWEsdGhpcy5fY2FsbEJhY2tzTWFwcGVkVG9SZW5ld1N0YXRlc1thXXx8KHRoaXMuX2NhbGxCYWNrc01hcHBlZFRvUmVuZXdTdGF0ZXNbYV09W10pO3ZhciBkPXRoaXM7dGhpcy5fY2FsbEJhY2tzTWFwcGVkVG9SZW5ld1N0YXRlc1thXS5wdXNoKGMpLHRoaXMuX2NhbGxCYWNrTWFwcGVkVG9SZW5ld1N0YXRlc1thXXx8KHRoaXMuX2NhbGxCYWNrTWFwcGVkVG9SZW5ld1N0YXRlc1thXT1mdW5jdGlvbihjLGUsZixnKXtkLl9hY3RpdmVSZW5ld2Fsc1tiXT1udWxsO2Zvcih2YXIgaD0wO2g8ZC5fY2FsbEJhY2tzTWFwcGVkVG9SZW5ld1N0YXRlc1thXS5sZW5ndGg7KytoKXRyeXtkLl9jYWxsQmFja3NNYXBwZWRUb1JlbmV3U3RhdGVzW2FdW2hdKGMsZSxmLGcpfWNhdGNoKGYpe2Qud2FybihmKX1kLl9jYWxsQmFja3NNYXBwZWRUb1JlbmV3U3RhdGVzW2FdPW51bGwsZC5fY2FsbEJhY2tNYXBwZWRUb1JlbmV3U3RhdGVzW2FdPW51bGx9KX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fcmVuZXdUb2tlbj1mdW5jdGlvbihhLGIsYyl7dGhpcy5pbmZvKFwicmVuZXdUb2tlbiBpcyBjYWxsZWQgZm9yIHJlc291cmNlOlwiK2EpO3ZhciBkPXRoaXMuX2FkZEFkYWxGcmFtZShcImFkYWxSZW5ld0ZyYW1lXCIrYSksZT10aGlzLl9ndWlkKCkrXCJ8XCIrYTt0aGlzLmNvbmZpZy5zdGF0ZT1lLHRoaXMuX3JlbmV3U3RhdGVzLnB1c2goZSksdGhpcy52ZXJib3NlKFwiUmVuZXcgdG9rZW4gRXhwZWN0ZWQgc3RhdGU6IFwiK2UpLGM9Y3x8XCJ0b2tlblwiO3ZhciBmPXRoaXMuX3VybFJlbW92ZVF1ZXJ5U3RyaW5nUGFyYW1ldGVyKHRoaXMuX2dldE5hdmlnYXRlVXJsKGMsYSksXCJwcm9tcHRcIik7Yz09PXRoaXMuUkVTUE9OU0VfVFlQRS5JRF9UT0tFTl9UT0tFTiYmKHRoaXMuX2lkVG9rZW5Ob25jZT10aGlzLl9ndWlkKCksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5OT05DRV9JRFRPS0VOLHRoaXMuX2lkVG9rZW5Ob25jZSwhMCksZis9XCImbm9uY2U9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuX2lkVG9rZW5Ob25jZSkpLGYrPVwiJnByb21wdD1ub25lXCIsZj10aGlzLl9hZGRIaW50UGFyYW1ldGVycyhmKSx0aGlzLnJlZ2lzdGVyQ2FsbGJhY2soZSxhLGIpLHRoaXMudmVyYm9zZVBpaShcIk5hdmlnYXRlIHRvOlwiK2YpLGQuc3JjPVwiYWJvdXQ6YmxhbmtcIix0aGlzLl9sb2FkRnJhbWVUaW1lb3V0KGYsXCJhZGFsUmVuZXdGcmFtZVwiK2EsYSl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX3JlbmV3SWRUb2tlbj1mdW5jdGlvbihhLGIpe3RoaXMuaW5mbyhcInJlbmV3SWRUb2tlbiBpcyBjYWxsZWRcIik7dmFyIGM9dGhpcy5fYWRkQWRhbEZyYW1lKFwiYWRhbElkVG9rZW5GcmFtZVwiKSxkPXRoaXMuX2d1aWQoKStcInxcIit0aGlzLmNvbmZpZy5jbGllbnRJZDt0aGlzLl9pZFRva2VuTm9uY2U9dGhpcy5fZ3VpZCgpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuTk9OQ0VfSURUT0tFTix0aGlzLl9pZFRva2VuTm9uY2UsITApLHRoaXMuY29uZmlnLnN0YXRlPWQsdGhpcy5fcmVuZXdTdGF0ZXMucHVzaChkKSx0aGlzLnZlcmJvc2UoXCJSZW5ldyBJZHRva2VuIEV4cGVjdGVkIHN0YXRlOiBcIitkKTt2YXIgZT1udWxsPT09Ynx8dm9pZCAwPT09Yj9udWxsOnRoaXMuY29uZmlnLmNsaWVudElkLGI9Ynx8XCJpZF90b2tlblwiLGY9dGhpcy5fdXJsUmVtb3ZlUXVlcnlTdHJpbmdQYXJhbWV0ZXIodGhpcy5fZ2V0TmF2aWdhdGVVcmwoYixlKSxcInByb21wdFwiKTtmKz1cIiZwcm9tcHQ9bm9uZVwiLGY9dGhpcy5fYWRkSGludFBhcmFtZXRlcnMoZiksZis9XCImbm9uY2U9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuX2lkVG9rZW5Ob25jZSksdGhpcy5yZWdpc3RlckNhbGxiYWNrKGQsdGhpcy5jb25maWcuY2xpZW50SWQsYSksdGhpcy52ZXJib3NlUGlpKFwiTmF2aWdhdGUgdG86XCIrZiksYy5zcmM9XCJhYm91dDpibGFua1wiLHRoaXMuX2xvYWRGcmFtZVRpbWVvdXQoZixcImFkYWxJZFRva2VuRnJhbWVcIix0aGlzLmNvbmZpZy5jbGllbnRJZCl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX3VybENvbnRhaW5zUXVlcnlTdHJpbmdQYXJhbWV0ZXI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IFJlZ0V4cChcIltcXFxcPyZdXCIrYStcIj1cIikudGVzdChiKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fdXJsUmVtb3ZlUXVlcnlTdHJpbmdQYXJhbWV0ZXI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgUmVnRXhwKFwiKFxcXFwmXCIrYitcIj0pW14mXStcIik7cmV0dXJuIGE9YS5yZXBsYWNlKGMsXCJcIiksYz1uZXcgUmVnRXhwKFwiKFwiK2IrXCI9KVteJl0rJlwiKSxhPWEucmVwbGFjZShjLFwiXCIpLGM9bmV3IFJlZ0V4cChcIihcIitiK1wiPSlbXiZdK1wiKSxhPWEucmVwbGFjZShjLFwiXCIpfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9sb2FkRnJhbWVUaW1lb3V0PWZ1bmN0aW9uKGEsYixjKXt0aGlzLnZlcmJvc2UoXCJTZXQgbG9hZGluZyBzdGF0ZSB0byBwZW5kaW5nIGZvcjogXCIrYyksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5SRU5FV19TVEFUVVMrYyx0aGlzLkNPTlNUQU5UUy5UT0tFTl9SRU5FV19TVEFUVVNfSU5fUFJPR1JFU1MpLHRoaXMuX2xvYWRGcmFtZShhLGIpO3ZhciBkPXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe2lmKGQuX2dldEl0ZW0oZC5DT05TVEFOVFMuU1RPUkFHRS5SRU5FV19TVEFUVVMrYyk9PT1kLkNPTlNUQU5UUy5UT0tFTl9SRU5FV19TVEFUVVNfSU5fUFJPR1JFU1Mpe2QudmVyYm9zZShcIkxvYWRpbmcgZnJhbWUgaGFzIHRpbWVkIG91dCBhZnRlcjogXCIrZC5DT05TVEFOVFMuTE9BREZSQU1FX1RJTUVPVVQvMWUzK1wiIHNlY29uZHMgZm9yIHJlc291cmNlIFwiK2MpO3ZhciBhPWQuX2FjdGl2ZVJlbmV3YWxzW2NdO2EmJmQuX2NhbGxCYWNrTWFwcGVkVG9SZW5ld1N0YXRlc1thXSYmZC5fY2FsbEJhY2tNYXBwZWRUb1JlbmV3U3RhdGVzW2FdKFwiVG9rZW4gcmVuZXdhbCBvcGVyYXRpb24gZmFpbGVkIGR1ZSB0byB0aW1lb3V0XCIsbnVsbCxcIlRva2VuIFJlbmV3YWwgRmFpbGVkXCIpLGQuX3NhdmVJdGVtKGQuQ09OU1RBTlRTLlNUT1JBR0UuUkVORVdfU1RBVFVTK2MsZC5DT05TVEFOVFMuVE9LRU5fUkVORVdfU1RBVFVTX0NBTkNFTEVEKX19LGQuQ09OU1RBTlRTLkxPQURGUkFNRV9USU1FT1VUKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fbG9hZEZyYW1lPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztjLmluZm8oXCJMb2FkRnJhbWU6IFwiK2IpO3ZhciBkPWI7c2V0VGltZW91dChmdW5jdGlvbigpe3ZhciBiPWMuX2FkZEFkYWxGcmFtZShkKTtcIlwiIT09Yi5zcmMmJlwiYWJvdXQ6YmxhbmtcIiE9PWIuc3JjfHwoYi5zcmM9YSxjLl9sb2FkRnJhbWUoYSxkKSl9LDUwMCl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuYWNxdWlyZVRva2VuPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5faXNFbXB0eShhKSlyZXR1cm4gdGhpcy53YXJuKFwicmVzb3VyY2UgaXMgcmVxdWlyZWRcIiksdm9pZCBiKFwicmVzb3VyY2UgaXMgcmVxdWlyZWRcIixudWxsLFwicmVzb3VyY2UgaXMgcmVxdWlyZWRcIik7dmFyIGM9dGhpcy5nZXRDYWNoZWRUb2tlbihhKTtyZXR1cm4gYz8odGhpcy5pbmZvKFwiVG9rZW4gaXMgYWxyZWFkeSBpbiBjYWNoZSBmb3IgcmVzb3VyY2U6XCIrYSksdm9pZCBiKG51bGwsYyxudWxsKSk6dGhpcy5fdXNlcnx8dGhpcy5jb25maWcuZXh0cmFRdWVyeVBhcmFtZXRlciYmLTEhPT10aGlzLmNvbmZpZy5leHRyYVF1ZXJ5UGFyYW1ldGVyLmluZGV4T2YoXCJsb2dpbl9oaW50XCIpP3ZvaWQodGhpcy5fYWN0aXZlUmVuZXdhbHNbYV0/dGhpcy5yZWdpc3RlckNhbGxiYWNrKHRoaXMuX2FjdGl2ZVJlbmV3YWxzW2FdLGEsYik6KHRoaXMuX3JlcXVlc3RUeXBlPXRoaXMuUkVRVUVTVF9UWVBFLlJFTkVXX1RPS0VOLGE9PT10aGlzLmNvbmZpZy5jbGllbnRJZD90aGlzLl91c2VyPyh0aGlzLnZlcmJvc2UoXCJyZW5ld2luZyBpZHRva2VuXCIpLHRoaXMuX3JlbmV3SWRUb2tlbihiKSk6KHRoaXMudmVyYm9zZShcInJlbmV3aW5nIGlkdG9rZW4gYW5kIGFjY2Vzc190b2tlblwiKSx0aGlzLl9yZW5ld0lkVG9rZW4oYix0aGlzLlJFU1BPTlNFX1RZUEUuSURfVE9LRU5fVE9LRU4pKTp0aGlzLl91c2VyPyh0aGlzLnZlcmJvc2UoXCJyZW5ld2luZyBhY2Nlc3NfdG9rZW5cIiksdGhpcy5fcmVuZXdUb2tlbihhLGIpKToodGhpcy52ZXJib3NlKFwicmVuZXdpbmcgaWR0b2tlbiBhbmQgYWNjZXNzX3Rva2VuXCIpLHRoaXMuX3JlbmV3VG9rZW4oYSxiLHRoaXMuUkVTUE9OU0VfVFlQRS5JRF9UT0tFTl9UT0tFTikpKSk6KHRoaXMud2FybihcIlVzZXIgbG9naW4gaXMgcmVxdWlyZWRcIiksdm9pZCBiKFwiVXNlciBsb2dpbiBpcyByZXF1aXJlZFwiLG51bGwsXCJsb2dpbiByZXF1aXJlZFwiKSl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuYWNxdWlyZVRva2VuUG9wdXA9ZnVuY3Rpb24oYSxiLGMsZCl7aWYodGhpcy5faXNFbXB0eShhKSlyZXR1cm4gdGhpcy53YXJuKFwicmVzb3VyY2UgaXMgcmVxdWlyZWRcIiksdm9pZCBkKFwicmVzb3VyY2UgaXMgcmVxdWlyZWRcIixudWxsLFwicmVzb3VyY2UgaXMgcmVxdWlyZWRcIik7aWYoIXRoaXMuX3VzZXIpcmV0dXJuIHRoaXMud2FybihcIlVzZXIgbG9naW4gaXMgcmVxdWlyZWRcIiksdm9pZCBkKFwiVXNlciBsb2dpbiBpcyByZXF1aXJlZFwiLG51bGwsXCJsb2dpbiByZXF1aXJlZFwiKTtpZih0aGlzLl9hY3F1aXJlVG9rZW5JblByb2dyZXNzKXJldHVybiB0aGlzLndhcm4oXCJBY3F1aXJlIHRva2VuIGludGVyYWN0aXZlIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiksdm9pZCBkKFwiQWNxdWlyZSB0b2tlbiBpbnRlcmFjdGl2ZSBpcyBhbHJlYWR5IGluIHByb2dyZXNzXCIsbnVsbCxcIkFjcXVpcmUgdG9rZW4gaW50ZXJhY3RpdmUgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1wiKTt2YXIgZT10aGlzLl9ndWlkKCkrXCJ8XCIrYTt0aGlzLmNvbmZpZy5zdGF0ZT1lLHRoaXMuX3JlbmV3U3RhdGVzLnB1c2goZSksdGhpcy5fcmVxdWVzdFR5cGU9dGhpcy5SRVFVRVNUX1RZUEUuUkVORVdfVE9LRU4sdGhpcy52ZXJib3NlKFwiUmVuZXcgdG9rZW4gRXhwZWN0ZWQgc3RhdGU6IFwiK2UpO3ZhciBmPXRoaXMuX3VybFJlbW92ZVF1ZXJ5U3RyaW5nUGFyYW1ldGVyKHRoaXMuX2dldE5hdmlnYXRlVXJsKFwidG9rZW5cIixhKSxcInByb21wdFwiKTtpZihmKz1cIiZwcm9tcHQ9c2VsZWN0X2FjY291bnRcIixiJiYoZis9YiksYyYmLTE9PT1mLmluZGV4T2YoXCImY2xhaW1zXCIpKWYrPVwiJmNsYWltcz1cIitlbmNvZGVVUklDb21wb25lbnQoYyk7ZWxzZSBpZihjJiYtMSE9PWYuaW5kZXhPZihcIiZjbGFpbXNcIikpdGhyb3cgbmV3IEVycm9yKFwiQ2xhaW1zIGNhbm5vdCBiZSBwYXNzZWQgYXMgYW4gZXh0cmFRdWVyeVBhcmFtZXRlclwiKTtmPXRoaXMuX2FkZEhpbnRQYXJhbWV0ZXJzKGYpLHRoaXMuX2FjcXVpcmVUb2tlbkluUHJvZ3Jlc3M9ITAsdGhpcy5pbmZvKFwiYWNxdWlyZVRva2VuIGludGVyYWN0aXZlIGlzIGNhbGxlZCBmb3IgdGhlIHJlc291cmNlIFwiK2EpLHRoaXMucmVnaXN0ZXJDYWxsYmFjayhlLGEsZCksdGhpcy5fbG9naW5Qb3B1cChmLGEsZCl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuYWNxdWlyZVRva2VuUmVkaXJlY3Q9ZnVuY3Rpb24oYSxiLGMpe2lmKHRoaXMuX2lzRW1wdHkoYSkpcmV0dXJuIHRoaXMud2FybihcInJlc291cmNlIGlzIHJlcXVpcmVkXCIpLHZvaWQgZChcInJlc291cmNlIGlzIHJlcXVpcmVkXCIsbnVsbCxcInJlc291cmNlIGlzIHJlcXVpcmVkXCIpO3ZhciBkPXRoaXMuY2FsbGJhY2s7aWYoIXRoaXMuX3VzZXIpcmV0dXJuIHRoaXMud2FybihcIlVzZXIgbG9naW4gaXMgcmVxdWlyZWRcIiksdm9pZCBkKFwiVXNlciBsb2dpbiBpcyByZXF1aXJlZFwiLG51bGwsXCJsb2dpbiByZXF1aXJlZFwiKTtpZih0aGlzLl9hY3F1aXJlVG9rZW5JblByb2dyZXNzKXJldHVybiB0aGlzLndhcm4oXCJBY3F1aXJlIHRva2VuIGludGVyYWN0aXZlIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiksdm9pZCBkKFwiQWNxdWlyZSB0b2tlbiBpbnRlcmFjdGl2ZSBpcyBhbHJlYWR5IGluIHByb2dyZXNzXCIsbnVsbCxcIkFjcXVpcmUgdG9rZW4gaW50ZXJhY3RpdmUgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1wiKTt2YXIgZT10aGlzLl9ndWlkKCkrXCJ8XCIrYTt0aGlzLmNvbmZpZy5zdGF0ZT1lLHRoaXMudmVyYm9zZShcIlJlbmV3IHRva2VuIEV4cGVjdGVkIHN0YXRlOiBcIitlKTt2YXIgZj10aGlzLl91cmxSZW1vdmVRdWVyeVN0cmluZ1BhcmFtZXRlcih0aGlzLl9nZXROYXZpZ2F0ZVVybChcInRva2VuXCIsYSksXCJwcm9tcHRcIik7aWYoZis9XCImcHJvbXB0PXNlbGVjdF9hY2NvdW50XCIsYiYmKGYrPWIpLGMmJi0xPT09Zi5pbmRleE9mKFwiJmNsYWltc1wiKSlmKz1cIiZjbGFpbXM9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGMpO2Vsc2UgaWYoYyYmLTEhPT1mLmluZGV4T2YoXCImY2xhaW1zXCIpKXRocm93IG5ldyBFcnJvcihcIkNsYWltcyBjYW5ub3QgYmUgcGFzc2VkIGFzIGFuIGV4dHJhUXVlcnlQYXJhbWV0ZXJcIik7Zj10aGlzLl9hZGRIaW50UGFyYW1ldGVycyhmKSx0aGlzLl9hY3F1aXJlVG9rZW5JblByb2dyZXNzPSEwLHRoaXMuaW5mbyhcImFjcXVpcmVUb2tlbiBpbnRlcmFjdGl2ZSBpcyBjYWxsZWQgZm9yIHRoZSByZXNvdXJjZSBcIithKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkxPR0lOX1JFUVVFU1Qsd2luZG93LmxvY2F0aW9uLmhyZWYpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuU1RBVEVfUkVORVcsZSwhMCksdGhpcy5wcm9tcHRVc2VyKGYpfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLnByb21wdFVzZXI9ZnVuY3Rpb24oYSl7YT8odGhpcy5pbmZvUGlpKFwiTmF2aWdhdGUgdG86XCIrYSksd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoYSkpOnRoaXMuaW5mbyhcIk5hdmlnYXRlIHVybCBpcyBlbXB0eVwiKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5jbGVhckNhY2hlPWZ1bmN0aW9uKCl7dGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5MT0dJTl9SRVFVRVNULFwiXCIpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuQU5HVUxBUl9MT0dJTl9SRVFVRVNULFwiXCIpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuU0VTU0lPTl9TVEFURSxcIlwiKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLlNUQVRFX0xPR0lOLFwiXCIpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuU1RBVEVfUkVORVcsXCJcIiksdGhpcy5fcmVuZXdTdGF0ZXM9W10sdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5OT05DRV9JRFRPS0VOLFwiXCIpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuSURUT0tFTixcIlwiKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVSUk9SLFwiXCIpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuRVJST1JfREVTQ1JJUFRJT04sXCJcIiksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5MT0dJTl9FUlJPUixcIlwiKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkxPR0lOX0VSUk9SLFwiXCIpO3ZhciBhPXRoaXMuX2dldEl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5UT0tFTl9LRVlTKTtpZighdGhpcy5faXNFbXB0eShhKSl7YT1hLnNwbGl0KHRoaXMuQ09OU1RBTlRTLlJFU09VUkNFX0RFTElNRVRFUik7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aCYmXCJcIiE9PWFbYl07YisrKXRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuQUNDRVNTX1RPS0VOX0tFWSthW2JdLFwiXCIpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuRVhQSVJBVElPTl9LRVkrYVtiXSwwKX10aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLlRPS0VOX0tFWVMsXCJcIil9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuY2xlYXJDYWNoZUZvclJlc291cmNlPWZ1bmN0aW9uKGEpe3RoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuU1RBVEVfUkVORVcsXCJcIiksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5FUlJPUixcIlwiKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVSUk9SX0RFU0NSSVBUSU9OLFwiXCIpLHRoaXMuX2hhc1Jlc291cmNlKGEpJiYodGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5BQ0NFU1NfVE9LRU5fS0VZK2EsXCJcIiksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5FWFBJUkFUSU9OX0tFWSthLDApKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5sb2dPdXQ9ZnVuY3Rpb24oKXt0aGlzLmNsZWFyQ2FjaGUoKSx0aGlzLl91c2VyPW51bGw7dmFyIGE7aWYodGhpcy5jb25maWcubG9nT3V0VXJpKWE9dGhpcy5jb25maWcubG9nT3V0VXJpO2Vsc2V7dmFyIGI9XCJjb21tb25cIixjPVwiXCI7dGhpcy5jb25maWcudGVuYW50JiYoYj10aGlzLmNvbmZpZy50ZW5hbnQpLHRoaXMuY29uZmlnLnBvc3RMb2dvdXRSZWRpcmVjdFVyaSYmKGM9XCJwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuY29uZmlnLnBvc3RMb2dvdXRSZWRpcmVjdFVyaSkpLGE9dGhpcy5pbnN0YW5jZStiK1wiL29hdXRoMi9sb2dvdXQ/XCIrY310aGlzLmluZm9QaWkoXCJMb2dvdXQgbmF2aWdhdGUgdG86IFwiK2EpLHRoaXMucHJvbXB0VXNlcihhKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5faXNFbXB0eT1mdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwPT09YXx8IWF8fDA9PT1hLmxlbmd0aH0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5nZXRVc2VyPWZ1bmN0aW9uKGEpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGEpdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7aWYodGhpcy5fdXNlcilyZXR1cm4gdm9pZCBhKG51bGwsdGhpcy5fdXNlcik7dmFyIGI9dGhpcy5fZ2V0SXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLklEVE9LRU4pO3RoaXMuX2lzRW1wdHkoYik/KHRoaXMud2FybihcIlVzZXIgaW5mb3JtYXRpb24gaXMgbm90IGF2YWlsYWJsZVwiKSxhKFwiVXNlciBpbmZvcm1hdGlvbiBpcyBub3QgYXZhaWxhYmxlXCIsbnVsbCkpOih0aGlzLmluZm8oXCJVc2VyIGV4aXN0cyBpbiBjYWNoZTogXCIpLHRoaXMuX3VzZXI9dGhpcy5fY3JlYXRlVXNlcihiKSxhKG51bGwsdGhpcy5fdXNlcikpfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9hZGRIaW50UGFyYW1ldGVycz1mdW5jdGlvbihhKXtpZih0aGlzLl91c2VyJiZ0aGlzLl91c2VyLnByb2ZpbGUpaWYodGhpcy5fdXNlci5wcm9maWxlLnNpZCYmLTEhPT1hLmluZGV4T2YoXCImcHJvbXB0PW5vbmVcIikpdGhpcy5fdXJsQ29udGFpbnNRdWVyeVN0cmluZ1BhcmFtZXRlcihcInNpZFwiLGEpfHwoYSs9XCImc2lkPVwiK2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLl91c2VyLnByb2ZpbGUuc2lkKSk7ZWxzZSBpZih0aGlzLl91c2VyLnByb2ZpbGUudXBuJiYodGhpcy5fdXJsQ29udGFpbnNRdWVyeVN0cmluZ1BhcmFtZXRlcihcImxvZ2luX2hpbnRcIixhKXx8KGErPVwiJmxvZ2luX2hpbnQ9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuX3VzZXIucHJvZmlsZS51cG4pKSwhdGhpcy5fdXJsQ29udGFpbnNRdWVyeVN0cmluZ1BhcmFtZXRlcihcImRvbWFpbl9oaW50XCIsYSkmJnRoaXMuX3VzZXIucHJvZmlsZS51cG4uaW5kZXhPZihcIkBcIik+LTEpKXt2YXIgYj10aGlzLl91c2VyLnByb2ZpbGUudXBuLnNwbGl0KFwiQFwiKTthKz1cIiZkb21haW5faGludD1cIitlbmNvZGVVUklDb21wb25lbnQoYltiLmxlbmd0aC0xXSl9cmV0dXJuIGF9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX2NyZWF0ZVVzZXI9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbCxjPXRoaXMuX2V4dHJhY3RJZFRva2VuKGEpO3JldHVybiBjJiZjLmhhc093blByb3BlcnR5KFwiYXVkXCIpJiYoYy5hdWQudG9Mb3dlckNhc2UoKT09PXRoaXMuY29uZmlnLmNsaWVudElkLnRvTG93ZXJDYXNlKCk/KGI9e3VzZXJOYW1lOlwiXCIscHJvZmlsZTpjfSxjLmhhc093blByb3BlcnR5KFwidXBuXCIpP2IudXNlck5hbWU9Yy51cG46Yy5oYXNPd25Qcm9wZXJ0eShcImVtYWlsXCIpJiYoYi51c2VyTmFtZT1jLmVtYWlsKSk6dGhpcy53YXJuKFwiSWRUb2tlbiBoYXMgaW52YWxpZCBhdWQgZmllbGRcIikpLGJ9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX2dldEhhc2g9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5kZXhPZihcIiMvXCIpPi0xP2E9YS5zdWJzdHJpbmcoYS5pbmRleE9mKFwiIy9cIikrMik6YS5pbmRleE9mKFwiI1wiKT4tMSYmKGE9YS5zdWJzdHJpbmcoMSkpLGF9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuaXNDYWxsYmFjaz1mdW5jdGlvbihhKXthPXRoaXMuX2dldEhhc2goYSk7dmFyIGI9dGhpcy5fZGVzZXJpYWxpemUoYSk7cmV0dXJuIGIuaGFzT3duUHJvcGVydHkodGhpcy5DT05TVEFOVFMuRVJST1JfREVTQ1JJUFRJT04pfHxiLmhhc093blByb3BlcnR5KHRoaXMuQ09OU1RBTlRTLkFDQ0VTU19UT0tFTil8fGIuaGFzT3duUHJvcGVydHkodGhpcy5DT05TVEFOVFMuSURfVE9LRU4pfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLmdldExvZ2luRXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZ2V0SXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkxPR0lOX0VSUk9SKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5nZXRSZXF1ZXN0SW5mbz1mdW5jdGlvbihhKXthPXRoaXMuX2dldEhhc2goYSk7dmFyIGI9dGhpcy5fZGVzZXJpYWxpemUoYSksYz17dmFsaWQ6ITEscGFyYW1ldGVyczp7fSxzdGF0ZU1hdGNoOiExLHN0YXRlUmVzcG9uc2U6XCJcIixyZXF1ZXN0VHlwZTp0aGlzLlJFUVVFU1RfVFlQRS5VTktOT1dOfTtpZihiJiYoYy5wYXJhbWV0ZXJzPWIsYi5oYXNPd25Qcm9wZXJ0eSh0aGlzLkNPTlNUQU5UUy5FUlJPUl9ERVNDUklQVElPTil8fGIuaGFzT3duUHJvcGVydHkodGhpcy5DT05TVEFOVFMuQUNDRVNTX1RPS0VOKXx8Yi5oYXNPd25Qcm9wZXJ0eSh0aGlzLkNPTlNUQU5UUy5JRF9UT0tFTikpKXtjLnZhbGlkPSEwO3ZhciBkPVwiXCI7aWYoIWIuaGFzT3duUHJvcGVydHkoXCJzdGF0ZVwiKSlyZXR1cm4gdGhpcy53YXJuKFwiTm8gc3RhdGUgcmV0dXJuZWRcIiksYztpZih0aGlzLnZlcmJvc2UoXCJTdGF0ZTogXCIrYi5zdGF0ZSksZD1iLnN0YXRlLGMuc3RhdGVSZXNwb25zZT1kLHRoaXMuX21hdGNoU3RhdGUoYykpcmV0dXJuIGM7aWYoIWMuc3RhdGVNYXRjaCYmd2luZG93LnBhcmVudCl7Yy5yZXF1ZXN0VHlwZT10aGlzLl9yZXF1ZXN0VHlwZTtmb3IodmFyIGU9dGhpcy5fcmVuZXdTdGF0ZXMsZj0wO2Y8ZS5sZW5ndGg7ZisrKWlmKGVbZl09PT1jLnN0YXRlUmVzcG9uc2Upe2Muc3RhdGVNYXRjaD0hMDticmVha319fXJldHVybiBjfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9tYXRjaE5vbmNlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2dldEl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5OT05DRV9JRFRPS0VOKTtpZihiKXtiPWIuc3BsaXQodGhpcy5DT05TVEFOVFMuQ0FDSEVfREVMSU1FVEVSKTtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKylpZihiW2NdPT09YS5wcm9maWxlLm5vbmNlKXJldHVybiEwfXJldHVybiExfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9tYXRjaFN0YXRlPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2dldEl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5TVEFURV9MT0dJTik7aWYoYil7Yj1iLnNwbGl0KHRoaXMuQ09OU1RBTlRTLkNBQ0hFX0RFTElNRVRFUik7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspaWYoYltjXT09PWEuc3RhdGVSZXNwb25zZSlyZXR1cm4gYS5yZXF1ZXN0VHlwZT10aGlzLlJFUVVFU1RfVFlQRS5MT0dJTixhLnN0YXRlTWF0Y2g9ITAsITB9dmFyIGQ9dGhpcy5fZ2V0SXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLlNUQVRFX1JFTkVXKTtpZihkKXtkPWQuc3BsaXQodGhpcy5DT05TVEFOVFMuQ0FDSEVfREVMSU1FVEVSKTtmb3IodmFyIGM9MDtjPGQubGVuZ3RoO2MrKylpZihkW2NdPT09YS5zdGF0ZVJlc3BvbnNlKXJldHVybiBhLnJlcXVlc3RUeXBlPXRoaXMuUkVRVUVTVF9UWVBFLlJFTkVXX1RPS0VOLGEuc3RhdGVNYXRjaD0hMCwhMH1yZXR1cm4hMX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fZ2V0UmVzb3VyY2VGcm9tU3RhdGU9ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGI9YS5pbmRleE9mKFwifFwiKTtpZihiPi0xJiZiKzE8YS5sZW5ndGgpcmV0dXJuIGEuc3Vic3RyaW5nKGIrMSl9cmV0dXJuXCJcIn0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5zYXZlVG9rZW5Gcm9tSGFzaD1mdW5jdGlvbihhKXt0aGlzLmluZm8oXCJTdGF0ZSBzdGF0dXM6XCIrYS5zdGF0ZU1hdGNoK1wiOyBSZXF1ZXN0IHR5cGU6XCIrYS5yZXF1ZXN0VHlwZSksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5FUlJPUixcIlwiKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVSUk9SX0RFU0NSSVBUSU9OLFwiXCIpO3ZhciBiPXRoaXMuX2dldFJlc291cmNlRnJvbVN0YXRlKGEuc3RhdGVSZXNwb25zZSk7aWYoYS5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KHRoaXMuQ09OU1RBTlRTLkVSUk9SX0RFU0NSSVBUSU9OKSl0aGlzLmluZm9QaWkoXCJFcnJvciA6XCIrYS5wYXJhbWV0ZXJzLmVycm9yK1wiOyBFcnJvciBkZXNjcmlwdGlvbjpcIithLnBhcmFtZXRlcnNbdGhpcy5DT05TVEFOVFMuRVJST1JfREVTQ1JJUFRJT05dKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVSUk9SLGEucGFyYW1ldGVycy5lcnJvciksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5FUlJPUl9ERVNDUklQVElPTixhLnBhcmFtZXRlcnNbdGhpcy5DT05TVEFOVFMuRVJST1JfREVTQ1JJUFRJT05dKSxhLnJlcXVlc3RUeXBlPT09dGhpcy5SRVFVRVNUX1RZUEUuTE9HSU4mJih0aGlzLl9sb2dpbkluUHJvZ3Jlc3M9ITEsdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5MT0dJTl9FUlJPUixhLnBhcmFtZXRlcnMuZXJyb3JfZGVzY3JpcHRpb24pKTtlbHNlIGlmKGEuc3RhdGVNYXRjaCl7dGhpcy5pbmZvKFwiU3RhdGUgaXMgcmlnaHRcIiksYS5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KHRoaXMuQ09OU1RBTlRTLlNFU1NJT05fU1RBVEUpJiZ0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLlNFU1NJT05fU1RBVEUsYS5wYXJhbWV0ZXJzW3RoaXMuQ09OU1RBTlRTLlNFU1NJT05fU1RBVEVdKTt2YXIgYzthLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkodGhpcy5DT05TVEFOVFMuQUNDRVNTX1RPS0VOKSYmKHRoaXMuaW5mbyhcIkZyYWdtZW50IGhhcyBhY2Nlc3MgdG9rZW5cIiksdGhpcy5faGFzUmVzb3VyY2UoYil8fChjPXRoaXMuX2dldEl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5UT0tFTl9LRVlTKXx8XCJcIix0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLlRPS0VOX0tFWVMsYytiK3RoaXMuQ09OU1RBTlRTLlJFU09VUkNFX0RFTElNRVRFUikpLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuQUNDRVNTX1RPS0VOX0tFWStiLGEucGFyYW1ldGVyc1t0aGlzLkNPTlNUQU5UUy5BQ0NFU1NfVE9LRU5dKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVYUElSQVRJT05fS0VZK2IsdGhpcy5fZXhwaXJlc0luKGEucGFyYW1ldGVyc1t0aGlzLkNPTlNUQU5UUy5FWFBJUkVTX0lOXSkpKSxhLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkodGhpcy5DT05TVEFOVFMuSURfVE9LRU4pJiYodGhpcy5pbmZvKFwiRnJhZ21lbnQgaGFzIGlkIHRva2VuXCIpLHRoaXMuX2xvZ2luSW5Qcm9ncmVzcz0hMSx0aGlzLl91c2VyPXRoaXMuX2NyZWF0ZVVzZXIoYS5wYXJhbWV0ZXJzW3RoaXMuQ09OU1RBTlRTLklEX1RPS0VOXSksdGhpcy5fdXNlciYmdGhpcy5fdXNlci5wcm9maWxlP3RoaXMuX21hdGNoTm9uY2UodGhpcy5fdXNlcik/KHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuSURUT0tFTixhLnBhcmFtZXRlcnNbdGhpcy5DT05TVEFOVFMuSURfVE9LRU5dKSxiPXRoaXMuY29uZmlnLmxvZ2luUmVzb3VyY2U/dGhpcy5jb25maWcubG9naW5SZXNvdXJjZTp0aGlzLmNvbmZpZy5jbGllbnRJZCx0aGlzLl9oYXNSZXNvdXJjZShiKXx8KGM9dGhpcy5fZ2V0SXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLlRPS0VOX0tFWVMpfHxcIlwiLHRoaXMuX3NhdmVJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuVE9LRU5fS0VZUyxjK2IrdGhpcy5DT05TVEFOVFMuUkVTT1VSQ0VfREVMSU1FVEVSKSksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5BQ0NFU1NfVE9LRU5fS0VZK2IsYS5wYXJhbWV0ZXJzW3RoaXMuQ09OU1RBTlRTLklEX1RPS0VOXSksdGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5FWFBJUkFUSU9OX0tFWStiLHRoaXMuX3VzZXIucHJvZmlsZS5leHApKToodGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5MT0dJTl9FUlJPUixcIk5vbmNlIHJlY2VpdmVkOiBcIit0aGlzLl91c2VyLnByb2ZpbGUubm9uY2UrXCIgaXMgbm90IHNhbWUgYXMgcmVxdWVzdGVkOiBcIit0aGlzLl9nZXRJdGVtKHRoaXMuQ09OU1RBTlRTLlNUT1JBR0UuTk9OQ0VfSURUT0tFTikpLHRoaXMuX3VzZXI9bnVsbCk6KGEucGFyYW1ldGVycy5lcnJvcj1cImludmFsaWQgaWRfdG9rZW5cIixhLnBhcmFtZXRlcnMuZXJyb3JfZGVzY3JpcHRpb249XCJJbnZhbGlkIGlkX3Rva2VuLiBpZF90b2tlbjogXCIrYS5wYXJhbWV0ZXJzW3RoaXMuQ09OU1RBTlRTLklEX1RPS0VOXSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVSUk9SLFwiaW52YWxpZCBpZF90b2tlblwiKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVSUk9SX0RFU0NSSVBUSU9OLFwiSW52YWxpZCBpZF90b2tlbi4gaWRfdG9rZW46IFwiK2EucGFyYW1ldGVyc1t0aGlzLkNPTlNUQU5UUy5JRF9UT0tFTl0pKSl9ZWxzZSBhLnBhcmFtZXRlcnMuZXJyb3I9XCJJbnZhbGlkX3N0YXRlXCIsYS5wYXJhbWV0ZXJzLmVycm9yX2Rlc2NyaXB0aW9uPVwiSW52YWxpZF9zdGF0ZS4gc3RhdGU6IFwiK2Euc3RhdGVSZXNwb25zZSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVSUk9SLFwiSW52YWxpZF9zdGF0ZVwiKSx0aGlzLl9zYXZlSXRlbSh0aGlzLkNPTlNUQU5UUy5TVE9SQUdFLkVSUk9SX0RFU0NSSVBUSU9OLFwiSW52YWxpZF9zdGF0ZS4gc3RhdGU6IFwiK2Euc3RhdGVSZXNwb25zZSk7dGhpcy5fc2F2ZUl0ZW0odGhpcy5DT05TVEFOVFMuU1RPUkFHRS5SRU5FV19TVEFUVVMrYix0aGlzLkNPTlNUQU5UUy5UT0tFTl9SRU5FV19TVEFUVVNfQ09NUExFVEVEKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5nZXRSZXNvdXJjZUZvckVuZHBvaW50PWZ1bmN0aW9uKGEpe2lmKHRoaXMuY29uZmlnJiZ0aGlzLmNvbmZpZy5hbm9ueW1vdXNFbmRwb2ludHMpZm9yKHZhciBiPTA7Yjx0aGlzLmNvbmZpZy5hbm9ueW1vdXNFbmRwb2ludHMubGVuZ3RoO2IrKylpZihhLmluZGV4T2YodGhpcy5jb25maWcuYW5vbnltb3VzRW5kcG9pbnRzW2JdKT4tMSlyZXR1cm4gbnVsbDtpZih0aGlzLmNvbmZpZyYmdGhpcy5jb25maWcuZW5kcG9pbnRzKWZvcih2YXIgYyBpbiB0aGlzLmNvbmZpZy5lbmRwb2ludHMpaWYoYS5pbmRleE9mKGMpPi0xKXJldHVybiB0aGlzLmNvbmZpZy5lbmRwb2ludHNbY107cmV0dXJuIGEuaW5kZXhPZihcImh0dHA6Ly9cIik+LTF8fGEuaW5kZXhPZihcImh0dHBzOi8vXCIpPi0xP3RoaXMuX2dldEhvc3RGcm9tVXJpKGEpPT09dGhpcy5fZ2V0SG9zdEZyb21VcmkodGhpcy5jb25maWcucmVkaXJlY3RVcmkpP3RoaXMuY29uZmlnLmxvZ2luUmVzb3VyY2U6bnVsbDp0aGlzLmNvbmZpZy5sb2dpblJlc291cmNlfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9nZXRIb3N0RnJvbVVyaT1mdW5jdGlvbihhKXt2YXIgYj1TdHJpbmcoYSkucmVwbGFjZSgvXihodHRwcz86KVxcL1xcLy8sXCJcIik7cmV0dXJuIGI9Yi5zcGxpdChcIi9cIilbMF19LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuaGFuZGxlV2luZG93Q2FsbGJhY2s9ZnVuY3Rpb24oYSl7aWYobnVsbD09YSYmKGE9d2luZG93LmxvY2F0aW9uLmhhc2gpLHRoaXMuaXNDYWxsYmFjayhhKSl7dmFyIGI9bnVsbCxjPSExO3RoaXMuX29wZW5lZFdpbmRvd3MubGVuZ3RoPjAmJnRoaXMuX29wZW5lZFdpbmRvd3NbdGhpcy5fb3BlbmVkV2luZG93cy5sZW5ndGgtMV0ub3BlbmVyJiZ0aGlzLl9vcGVuZWRXaW5kb3dzW3RoaXMuX29wZW5lZFdpbmRvd3MubGVuZ3RoLTFdLm9wZW5lci5fYWRhbEluc3RhbmNlPyhiPXRoaXMuX29wZW5lZFdpbmRvd3NbdGhpcy5fb3BlbmVkV2luZG93cy5sZW5ndGgtMV0ub3BlbmVyLl9hZGFsSW5zdGFuY2UsYz0hMCk6d2luZG93LnBhcmVudCYmd2luZG93LnBhcmVudC5fYWRhbEluc3RhbmNlJiYoYj13aW5kb3cucGFyZW50Ll9hZGFsSW5zdGFuY2UpO3ZhciBkLGUsZj1iLmdldFJlcXVlc3RJbmZvKGEpLGc9bnVsbDtlPWN8fHdpbmRvdy5wYXJlbnQhPT13aW5kb3c/Yi5fY2FsbEJhY2tNYXBwZWRUb1JlbmV3U3RhdGVzW2Yuc3RhdGVSZXNwb25zZV06Yi5jYWxsYmFjayxiLmluZm8oXCJSZXR1cm5lZCBmcm9tIHJlZGlyZWN0IHVybFwiKSxiLnNhdmVUb2tlbkZyb21IYXNoKGYpLGYucmVxdWVzdFR5cGU9PT10aGlzLlJFUVVFU1RfVFlQRS5SRU5FV19UT0tFTiYmd2luZG93LnBhcmVudD8od2luZG93LnBhcmVudCE9PXdpbmRvdz9iLnZlcmJvc2UoXCJXaW5kb3cgaXMgaW4gaWZyYW1lLCBhY3F1aXJpbmcgdG9rZW4gc2lsZW50bHlcIik6Yi52ZXJib3NlKFwiYWNxdWlyaW5nIHRva2VuIGludGVyYWN0aXZlIGluIHByb2dyZXNzXCIpLGQ9Zi5wYXJhbWV0ZXJzW2IuQ09OU1RBTlRTLkFDQ0VTU19UT0tFTl18fGYucGFyYW1ldGVyc1tiLkNPTlNUQU5UUy5JRF9UT0tFTl0sZz1iLkNPTlNUQU5UUy5BQ0NFU1NfVE9LRU4pOmYucmVxdWVzdFR5cGU9PT10aGlzLlJFUVVFU1RfVFlQRS5MT0dJTiYmKGQ9Zi5wYXJhbWV0ZXJzW2IuQ09OU1RBTlRTLklEX1RPS0VOXSxnPWIuQ09OU1RBTlRTLklEX1RPS0VOKTt2YXIgaD1mLnBhcmFtZXRlcnNbYi5DT05TVEFOVFMuRVJST1JfREVTQ1JJUFRJT05dLGk9Zi5wYXJhbWV0ZXJzW2IuQ09OU1RBTlRTLkVSUk9SXTt0cnl7ZSYmZShoLGQsaSxnKX1jYXRjaChhKXtiLmVycm9yKFwiRXJyb3Igb2NjdXJyZWQgaW4gdXNlciBkZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9uOiBcIithKX13aW5kb3cucGFyZW50IT09d2luZG93fHxjfHwoYi5jb25maWcubmF2aWdhdGVUb0xvZ2luUmVxdWVzdFVybD93aW5kb3cubG9jYXRpb24uaHJlZj1iLl9nZXRJdGVtKGIuQ09OU1RBTlRTLlNUT1JBR0UuTE9HSU5fUkVRVUVTVCk6d2luZG93LmxvY2F0aW9uLmhhc2g9XCJcIil9fSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9nZXROYXZpZ2F0ZVVybD1mdW5jdGlvbihhLGIpe3ZhciBjPVwiY29tbW9uXCI7dGhpcy5jb25maWcudGVuYW50JiYoYz10aGlzLmNvbmZpZy50ZW5hbnQpO3ZhciBkPXRoaXMuaW5zdGFuY2UrYytcIi9vYXV0aDIvYXV0aG9yaXplXCIrdGhpcy5fc2VyaWFsaXplKGEsdGhpcy5jb25maWcsYikrdGhpcy5fYWRkTGliTWV0YWRhdGEoKTtyZXR1cm4gdGhpcy5pbmZvKFwiTmF2aWdhdGUgdXJsOlwiK2QpLGR9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX2V4dHJhY3RJZFRva2VuPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2RlY29kZUp3dChhKTtpZighYilyZXR1cm4gbnVsbDt0cnl7dmFyIGM9Yi5KV1NQYXlsb2FkLGQ9dGhpcy5fYmFzZTY0RGVjb2RlU3RyaW5nVXJsU2FmZShjKTtyZXR1cm4gZD9KU09OLnBhcnNlKGQpOih0aGlzLmluZm8oXCJUaGUgcmV0dXJuZWQgaWRfdG9rZW4gY291bGQgbm90IGJlIGJhc2U2NCB1cmwgc2FmZSBkZWNvZGVkLlwiKSxudWxsKX1jYXRjaChhKXt0aGlzLmVycm9yKFwiVGhlIHJldHVybmVkIGlkX3Rva2VuIGNvdWxkIG5vdCBiZSBkZWNvZGVkXCIsYSl9cmV0dXJuIG51bGx9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX2Jhc2U2NERlY29kZVN0cmluZ1VybFNhZmU9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9YS5yZXBsYWNlKC8tL2csXCIrXCIpLnJlcGxhY2UoL18vZyxcIi9cIiksd2luZG93LmF0b2I/ZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh3aW5kb3cuYXRvYihhKSkpOmRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUodGhpcy5fZGVjb2RlKGEpKSl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX2RlY29kZT1mdW5jdGlvbihhKXt2YXIgYj1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7YT1TdHJpbmcoYSkucmVwbGFjZSgvPSskLyxcIlwiKTt2YXIgYz1hLmxlbmd0aDtpZihjJTQ9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRva2VuIHRvIGJlIGRlY29kZWQgaXMgbm90IGNvcnJlY3RseSBlbmNvZGVkLlwiKTtmb3IodmFyIGQsZSxmLGcsaCxpLGosayxsPVwiXCIsbT0wO208YzttKz00KXtpZihkPWIuaW5kZXhPZihhLmNoYXJBdChtKSksZT1iLmluZGV4T2YoYS5jaGFyQXQobSsxKSksZj1iLmluZGV4T2YoYS5jaGFyQXQobSsyKSksZz1iLmluZGV4T2YoYS5jaGFyQXQobSszKSksbSsyPT09Yy0xKXtoPWQ8PDE4fGU8PDEyfGY8PDYsaT1oPj4xNiYyNTUsaj1oPj44JjI1NSxsKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGksaik7YnJlYWt9aWYobSsxPT09Yy0xKXtoPWQ8PDE4fGU8PDEyLGk9aD4+MTYmMjU1LGwrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSk7YnJlYWt9aD1kPDwxOHxlPDwxMnxmPDw2fGcsaT1oPj4xNiYyNTUsaj1oPj44JjI1NSxrPTI1NSZoLGwrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSxqLGspfXJldHVybiBsfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9kZWNvZGVKd3Q9ZnVuY3Rpb24oYSl7aWYodGhpcy5faXNFbXB0eShhKSlyZXR1cm4gbnVsbDt2YXIgYj0vXihbXlxcLlxcc10qKVxcLihbXlxcLlxcc10rKVxcLihbXlxcLlxcc10qKSQvLGM9Yi5leGVjKGEpO3JldHVybiFjfHxjLmxlbmd0aDw0Pyh0aGlzLndhcm4oXCJUaGUgcmV0dXJuZWQgaWRfdG9rZW4gaXMgbm90IHBhcnNlYWJsZS5cIiksbnVsbCk6e2hlYWRlcjpjWzFdLEpXU1BheWxvYWQ6Y1syXSxKV1NTaWc6Y1szXX19LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX2NvbnZlcnRVcmxTYWZlVG9SZWd1bGFyQmFzZTY0RW5jb2RlZFN0cmluZz1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKFwiLVwiLFwiK1wiKS5yZXBsYWNlKFwiX1wiLFwiL1wiKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fc2VyaWFsaXplPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1bXTtpZihudWxsIT09Yil7ZC5wdXNoKFwiP3Jlc3BvbnNlX3R5cGU9XCIrYSksZC5wdXNoKFwiY2xpZW50X2lkPVwiK2VuY29kZVVSSUNvbXBvbmVudChiLmNsaWVudElkKSksYyYmZC5wdXNoKFwicmVzb3VyY2U9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGMpKSxkLnB1c2goXCJyZWRpcmVjdF91cmk9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGIucmVkaXJlY3RVcmkpKSxkLnB1c2goXCJzdGF0ZT1cIitlbmNvZGVVUklDb21wb25lbnQoYi5zdGF0ZSkpLGIuaGFzT3duUHJvcGVydHkoXCJzbGljZVwiKSYmZC5wdXNoKFwic2xpY2U9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGIuc2xpY2UpKSxiLmhhc093blByb3BlcnR5KFwiZXh0cmFRdWVyeVBhcmFtZXRlclwiKSYmZC5wdXNoKGIuZXh0cmFRdWVyeVBhcmFtZXRlcik7dmFyIGU9Yi5jb3JyZWxhdGlvbklkP2IuY29ycmVsYXRpb25JZDp0aGlzLl9ndWlkKCk7ZC5wdXNoKFwiY2xpZW50LXJlcXVlc3QtaWQ9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGUpKX1yZXR1cm4gZC5qb2luKFwiJlwiKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fZGVzZXJpYWxpemU9ZnVuY3Rpb24oYSl7dmFyIGIsYz0vXFwrL2csZD0vKFteJj1dKyk9KFteJl0qKS9nLGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChhLnJlcGxhY2UoYyxcIiBcIikpfSxmPXt9O2ZvcihiPWQuZXhlYyhhKTtiOylmW2UoYlsxXSldPWUoYlsyXSksYj1kLmV4ZWMoYSk7cmV0dXJuIGZ9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX2RlY2ltYWxUb0hleD1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS50b1N0cmluZygxNik7Yi5sZW5ndGg8MjspYj1cIjBcIitiO3JldHVybiBifSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9ndWlkPWZ1bmN0aW9uKCl7dmFyIGE9d2luZG93LmNyeXB0b3x8d2luZG93Lm1zQ3J5cHRvO2lmKGEmJmEuZ2V0UmFuZG9tVmFsdWVzKXt2YXIgYj1uZXcgVWludDhBcnJheSgxNik7cmV0dXJuIGEuZ2V0UmFuZG9tVmFsdWVzKGIpLGJbNl18PTY0LGJbNl0mPTc5LGJbOF18PTEyOCxiWzhdJj0xOTEsdGhpcy5fZGVjaW1hbFRvSGV4KGJbMF0pK3RoaXMuX2RlY2ltYWxUb0hleChiWzFdKSt0aGlzLl9kZWNpbWFsVG9IZXgoYlsyXSkrdGhpcy5fZGVjaW1hbFRvSGV4KGJbM10pK1wiLVwiK3RoaXMuX2RlY2ltYWxUb0hleChiWzRdKSt0aGlzLl9kZWNpbWFsVG9IZXgoYls1XSkrXCItXCIrdGhpcy5fZGVjaW1hbFRvSGV4KGJbNl0pK3RoaXMuX2RlY2ltYWxUb0hleChiWzddKStcIi1cIit0aGlzLl9kZWNpbWFsVG9IZXgoYls4XSkrdGhpcy5fZGVjaW1hbFRvSGV4KGJbOV0pK1wiLVwiK3RoaXMuX2RlY2ltYWxUb0hleChiWzEwXSkrdGhpcy5fZGVjaW1hbFRvSGV4KGJbMTFdKSt0aGlzLl9kZWNpbWFsVG9IZXgoYlsxMl0pK3RoaXMuX2RlY2ltYWxUb0hleChiWzEzXSkrdGhpcy5fZGVjaW1hbFRvSGV4KGJbMTRdKSt0aGlzLl9kZWNpbWFsVG9IZXgoYlsxNV0pfWZvcih2YXIgYz1cInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLGQ9XCIwMTIzNDU2Nzg5YWJjZGVmXCIsZT0wLGY9XCJcIixnPTA7ZzwzNjtnKyspXCItXCIhPT1jW2ddJiZcIjRcIiE9PWNbZ10mJihlPTE2Kk1hdGgucmFuZG9tKCl8MCksXCJ4XCI9PT1jW2ddP2YrPWRbZV06XCJ5XCI9PT1jW2ddPyhlJj0zLGV8PTgsZis9ZFtlXSk6Zis9Y1tnXTtyZXR1cm4gZn0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fZXhwaXJlc0luPWZ1bmN0aW9uKGEpe3JldHVybiBhfHwoYT0zNTk5KSx0aGlzLl9ub3coKStwYXJzZUludChhLDEwKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fbm93PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgucm91bmQoKG5ldyBEYXRlKS5nZXRUaW1lKCkvMWUzKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fYWRkQWRhbEZyYW1lPWZ1bmN0aW9uKGEpe2lmKHZvaWQgMCE9PWEpe3RoaXMuaW5mbyhcIkFkZCBhZGFsIGZyYW1lIHRvIGRvY3VtZW50OlwiK2EpO3ZhciBiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2lmKCFiKXtpZihkb2N1bWVudC5jcmVhdGVFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJih3aW5kb3cub3BlcmF8fC0xPT09d2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgNS4wXCIpKSl7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtjLnNldEF0dHJpYnV0ZShcImlkXCIsYSksYy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKSxjLnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIixjLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixjLnN0eWxlLndpZHRoPWMuc3R5bGUuaGVpZ2h0PWMuYm9yZGVyV2lkdGg9XCIwcHhcIixiPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXS5hcHBlbmRDaGlsZChjKX1lbHNlIGRvY3VtZW50LmJvZHkmJmRvY3VtZW50LmJvZHkuaW5zZXJ0QWRqYWNlbnRIVE1MJiZkb2N1bWVudC5ib2R5Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZUVuZFwiLCc8aWZyYW1lIG5hbWU9XCInK2ErJ1wiIGlkPVwiJythKydcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPjwvaWZyYW1lPicpO3dpbmRvdy5mcmFtZXMmJndpbmRvdy5mcmFtZXNbYV0mJihiPXdpbmRvdy5mcmFtZXNbYV0pfXJldHVybiBifX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fc2F2ZUl0ZW09ZnVuY3Rpb24oYSxiLGMpe2lmKHRoaXMuY29uZmlnJiZ0aGlzLmNvbmZpZy5jYWNoZUxvY2F0aW9uJiZcImxvY2FsU3RvcmFnZVwiPT09dGhpcy5jb25maWcuY2FjaGVMb2NhdGlvbil7aWYoIXRoaXMuX3N1cHBvcnRzTG9jYWxTdG9yYWdlKCkpcmV0dXJuIHRoaXMuaW5mbyhcIkxvY2FsIHN0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZFwiKSwhMTtpZihjKXt2YXIgZD10aGlzLl9nZXRJdGVtKGEpfHxcIlwiO2xvY2FsU3RvcmFnZS5zZXRJdGVtKGEsZCtiK3RoaXMuQ09OU1RBTlRTLkNBQ0hFX0RFTElNRVRFUil9ZWxzZSBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhLGIpO3JldHVybiEwfXJldHVybiB0aGlzLl9zdXBwb3J0c1Nlc3Npb25TdG9yYWdlKCk/KHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oYSxiKSwhMCk6KHRoaXMuaW5mbyhcIlNlc3Npb24gc3RvcmFnZSBpcyBub3Qgc3VwcG9ydGVkXCIpLCExKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fZ2V0SXRlbT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jb25maWcmJnRoaXMuY29uZmlnLmNhY2hlTG9jYXRpb24mJlwibG9jYWxTdG9yYWdlXCI9PT10aGlzLmNvbmZpZy5jYWNoZUxvY2F0aW9uP3RoaXMuX3N1cHBvcnRzTG9jYWxTdG9yYWdlKCk/bG9jYWxTdG9yYWdlLmdldEl0ZW0oYSk6KHRoaXMuaW5mbyhcIkxvY2FsIHN0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZFwiKSxudWxsKTp0aGlzLl9zdXBwb3J0c1Nlc3Npb25TdG9yYWdlKCk/c2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShhKToodGhpcy5pbmZvKFwiU2Vzc2lvbiBzdG9yYWdlIGlzIG5vdCBzdXBwb3J0ZWRcIiksbnVsbCl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX3N1cHBvcnRzTG9jYWxTdG9yYWdlPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiEhd2luZG93LmxvY2FsU3RvcmFnZSYmKHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInN0b3JhZ2VUZXN0XCIsXCJBXCIpLFwiQVwiPT13aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdG9yYWdlVGVzdFwiKSYmKHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInN0b3JhZ2VUZXN0XCIpLCF3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzdG9yYWdlVGVzdFwiKSkpfWNhdGNoKGEpe3JldHVybiExfX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fc3VwcG9ydHNTZXNzaW9uU3RvcmFnZT1mdW5jdGlvbigpe3RyeXtyZXR1cm4hIXdpbmRvdy5zZXNzaW9uU3RvcmFnZSYmKHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwic3RvcmFnZVRlc3RcIixcIkFcIiksXCJBXCI9PXdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwic3RvcmFnZVRlc3RcIikmJih3aW5kb3cuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShcInN0b3JhZ2VUZXN0XCIpLCF3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcInN0b3JhZ2VUZXN0XCIpKSl9Y2F0Y2goYSl7cmV0dXJuITF9fSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLl9jbG9uZUNvbmZpZz1mdW5jdGlvbihhKXtpZihudWxsPT09YXx8XCJvYmplY3RcIiE9dHlwZW9mIGEpcmV0dXJuIGE7dmFyIGI9e307Zm9yKHZhciBjIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShjKSYmKGJbY109YVtjXSk7cmV0dXJuIGJ9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuX2FkZExpYk1ldGFkYXRhPWZ1bmN0aW9uKCl7cmV0dXJuXCImeC1jbGllbnQtU0tVPUpzJngtY2xpZW50LVZlcj1cIit0aGlzLl9saWJWZXJzaW9uKCl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKGEsYixjLGQpe2lmKGE8PUxvZ2dpbmcubGV2ZWwpe2lmKCFMb2dnaW5nLnBpaUxvZ2dpbmdFbmFibGVkJiZkKXJldHVybjt2YXIgZT0obmV3IERhdGUpLnRvVVRDU3RyaW5nKCksZj1cIlwiO2Y9dGhpcy5jb25maWcuY29ycmVsYXRpb25JZD9lK1wiOlwiK3RoaXMuY29uZmlnLmNvcnJlbGF0aW9uSWQrXCItXCIrdGhpcy5fbGliVmVyc2lvbigpK1wiLVwiK3RoaXMuQ09OU1RBTlRTLkxFVkVMX1NUUklOR19NQVBbYV0rXCIgXCIrYjplK1wiOlwiK3RoaXMuX2xpYlZlcnNpb24oKStcIi1cIit0aGlzLkNPTlNUQU5UUy5MRVZFTF9TVFJJTkdfTUFQW2FdK1wiIFwiK2IsYyYmKGYrPVwiXFxuc3RhY2s6XFxuXCIrYy5zdGFjayksTG9nZ2luZy5sb2coZil9fSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLmVycm9yPWZ1bmN0aW9uKGEsYil7dGhpcy5sb2codGhpcy5DT05TVEFOVFMuTE9HR0lOR19MRVZFTC5FUlJPUixhLGIpfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLndhcm49ZnVuY3Rpb24oYSl7dGhpcy5sb2codGhpcy5DT05TVEFOVFMuTE9HR0lOR19MRVZFTC5XQVJOLGEsbnVsbCl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUuaW5mbz1mdW5jdGlvbihhKXtcclxudGhpcy5sb2codGhpcy5DT05TVEFOVFMuTE9HR0lOR19MRVZFTC5JTkZPLGEsbnVsbCl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUudmVyYm9zZT1mdW5jdGlvbihhKXt0aGlzLmxvZyh0aGlzLkNPTlNUQU5UUy5MT0dHSU5HX0xFVkVMLlZFUkJPU0UsYSxudWxsKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5lcnJvclBpaT1mdW5jdGlvbihhLGIpe3RoaXMubG9nKHRoaXMuQ09OU1RBTlRTLkxPR0dJTkdfTEVWRUwuRVJST1IsYSxiLCEwKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS53YXJuUGlpPWZ1bmN0aW9uKGEpe3RoaXMubG9nKHRoaXMuQ09OU1RBTlRTLkxPR0dJTkdfTEVWRUwuV0FSTixhLG51bGwsITApfSxBdXRoZW50aWNhdGlvbkNvbnRleHQucHJvdG90eXBlLmluZm9QaWk9ZnVuY3Rpb24oYSl7dGhpcy5sb2codGhpcy5DT05TVEFOVFMuTE9HR0lOR19MRVZFTC5JTkZPLGEsbnVsbCwhMCl9LEF1dGhlbnRpY2F0aW9uQ29udGV4dC5wcm90b3R5cGUudmVyYm9zZVBpaT1mdW5jdGlvbihhKXt0aGlzLmxvZyh0aGlzLkNPTlNUQU5UUy5MT0dHSU5HX0xFVkVMLlZFUkJPU0UsYSxudWxsLCEwKX0sQXV0aGVudGljYXRpb25Db250ZXh0LnByb3RvdHlwZS5fbGliVmVyc2lvbj1mdW5jdGlvbigpe3JldHVyblwiMS4wLjE3XCJ9LFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzJiYobW9kdWxlLmV4cG9ydHM9QXV0aGVudGljYXRpb25Db250ZXh0LG1vZHVsZS5leHBvcnRzLmluamVjdD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uQ29udGV4dChhKX0pLEF1dGhlbnRpY2F0aW9uQ29udGV4dH0oKTsiLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuNCszMTRlNDgzMVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxudmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdm9pZCAwO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgVFJZX0NBVENIX0VSUk9SID0geyBlcnJvcjogbnVsbCB9O1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIFRSWV9DQVRDSF9FUlJPUi5lcnJvcik7XG4gICAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdm9pZCAwLFxuICAgICAgZmFpbGVkID0gdm9pZCAwO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZS5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFByb21pc2U7XG59KCk7XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IHRoZW47XG5Qcm9taXNlJDEuYWxsID0gYWxsO1xuUHJvbWlzZSQxLnJhY2UgPSByYWNlO1xuUHJvbWlzZSQxLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDEucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDEuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDEuX2FzYXAgPSBhc2FwO1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICB2YXIgbG9jYWwgPSB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBzZWxmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgaWYgKFApIHtcbiAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgfVxuXG4gICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQxO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDEucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UkMS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG5yZXR1cm4gUHJvbWlzZSQxO1xuXG59KSkpO1xuXG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMy4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOC0wMS0yMFQxNzoyNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jLCBub2RlICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggbm9kZVsgaSBdICkge1xuXHRcdFx0XHRcdHNjcmlwdFsgaSBdID0gbm9kZVsgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4zLjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDgtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoXCJmb3JtXCIgaW4gZWxlbSB8fCBcImxhYmVsXCIgaW4gZWxlbSk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwiaWZyYW1lXCIgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuICAgICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYywgbm9kZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSBkaXYub2Zmc2V0V2lkdGggPT09IDM2IHx8IFwiYWJzb2x1dGVcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXG4vLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcblx0aWYgKCAhcmV0ICkge1xuXHRcdHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cdFx0KSApO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94O1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0dmFsdWVJc0JvcmRlckJveCA9IHZhbHVlSXNCb3JkZXJCb3ggJiZcblx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdICk7XG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdGlmICggdmFsID09PSBcImF1dG9cIiB8fFxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkge1xuXG5cdFx0dmFsID0gZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdO1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHByb3ZpZGUgYm9yZGVyLWJveCB2YWx1ZXNcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYm94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpID09PSBzdHlsZXMucG9zaXRpb24gKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLCBldmFsKShcInRoaXNcIik7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJcclxuZXhwb3J0IGNsYXNzIENhcntcclxuICAgIGRyaXZlKCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJicnJycnJtIC4uLi5cIik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBTUFV0aWwgfSBmcm9tIFwiLi91dGlsXCI7XHJcbmltcG9ydCB7IENhciB9IGZyb20gXCIuL2NhclwiO1xyXG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gXCIuL3N0YXRlXCI7XHJcblxyXG5sZXQgc3BVdGlsID0gbmV3IFNQVXRpbCgpO1xyXG5zcFV0aWwubG9nKCk7XHJcblxyXG5zcFV0aWxcclxuICAuZ2V0V2ViVGl0bGVDU09NKClcclxuICAudGhlbihkYXRhID0+IGNvbnNvbGUubG9nKGBXZWIgVGl0bGUgcmVjZWl2ZWQgYnkgQ1NPTSBpczogJHtkYXRhfWApKTtcclxuXHJcbnNwVXRpbC5nZXRXZWJUaXRsZVJFU1QoKTtcclxuXHJcbnNwVXRpbC5nZXROZXdzSXRlbXMoKS50aGVuKChlbnRyaWVzOiBOZXdzRW50cnlbXSkgPT4ge1xyXG4gIGxldCBodG1sID0gXCJcIjtcclxuICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4gKGh0bWwgKz0gYDxkaXY+JHtlbnRyeS5UaXRsZX08L2Rpdj5gKSk7XHJcbiAgbGV0IGRpdlJlc3VsdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcmVzdWx0XCIpO1xyXG4gIGRpdlJlc3VsdC5pbm5lckhUTUwgPSBodG1sO1xyXG59KTtcclxuXHJcbnNwVXRpbC5nZXRMaXN0SXRlbXNQblAoKTtcclxuXHJcbmZ1bmN0aW9uIGRyaXZlUG9yc2NoZSgpIHtcclxuICBsZXQgcG9yc2NoZSA9IG5ldyBDYXIoKTtcclxuICBwb3JzY2hlLmRyaXZlKCk7XHJcbn1cclxuXHJcbi8vZXhwb3J0IG1ldGhvZCB0byBnbG9iYWwgbmFtZXNwYWNlIC0gb3RoZXJ3aXNlIGlzIGlzIG5vdCBhdmFpbGFibGUgZm9yIGZ1bmN0aW9uIGNhbGxcclxuKDxhbnk+d2luZG93KS5kcml2ZSA9IGRyaXZlUG9yc2NoZTtcclxuXHJcbi8vZXhwb3J0aW5nIGFuIG9iamVjdFxyXG4oPGFueT53aW5kb3cpLnN0YXRlID0gbmV3IFN0YXRlKCk7XHJcbiIsImltcG9ydCB7IFNQVXRpbCB9IGZyb20gXCIuL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZSB7XHJcbiAgdXRpbDogU1BVdGlsO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMudXRpbCA9IG5ldyBTUFV0aWwoKTtcclxuICB9XHJcblxyXG4gIGluaXQoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkluaXRpYWxpemluZyBTdGF0ZVwiKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gXCJlczYtcHJvbWlzZVwiO1xyXG5pbXBvcnQgKiBhcyAkIGZyb20gXCJqcXVlcnlcIjtcclxuaW1wb3J0IHsgc3AgfSBmcm9tIFwiQHBucC9zcFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNQVXRpbCB7XHJcbiAgcHJpdmF0ZSBiYXNlVXJsOiBzdHJpbmc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgbGV0IGNvbnRleHQ6IFNQLkNsaWVudENvbnRleHQgPSBTUC5DbGllbnRDb250ZXh0LmdldF9jdXJyZW50KCk7XHJcbiAgICB0aGlzLmJhc2VVcmwgPSBjb250ZXh0LmdldF91cmwoKTtcclxuICB9XHJcblxyXG4gIGxvZygpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiaGVsbG8gd29yZCBsb2dnZWQgZnJvbSBTUFV0aWxcIik7XHJcbiAgfVxyXG5cclxuICBnZXRXZWJUaXRsZUNTT00oKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIGNvbnNvbGUubG9nKFwiRXhlY3V0aW5nIENTT01cIik7XHJcbiAgICAvL3dyYXBwaW5nIGNhbGwgaW4gUHJvbWlzZSAtIG5vdCBuZWNlc3NhcnkgYnV0IG5pY2VyIHRvIHVzZVxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBsZXQgY29udGV4dDogU1AuQ2xpZW50Q29udGV4dCA9IG5ldyBTUC5DbGllbnRDb250ZXh0KHRoaXMuYmFzZVVybCk7XHJcbiAgICAgIGxldCB3ZWI6IFNQLldlYiA9IGNvbnRleHQuZ2V0X3dlYigpO1xyXG4gICAgICBjb250ZXh0LmxvYWQod2ViKTtcclxuICAgICAgY29udGV4dC5leGVjdXRlUXVlcnlBc3luYyhcclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICByZXNvbHZlKHdlYi5nZXRfdGl0bGUoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAoc2VuZGVyLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlcXVlc3QgZmFpbGVkLiBcIiArIGFyZ3MuZ2V0X21lc3NhZ2UoKSk7XHJcbiAgICAgICAgICByZWplY3QoXCJFcnIgaGFwcGVuZWQgLSBzZWUgY29uc29sZSBmb3IgZGV0YWlsc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldFdlYlRpdGxlUkVTVCgpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiZXhlY3V0aW5nIHJlc3RcIik7XHJcbiAgICBsZXQgcXJ5ID0gdGhpcy5iYXNlVXJsICsgXCIvX2FwaS93ZWIvdGl0bGVcIjtcclxuXHJcbiAgICAkLmFqYXgoe1xyXG4gICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICB1cmw6IHFyeSxcclxuICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb247b2RhdGE9dmVyYm9zZVwiXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBXZWIgVGl0bGUgaXM6ICR7ZGF0YS5kLlRpdGxlfWApO1xyXG4gICAgICB9KVxyXG4gICAgICAuZmFpbChlcnIgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0TmV3c0l0ZW1zKCk6IFByb21pc2U8TmV3c0VudHJ5W10+IHtcclxuICAgIGxldCBxcnkgPSBgJHt0aGlzLmJhc2VVcmx9L19hcGkvd2ViL2xpc3RzL2dldGJ5dGl0bGUoJ05ld3MnKS9pdGVtc2A7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAkLmFqYXgoe1xyXG4gICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgdXJsOiBxcnksXHJcbiAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uO29kYXRhPXZlcmJvc2VcIixcclxuICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjtvZGF0YT12ZXJib3NlXCJcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICByZXNvbHZlKDxOZXdzRW50cnlbXT5kYXRhLmQucmVzdWx0cyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZmFpbChlcnIgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldExpc3RJdGVtc1BuUCgpIHtcclxuICAgIGxldCBsaXN0ID0gc3Aud2ViLmxpc3RzLmdldEJ5VGl0bGUoXCJOZXdzXCIpO1xyXG5cclxuICAgIGxpc3QuaXRlbXNcclxuICAgICAgLmdldCgpXHJcbiAgICAgIC50aGVuKGZ1bmN0aW9uKGl0ZW1zKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJJdGVtcyByZWNlaXZlZCB1c2luZyBQblBcIik7XHJcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcykge1xyXG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBpdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHByb3AgKyBcIjogXCIgKyBpdGVtW3Byb3BdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=